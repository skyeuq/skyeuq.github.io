<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS媒体查询与响应式网页</title>
      <link href="/2025/03/31/media/"/>
      <url>/2025/03/31/media/</url>
      
        <content type="html"><![CDATA[<p>在当今这个设备多样化的时代，从手机、平板到桌面显示器，用户的屏幕尺寸和分辨率千差万别。为了提供良好的用户体验，我们需要让网页能够根据设备特性自动调整布局和样式，而这正是 <strong>CSS 媒体查询（Media Queries）</strong> 的用武之地。它是实现响应式网页设计（Responsive Web Design, RWD）的核心技术之一。</p><hr><h2 id="一、什么是媒体查询？"><a href="#一、什么是媒体查询？" class="headerlink" title="一、什么是媒体查询？"></a>一、什么是媒体查询？</h2><p><strong>媒体查询（Media Query）</strong> 是 CSS3 引入的一项特性，允许开发者基于目标设备的“媒体特性”（如宽度、高度、分辨率、方向等）有条件地应用不同的 CSS 样式。</p><p>换句话说，它就像一组“if 判断语句”，能让网页在不同设备上展现最合适的界面。</p><hr><h2 id="二、媒体查询的基本语法"><a href="#二、媒体查询的基本语法" class="headerlink" title="二、媒体查询的基本语法"></a>二、媒体查询的基本语法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> [媒体类型] <span class="keyword">and</span> ([媒体特性]) &#123;</span><br><span class="line">  <span class="comment">/* 条件满足时应用的 CSS */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>媒体类型</strong>：常见的有 <code>all</code>（默认）、<code>screen</code>（屏幕）、<code>print</code>（打印）等。</li><li><strong>媒体特性</strong>：例如 <code>width</code>、<code>max-width</code>、<code>orientation</code>、<code>resolution</code> 等。</li></ul><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>含义：<strong>当屏幕宽度小于等于 768px 时，背景颜色变成浅蓝色</strong>。</p><hr><h2 id="三、CSS-媒体查询特性汇总表（Media-Features）"><a href="#三、CSS-媒体查询特性汇总表（Media-Features）" class="headerlink" title="三、CSS 媒体查询特性汇总表（Media Features）"></a>三、CSS 媒体查询特性汇总表（Media Features）</h2><p>以下是媒体查询支持的完整特性列表（部分支持单位及常用值）：</p><table><thead><tr><th>特性名</th><th>描述</th><th>常用值 &#x2F; 单位</th></tr></thead><tbody><tr><td><code>width</code> &#x2F; <code>height</code></td><td>视口的宽度或高度</td><td><code>px</code>, <code>em</code></td></tr><tr><td><code>min-width</code> &#x2F; <code>max-width</code></td><td>最小&#x2F;最大视口宽度</td><td><code>768px</code>、<code>1024px</code></td></tr><tr><td><code>min-height</code> &#x2F; <code>max-height</code></td><td>最小&#x2F;最大视口高度</td><td><code>500px</code> 等</td></tr><tr><td><code>aspect-ratio</code></td><td>视口宽高比</td><td><code>16/9</code>、<code>4/3</code></td></tr><tr><td><code>min-aspect-ratio</code> &#x2F; <code>max-aspect-ratio</code></td><td>限定宽高比范围</td><td></td></tr><tr><td><code>orientation</code></td><td>屏幕方向</td><td><code>portrait</code>、<code>landscape</code></td></tr><tr><td><code>resolution</code></td><td>屏幕分辨率</td><td><code>96dpi</code>、<code>2dppx</code>、<code>300dpi</code></td></tr><tr><td><code>min-resolution</code> &#x2F; <code>max-resolution</code></td><td>限制分辨率范围</td><td></td></tr><tr><td><code>color</code></td><td>可用颜色位数</td><td><code>8</code>、<code>24</code>（一般不常用）</td></tr><tr><td><code>color-index</code></td><td>可用颜色索引数量（过时）</td><td></td></tr><tr><td><code>monochrome</code></td><td>单色显示位数（主要用于打印设备）</td><td></td></tr><tr><td><code>scan</code></td><td>电视设备的扫描方式（极少使用）</td><td><code>progressive</code>、<code>interlace</code></td></tr><tr><td><code>grid</code></td><td>是否基于栅格设备（打印&#x2F;盲文终端）</td><td><code>0</code>（否）、<code>1</code>（是）</td></tr><tr><td><code>update</code></td><td>设备刷新能力（响应频率）</td><td><code>none</code>、<code>slow</code>、<code>fast</code></td></tr><tr><td><code>overflow-block</code></td><td>纵向溢出是否允许滚动</td><td><code>none</code>、<code>scroll</code>、<code>paged</code></td></tr><tr><td><code>overflow-inline</code></td><td>横向是否允许滚动或分页</td><td>同上</td></tr><tr><td><code>pointer</code></td><td>是否有指针输入设备</td><td><code>none</code>、<code>coarse</code>、<code>fine</code></td></tr><tr><td><code>hover</code></td><td>是否支持悬停</td><td><code>none</code>、<code>hover</code></td></tr><tr><td><code>prefers-color-scheme</code></td><td>用户偏好颜色主题</td><td><code>dark</code>、<code>light</code></td></tr><tr><td><code>prefers-reduced-motion</code></td><td>用户是否偏好减少动画</td><td><code>reduce</code>、<code>no-preference</code></td></tr></tbody></table><blockquote><p>💬并非所有特性在所有设备上都被支持，请使用 DevTools 检查生效情况。</p></blockquote><hr><h2 id="四、逻辑运算符"><a href="#四、逻辑运算符" class="headerlink" title="四、逻辑运算符"></a>四、逻辑运算符</h2><ul><li><code>and</code>：多个条件同时满足时生效</li><li><code>,</code>：类似于 <code>or</code>，任一条件满足即生效</li><li><code>not</code>：逻辑非，条件不满足时生效</li></ul><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>), (<span class="attribute">orientation</span>: portrait) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123; &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五、响应式开发策略：Mobile-First-vs-Desktop-First"><a href="#五、响应式开发策略：Mobile-First-vs-Desktop-First" class="headerlink" title="五、响应式开发策略：Mobile First vs Desktop First"></a>五、响应式开发策略：Mobile First vs Desktop First</h2><p><strong>Mobile First（推荐）</strong>：先写手机端样式，使用 <code>min-width</code> 增强样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 默认手机样式 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 平板及以上 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法清晰且易于维护，适合现代 Web 开发。</p><hr><h2 id="六、实战案例：响应式导航栏"><a href="#六、实战案例：响应式导航栏" class="headerlink" title="六、实战案例：响应式导航栏"></a>六、实战案例：响应式导航栏</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.nav</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.nav</span> <span class="selector-class">.menu</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">gap</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.nav</span> <span class="selector-class">.hamburger</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.nav</span> <span class="selector-class">.menu</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.nav</span> <span class="selector-class">.hamburger</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span>MySite<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>About<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hamburger&quot;</span>&gt;</span>☰<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>👉 拖动浏览器窗口宽度，观察菜单变化。这种设计常用于响应式网页导航栏。</p><hr><h2 id="七、进阶技巧"><a href="#七、进阶技巧" class="headerlink" title="七、进阶技巧"></a>七、进阶技巧</h2><h3 id="1-适配暗色模式（Dark-Mode）"><a href="#1-适配暗色模式（Dark-Mode）" class="headerlink" title="1. 适配暗色模式（Dark Mode）"></a>1. 适配暗色模式（Dark Mode）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#111</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Retina-屏优化"><a href="#2-Retina-屏优化" class="headerlink" title="2. Retina 屏优化"></a>2. Retina 屏优化</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-resolution</span>: <span class="number">2dppx</span>) &#123;</span><br><span class="line">  <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;logo@2x.png&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用-CSS-变量配合媒体查询"><a href="#3-使用-CSS-变量配合媒体查询" class="headerlink" title="3. 使用 CSS 变量配合媒体查询"></a>3. 使用 CSS 变量配合媒体查询</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attr">--font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">var</span>(--font-size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="八、常见断点建议（断点-适配分界线）"><a href="#八、常见断点建议（断点-适配分界线）" class="headerlink" title="八、常见断点建议（断点 &#x3D; 适配分界线）"></a>八、常见断点建议（断点 &#x3D; 适配分界线）</h2><table><thead><tr><th>设备</th><th>建议断点区间</th></tr></thead><tbody><tr><td>手机</td><td><code>max-width: 600px</code></td></tr><tr><td>平板</td><td><code>601px ~ 1024px</code></td></tr><tr><td>小桌面</td><td><code>1025px ~ 1440px</code></td></tr><tr><td>大屏桌面</td><td><code>min-width: 1441px</code></td></tr></tbody></table><hr><h2 id="九、常见错误排查建议"><a href="#九、常见错误排查建议" class="headerlink" title="九、常见错误排查建议"></a>九、常见错误排查建议</h2><ol><li><p>忘记加 viewport 元标签导致移动端样式无效：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>写了媒体查询却没命中选择器（选择器优先级或拼写错误）。</p></li><li><p>媒体查询覆盖不生效，需注意后写样式优先。</p></li><li><p>在组件化开发中（如 Vue&#x2F;React），注意媒体查询是否作用于局部作用域或模块 CSS。</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 媒体查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS杂记</title>
      <link href="/2025/03/31/css1/"/>
      <url>/2025/03/31/css1/</url>
      
        <content type="html"><![CDATA[<h2 id="链接HTML文件与CSS样式表"><a href="#链接HTML文件与CSS样式表" class="headerlink" title="链接HTML文件与CSS样式表"></a>链接HTML文件与CSS样式表</h2><ul><li>在<code>&lt;head&gt;</code>元素里使用<code>&lt;style&gt;</code>元素嵌入样式表</li><li>使用HTML元素的style属性设置样式表</li><li>将样式表放在外部文件，然后使用<code>@import</code>指令导入HTML文件</li><li>将样式表放在外部文件，然后使用<code>&lt;link&gt;</code>元素链接至HTML文件</li></ul><blockquote><p><code>@import</code>和<code>&lt;link&gt;</code>有什么区别？<br>首先，<link> 是 HTML 提供的标签，属于 HTML 语义结构的一部分，能够并行加载 CSS 文件，加载效率更高，浏览器在解析 HTML 时遇到 <link> 标签就会立即开始加载对应的样式文件，有利于页面快速渲染，因此推荐在生产环境中优先使用。而 @import 是 CSS 提供的语法规则，通常用于在一个 CSS 文件中导入另一个 CSS 文件，属于 CSS 级别的语法，加载具有延迟性——只有在外部样式表被解析时才会继续解析 @import 的文件，可能会导致样式闪烁（FOUC）或阻塞渲染，影响性能。此外，旧版本的浏览器（如 IE5）对 @import 的兼容性较差，而 <link> 的兼容性更好也更稳定。从可维护性角度看，@import 常用于将 CSS 文件模块化，结构清晰，但不适合在 HTML 文件中使用。因此在实际开发中，如果是在 HTML 中引入样式，推荐使用 <link>；如果是在 CSS 中组织样式模块，可以使用 @import，但在现代工程化开发中，推荐使用 CSS 预处理器（如 Sass、Less）或模块化方案（如 PostCSS、Vite 等）统一管理样式依赖，更灵活高效。</p></blockquote><h2 id="选择器类型"><a href="#选择器类型" class="headerlink" title="选择器类型"></a>选择器类型</h2><table><thead><tr><th>类型</th><th>选择器</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>万用选择器</td><td><code>*</code></td><td>匹配所有元素</td><td><code>*</code></td></tr><tr><td>元素选择器</td><td><code>h1</code></td><td>匹配指定元素</td><td><code>p</code></td></tr><tr><td>子选择器</td><td><code>&gt;</code></td><td>匹配指定元素的子元素</td><td><code>div &gt; p</code></td></tr><tr><td>后代选择器</td><td>空格</td><td>匹配指定元素的后代元素</td><td><code>div p</code></td></tr><tr><td>相邻兄弟选择器</td><td><code>+</code></td><td>匹配指定元素后面的相邻兄弟元素</td><td><code>div + p</code></td></tr><tr><td>通用兄弟选择器</td><td><code>~</code></td><td>匹配指定元素的所有兄弟元素</td><td><code>div ~ p</code></td></tr><tr><td>类选择器</td><td><code>.</code></td><td>匹配指定类名的元素</td><td><code>.class</code></td></tr><tr><td>ID选择器</td><td><code>#</code></td><td>匹配指定 ID 的元素</td><td><code>#id</code></td></tr><tr><td>属性选择器</td><td><code>[]</code></td><td>匹配指定属性的元素</td><td><code>[attr]</code></td></tr><tr><td>伪类选择器</td><td><code>:</code></td><td>匹配指定状态的元素</td><td><code>:hover</code></td></tr><tr><td>伪元素选择器</td><td><code>::</code></td><td>匹配指定元素的特定部分</td><td><code>::before</code></td></tr></tbody></table><ul><li>详说属性选择器<ul><li><code>[attr]</code>：匹配具有指定属性的元素</li><li><code>[attr=value]</code>：匹配属性值完全等于指定值的元素</li><li><code>[attr~=value]</code>：匹配属性值中包含指定词汇的元素或以空格分隔</li><li><code>[attr|=value]</code>：匹配属性值以指定值开头的元素或以连字符分隔</li><li><code>[attr^=value]</code>：匹配属性值以指定值开头的元素</li><li><code>[attr$=value]</code>：匹配属性值以指定值结尾的元素</li><li><code>[attr*=value]</code>：匹配属性值中包含指定值的元素</li></ul></li><li>详说伪类选择器<ul><li><code>:link</code>：匹配未访问的链接</li><li><code>:visited</code>：匹配已访问的链接</li><li><code>:hover</code>：匹配鼠标悬停的元素</li><li><code>:active</code>：匹配被激活的元素</li><li><code>:focus</code>：匹配获得焦点的元素</li><li><code>:first-child</code>：匹配父元素的第一个子元素</li><li><code>:last-child</code>：匹配父元素的最后一个子元素</li><li><code>:nth-child(n)</code>：匹配父元素的第 n 个子元素</li><li><code>:nth-last-child(n)</code>：匹配父元素的倒数第 n 个子元素</li><li><code>:nth-of-type(n)</code>：匹配父元素的第 n 个指定类型的子元素</li><li><code>:nth-last-of-type(n)</code>：匹配父元素的倒数第 n 个指定类型的子元素</li><li><code>:first-of-type</code>：匹配父元素的第一个指定类型的子元素</li><li><code>:last-of-type</code>：匹配父元素的最后一个指定类型的子元素</li><li><code>:only-child</code>：匹配父元素的唯一子元素</li><li><code>:only-of-type</code>：匹配父元素的唯一指定类型的子元素</li><li><code>:empty</code>：匹配没有子元素的元素</li><li><code>:not(selector)</code>：匹配不符合指定选择器的元素</li><li><code>:enabled</code>：匹配可用的表单元素</li><li><code>:disabled</code>：匹配禁用的表单元素</li><li><code>:checked</code>：匹配被选中的表单元素</li><li><code>:target</code>：匹配当前活动的目标元素</li><li><code>:lang(language)</code>：匹配指定语言的</li></ul></li><li>详说伪元素选择器<ul><li><code>::before</code>：在元素内容之前插入内容</li><li><code>::after</code>：在元素内容之后插入内容</li><li><code>::first-letter</code>：选择元素的第一个字母</li><li><code>::first-line</code>：选择元素的第一行</li><li><code>::selection</code>：选择被用户选取的部分<blockquote><p>伪元素选择器是 CSS 中用于创建和样式化某些“虚拟”元素的一种语法，它不会出现在 DOM 中，但能通过样式实现特定的视觉效果。</p></blockquote></li></ul></li></ul><h2 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h2><p><em><strong>由选择器的“特异性值”决定</strong></em></p><ol><li>内联样式（a）：如 <code>&lt;div style=&quot;color: red;&quot;&gt;</code>，它的优先级最高，特异性是 (1,0,0,0)。</li><li>ID选择器（b）：如 <code>#app</code>，特异性是 (0,1,0,0)，次于内联样式。</li><li>类选择器、伪类、属性选择器（c）：如 <code>.btn、:hover、[type=&quot;text&quot;</code>]，特异性是 (0,0,1,0)。</li><li>元素选择器和伪元素（d）：如 <code>div、h1、::before</code>，特异性是 (0,0,0,1)。</li><li>如果特异性相同，则后写的规则覆盖前写的（就近原则）。</li><li>当然还有一个特殊情况是 !important，它会将样式强制提升为最高优先级，但它不是特异性的一部分，优先级体系之外，一般只在必要场景下使用（如第三方样式覆盖）。</li></ol><h2 id="颜色、字体、文本与列表属性"><a href="#颜色、字体、文本与列表属性" class="headerlink" title="颜色、字体、文本与列表属性"></a>颜色、字体、文本与列表属性</h2><h3 id="颜色属性"><a href="#颜色属性" class="headerlink" title="颜色属性"></a>颜色属性</h3><ul><li><code>color</code>：前景颜色，相对于背景颜色而言，用于设置文本颜色<ul><li>颜色名称：如 <code>red</code>、<code>blue</code>、<code>green</code></li><li>rgb 值：如 <code>rgb(255, 0, 0)</code></li><li>十六进制值：如 <code>#ff0000</code></li><li>rgba 值：如 <code>rgba(255, 0, 0, 0.5)</code></li><li>hsl 值：如 <code>hsl(0, 100%, 50%)</code>，hsl 表示色调、饱和度、亮度</li><li>hsla 值：如 <code>hsla(0, 100%, 50%, 0.5)</code></li></ul></li><li><code>background-color</code>：背景颜色，用于设置元素的背景颜色，默认值是transparent</li><li><code>opacity</code>：透明度，用于设置元素的透明度，取值范围是 0~1，0 表示完全透明，1 表示完全不透明</li></ul><h3 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h3><ul><li><code>font-family</code>：字体系列，用于设置元素的字体系列，如 <code>font-family: Arial, sans-serif;</code></li><li><code>font-size</code>：字体大小，用于设置元素的字体大小，如 <code>font-size: 16px;</code><ul><li>长度值：如 <code>px</code>、<code>em</code>、<code>rem</code></li><li>绝对值：如 <code>xx-small</code>、<code>x-small</code>、<code>small</code>、<code>medium</code>、<code>large</code>、<code>x-large</code>、<code>xx-large</code></li><li>相对值：如 <code>smaller</code>、<code>larger</code></li><li>百分比值：如 <code>100%</code></li></ul></li><li><code>font-weight</code>：字体粗细，用于设置元素的字体粗细，如 <code>font-weight: bold;</code><ul><li>数值：如 <code>100</code>、<code>200</code>、<code>300</code>、<code>400</code>、<code>500</code>、<code>600</code>、<code>700</code>、<code>800</code>、<code>900</code></li><li>关键字：如 <code>normal</code>、<code>bold</code>、<code>bolder</code>、<code>lighter</code></li></ul></li><li><code>font-varient</code>：字体变体，用于设置元素的字体变体，如 <code>font-varient: small-caps;</code><ul><li><code>normal</code>：正常字体</li><li><code>small-caps</code>：小型大写字体</li></ul></li><li><code>line-height</code>：行高，用于设置元素的行高，如 <code>line-height: 1.5;</code><ul><li>数值：如 <code>1.5</code>、<code>2</code></li><li>百分比值：如 <code>150%</code>、<code>200%</code></li><li>长度值：如 <code>px</code>、<code>em</code></li><li><code>normal</code>：默认行高</li></ul></li></ul><blockquote><table><thead><tr><th>类型</th><th>单位</th><th>含义&#x2F;全称</th><th>换算关系</th><th>参考对象</th></tr></thead><tbody><tr><td><strong>绝对单位</strong></td><td><code>px</code></td><td>像素（Pixel）</td><td>屏幕逻辑像素</td><td>屏幕</td></tr><tr><td></td><td><code>pt</code></td><td>点（Point）</td><td>1pt &#x3D; 1&#x2F;72 inch</td><td>印刷单位</td></tr><tr><td></td><td><code>pc</code></td><td>派卡（Pica）</td><td>1pc &#x3D; 12pt &#x3D; 1&#x2F;6 inch</td><td>印刷单位</td></tr><tr><td></td><td><code>in</code></td><td>英寸（Inch）</td><td>1in &#x3D; 96px &#x3D; 2.54cm</td><td>实体长度</td></tr><tr><td></td><td><code>cm</code></td><td>厘米（Centimeter）</td><td>1cm ≈ 37.8px</td><td>实体长度</td></tr><tr><td></td><td><code>mm</code></td><td>毫米（Millimeter）</td><td>1mm &#x3D; 1&#x2F;10 cm</td><td>实体长度</td></tr><tr><td><strong>相对单位</strong></td><td><code>%</code></td><td>百分比</td><td>相对于父元素的对应属性</td><td>布局、宽高、边距等</td></tr><tr><td></td><td><code>em</code></td><td>相对于当前元素的字体大小</td><td>所使用字体的大写英文字母M的宽度</td><td>字体大小、内边距、margin 等</td></tr><tr><td></td><td><code>rem</code></td><td>根元素字体大小（root em）</td><td>根元素 <code>&lt;html&gt;</code> 的 <code>font-size</code></td><td>响应式字体&#x2F;布局推荐用法</td></tr><tr><td></td><td><code>vw</code></td><td>视口宽度的百分比</td><td>1vw &#x3D; 1% 视口宽度</td><td>响应式横向布局，适配各种屏幕</td></tr><tr><td></td><td><code>vh</code></td><td>视口高度的百分比</td><td>1vh &#x3D; 1% 视口高度</td><td>响应式全屏布局</td></tr><tr><td></td><td><code>vmin</code></td><td>较小的视口边（vw或vh）</td><td><code>min(vw, vh)</code></td><td>保证元素在所有设备上适配</td></tr><tr><td></td><td><code>vmax</code></td><td>较大的视口边（vw或vh）</td><td><code>max(vw, vh)</code></td><td>用于控制最大比例布局</td></tr><tr><td></td><td><code>ch</code></td><td>“0”字符的宽度</td><td>当前字体中数字“0”的宽度</td><td>表单输入宽度、等宽排版</td></tr><tr><td></td><td><code>ex</code></td><td>“x”字符的高度</td><td>当前字体中小写“x”的高度</td><td>罕见用法，依赖字体</td></tr><tr><td></td><td><code>fr</code></td><td>Fraction（分数单位）</td><td>Grid 剩余空间的分配单位</td><td>Grid 布局下分配空间，响应式布局利器</td></tr></tbody></table></blockquote><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><ul><li><code>text-align</code>：文本对齐方式，用于设置元素内文本的对齐方式，如 <code>text-align: center;</code><ul><li><code>left</code>：左对齐</li><li><code>right</code>：右对齐</li><li><code>center</code>：居中对齐</li><li><code>justify</code>：两端对齐</li></ul></li><li><code>text-indent</code>：文本缩进，用于设置元素内文本的首行缩进，如 <code>text-indent: 2em;</code></li><li><code>text-decoration</code>：文本装饰，用于设置元素内文本的装饰效果，如 <code>text-decoration: underline wavy red;</code><ul><li><code>none</code>：无装饰</li><li><code>underline</code>：下划线</li><li><code>overline</code>：上划线</li><li><code>line-through</code>：删除线</li><li><code>text-decoration-color</code>：装饰线颜色</li><li><code>text-decoration-style</code>：装饰线样式, 如 <code>dotted</code>、<code>dashed</code>、<code>solid</code>、<code>double</code>、<code>wavy</code></li></ul></li><li><code>lettter-spacing</code>：字母间距，用于设置元素内文本的字母间距，如 <code>letter-spacing: 2px;</code></li><li><code>word-spacing</code>：单词间距，用于设置元素内文本的单词间距，如 <code>word-spacing: 2px;</code></li><li><code>text-transform</code>：文本转换，用于设置元素内文本的大小写转换，如 <code>text-transform: uppercase;</code><ul><li><code>none</code>：无转换</li><li><code>uppercase</code>：大写</li><li><code>lowercase</code>：小写</li><li><code>capitalize</code>：首字母大写</li></ul></li><li><code>white-space</code>：空白处理，用于设置元素内文本的空白处理方式，如 <code>white-space: nowrap;</code><ul><li><code>normal</code>：默认处理方式</li><li><code>nowrap</code>：不换行</li><li><code>pre</code>：保留空白</li><li><code>pre-line</code>：保留换行</li><li><code>pre-wrap</code>：保留空白和换行</li></ul></li><li><code>text-shadow</code>：文本阴影，用于设置元素内文本的阴影效果，如 <code>text-shadow: 2px 2px 2px #000;</code>, 水平位移、垂直位移、模糊半径、阴影颜色</li></ul><h3 id="列表属性"><a href="#列表属性" class="headerlink" title="列表属性"></a>列表属性</h3><ul><li><code>list-style-type</code>：列表标记类型，用于设置列表项的标记类型，如 <code>list-style-type: disc;</code><ul><li><code>disc</code>：实心圆</li><li><code>circle</code>：空心圆</li><li><code>square</code>：实心方块</li><li><code>decimal</code>：数字</li><li><code>decimal-leading-zero</code>：数字前补零</li><li><code>lower-roman</code>：小写罗马数字</li><li><code>upper-roman</code>：大写罗马数字</li><li><code>lower-alpha</code>：小写字母</li><li><code>upper-alpha</code>：大写字母</li><li><code>none</code>：无标记</li></ul></li><li><code>list-style-image</code>：列表标记图片，用于设置列表项的标记图片，如 <code>list-style-image: url(&#39;list.png&#39;);</code></li><li><code>list-style-position</code>：列表标记位置，用于设置列表项的标记位置，如 <code>list-style-position: inside;</code><ul><li><code>inside</code>：内部</li><li><code>outside</code>：外部</li></ul></li></ul><h2 id="盒模型与布局属性"><a href="#盒模型与布局属性" class="headerlink" title="盒模型与布局属性"></a>盒模型与布局属性</h2><h3 id="Box-Model"><a href="#Box-Model" class="headerlink" title="Box Model"></a>Box Model</h3><ul><li><code>content</code>：内容区域，用于显示元素的内容，如 <code>width</code>、<code>height</code>，<code>min-width</code>、<code>max-width</code>、<code>min-height</code>、<code>max-height</code> 用于设置元素的最小宽度、最大宽度、最小高度、最大高度。<code>overflow</code> 用于设置元素内容溢出时的处理方式，如 <code>overflow: hidden;</code>、<code>overflow: auto;</code>、<code>overflow: scroll;</code></li><li><code>padding</code>：内边距区域，用于设置元素内边距，如 <code>padding: 10px;</code></li><li><code>border</code>：边框区域，用于设置元素边框，如 <code>border: 1px solid #000;</code>（solid、dotted、dashed、double、groove、ridge、inset、outset）</li><li><code>margin</code>：外边距区域，用于设置元素外边距，如 <code>margin: 10px;</code></li></ul><p><strong>边界重叠：当两个或多个垂直外边距相遇时，它们将合并为一个外边距，合并后的外边距为相遇外边距中的最大外边距，这种现象称为边界重叠。</strong></p><h3 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h3><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><ul><li><code>block</code>: 区块层级，可以设置宽度高度留白与边界</li><li><code>inline</code>: 行内层级，不可以设置宽度高度留白与边界</li><li><code>inline-block</code>: 行内块层级，可以设置宽度高度留白与边界</li><li><code>none</code>: 不占据空间</li></ul><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><ul><li><code>static</code>: 默认定位，元素按照文档流排列</li><li><code>relative</code>: 相对定位，元素相对于自身原始位置定位</li><li><code>absolute</code>: 绝对定位，元素相对于最近的非static定位祖先元素定位</li><li><code>fixed</code>: 固定定位，元素相对于视口定位</li><li><code>sticky</code>: 粘性定位，元素相对于视口定位，直到滚动到指定位置</li></ul><p>top、right、bottom、left：用于设置元素的定位偏移量，如 <code>top: 10px;</code>，只有在设置了定位属性后才能使用。</p><p><code>z-index</code>：用于设置元素的堆叠顺序，数值越大越靠前，如 <code>z-index: 1;</code>，只有在设置了定位属性后才能使用。</p><p><code>float</code>：用于设置元素的浮动方式，如 <code>float: left;</code>，取值有 <code>left</code>、<code>right</code>、<code>none</code>，<code>clear</code> 用于设置元素的浮动清除方式，如 <code>clear: both;</code></p><p><code>visibility</code>：用于设置元素的可见性，如 <code>visibility: hidden;</code>，取值有 <code>visible</code>、<code>hidden</code></p><p><code>box-shadow</code>：用于设置元素的阴影效果，如 <code>box-shadow: 2px 2px 2px #000;</code>，水平位移、垂直位移、模糊半径、阴影颜色</p><p><code>vertical-align</code>：用于设置元素的垂直对齐方式，如 <code>vertical-align: middle;</code>，取值有 <code>baseline</code>、<code>top</code>、<code>middle</code>、<code>bottom</code>、<code>text-top</code>、<code>text-bottom</code></p><blockquote><hr><h3 id="什么是-float"><a href="#什么是-float" class="headerlink" title="什么是 float"></a>什么是 <code>float</code></h3><p><code>float</code> 原本的设计初衷是让元素<strong>浮动在文字周围</strong>，最初用于实现图文混排（如图像左浮动，文字右环绕），当我们给元素设置 <code>float: left</code> 或 <code>float: right</code> 后，它就会：</p><ul><li><strong>脱离标准文档流</strong>（不会再占据原本位置）；</li><li>在容器中向左或右浮动，后续的非浮动元素会围绕它排列；</li><li><strong>仍然保留在 DOM 结构中</strong>，但对兄弟元素的布局产生影响；</li><li>它的父元素若没有特殊处理，<strong>将不再被它撑开高度</strong>，这就是所谓“高度塌陷”问题。</li></ul><hr><h3 id="什么是-clear"><a href="#什么是-clear" class="headerlink" title="什么是 clear"></a>什么是 <code>clear</code></h3><p><code>clear</code> 是专门用来<strong>控制元素是否可以出现在浮动元素旁边</strong>的属性，它的作用是“<strong>清除前面浮动元素对我的影响</strong>”，可选值包括：</p><ul><li><code>clear: left</code>：不允许出现在左侧有浮动的元素旁；</li><li><code>clear: right</code>：不允许出现在右侧有浮动的元素旁；</li><li><code>clear: both</code>：两边都不允许，必须换行到浮动元素的下方；</li><li><code>clear: none</code>：默认值，不清除任何浮动影响。</li></ul><hr><h3 id="二者关系和实际用途"><a href="#二者关系和实际用途" class="headerlink" title="二者关系和实际用途"></a>二者关系和实际用途</h3><ul><li><code>float</code> 用于<strong>创建浮动布局</strong>，比如实现横向排列、图文环绕；</li><li><code>clear</code> 用于<strong>清除浮动影响</strong>，保证某些元素不会被环绕，或者用于“清除浮动”本身；</li><li>清除浮动的典型场景是<strong>父元素被浮动子元素高度塌陷</strong>，这时我们会在父元素内部末尾添加一个设置了 <code>clear: both</code> 的元素（推荐用伪元素），如：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>  修改 display 会触发 重排（reflow） 和 重绘（repaint），因为它会影响元素是否参与布局（布局树会发生变化）；<br>   修改 visibility 只会触发 重绘（repaint），不会触发重排，因为它不会影响布局，仅仅是改变了元素是否可见。</p></blockquote><h2 id="背景、渐层与表格"><a href="#背景、渐层与表格" class="headerlink" title="背景、渐层与表格"></a>背景、渐层与表格</h2><h3 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h3><ul><li><code>background-image</code>：背景图片，用于设置元素的背景图片，如 <code>background-image: url(&#39;bg.png&#39;);</code></li><li><code>background-repeat</code>：背景重复，用于设置元素的背景图片重复方式，如 <code>background-repeat: no-repeat;</code><ul><li><code>repeat</code>：默认值，横向纵向都重复</li><li><code>repeat-x</code>：横向重复</li><li><code>repeat-y</code>：纵向重复</li><li><code>no-repeat</code>：不重复</li><li><code>space</code>：平铺，间距相等，调整间距让图片铺满</li><li><code>round</code>：平铺，间距不等，调整大小让图片铺满</li></ul></li><li><code>background-position</code>：背景位置，用于设置元素的背景图片位置，如 <code>background-position: center center;</code><ul><li><code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>、<code>center</code></li><li>百分比值：如 <code>50% 50%</code></li><li>长度值：如 <code>10px 20px</code> ，第一个值是水平位置，第二个值是垂直位置</li></ul></li><li><code>background-attachment</code>：背景附着，用于设置元素的背景图片是否随元素滚动，如 <code>background-attachment: fixed;</code><ul><li><code>scroll</code>：默认值，背景图片随元素滚动</li><li><code>fixed</code>：背景图片固定在视口</li><li><code>local</code>：背景图片随元素滚动</li></ul></li><li><code>background-clip</code>：背景显示区域，如 <code>background-clip: padding-box;</code><ul><li><code>border-box</code>：默认值，描绘到边框盒</li><li><code>padding-box</code>：描绘到内边距盒</li><li><code>content-box</code>：描绘到内容盒</li></ul></li><li><code>background-origin</code>：背景原点，用于设置元素的背景图片定位原点，如 <code>background-origin: padding-box;</code><ul><li><code>border-box</code>：默认值，背景图片定位原点在边框盒</li><li><code>padding-box</code>：背景图片定位原点在内边距盒</li><li><code>content-box</code>：背景图片定位原点在内容盒</li></ul></li><li><code>background-size</code>：背景尺寸，用于设置元素的背景图片尺寸，如 <code>background-size: cover;</code><ul><li><code>auto</code>：默认值，保持原始尺寸</li><li><code>cover</code>：图片等比例缩放，覆盖整个容器</li><li><code>contain</code>：图片等比例缩放，适应容器</li><li>百分比值：如 <code>50% 50%</code>，第一个值是宽度，第二个值是高度</li><li>长度值：如 <code>100px 200px</code>，第一个值是宽度，第二个值是高度</li></ul></li></ul><h3 id="渐变属性"><a href="#渐变属性" class="headerlink" title="渐变属性"></a>渐变属性</h3><ul><li><code>linear-gradient</code>：线性渐变，用于设置元素的背景线性渐变效果，如 <code>linear-gradient(to right, red, blue);</code><ul><li><code>to top</code>、<code>to right</code>、<code>to bottom</code>、<code>to left</code>、<code>to top right</code>、<code>to top left</code>、<code>to bottom right</code>、<code>to bottom left</code></li><li><code>angle</code>：如 <code>45deg</code>、<code>90deg</code></li></ul></li><li><code>radial-gradient</code>：放射状渐变，用于设置元素的背景放射状渐变效果，如 <code>radial-gradient(circle, red, blue);</code><ul><li><code>circle</code>、<code>ellipse</code>是渐变形状</li><li><code>closest-side</code>、<code>closest-corner</code>、<code>farthest-side</code>、<code>farthest-corner</code>是渐变大小</li><li><code>at</code>：如 <code>at 50% 50%</code>，渐变中心点</li></ul></li><li><code>repeating-linear-gradient</code>：重复线性渐变，用于设置元素的背景重复线性渐变效果，如 <code>repeating-linear-gradient(to right, red, blue);</code></li><li><code>repeating-radial-gradient</code>：重复放射状渐变，用于设置元素的背景重复放射状渐变效果，如 <code>repeating-radial-gradient(circle, red, blue);</code></li></ul><h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><ul><li><code>caption-side</code>：表格标题位置，用于设置表格标题的位置，如 <code>caption-side: bottom;</code><ul><li><code>top</code>：顶部</li><li><code>bottom</code>：底部</li></ul></li><li><code>border-collapse</code>：边框合并，用于设置表格边框合并方式，如 <code>border-collapse: collapse;</code><ul><li><code>separate</code>：默认值，边框分开</li><li><code>collapse</code>：边框合并</li></ul></li><li><code>table-layout</code>：表格布局，用于设置表格布局方式，如 <code>table-layout: fixed;</code><ul><li><code>auto</code>：默认值，根据内容自动调整</li><li><code>fixed</code>：固定布局，根据表格宽度和列宽度确定单元格宽度</li></ul></li><li><code>empty-cells</code>：空单元格，用于设置表格空单元格显示方式，如 <code>empty-cells: hide;</code><ul><li><code>show</code>：默认值，显示空单元格</li><li><code>hide</code>：隐藏空单元格</li></ul></li><li><code>border-spacing</code>：边框间距，用于设置表格边框间距，如 <code>border-spacing: 10px;</code></li></ul><h2 id="变形、转场"><a href="#变形、转场" class="headerlink" title="变形、转场"></a>变形、转场</h2><h3 id="变形处理"><a href="#变形处理" class="headerlink" title="变形处理"></a>变形处理</h3><ul><li><code>transform</code>：变形效果，用于设置元素的变形效果，如 <code>transform: rotate(45deg);</code><ul><li><code>rotate(angle)</code>：旋转，顺时针旋转angle角度</li><li><code>scale(x, y)</code>：缩放，横向缩放x倍，纵向缩放y倍</li><li><code>translate(x, y)</code>：平移，横向平移x距离，纵向平移y距离</li><li><code>skew(x-angle, y-angle)</code>：倾斜，横向倾斜x-angle角度，纵向倾斜y-angle角度</li><li><code>matrix(a, b, c, d, e, f)</code>：矩阵变形</li></ul></li><li><code>transform-origin</code>：变形原点，用于设置元素的变形原点，如 <code>transform-origin: 50% 50%;</code><ul><li>百分比值：如 <code>50% 50%</code></li><li>长度值：如 <code>100px 200px</code>，第一个值是水平位置，第二个值是垂直位置</li></ul></li></ul><h3 id="转场效果"><a href="#转场效果" class="headerlink" title="转场效果"></a>转场效果</h3><ul><li><code>transition</code>：转场效果，用于设置元素的转场效果，如 <code>transition: width 1s;</code><ul><li><code>transition-property</code>：转场属性，如 <code>transition-property: width;</code><ul><li><code>all</code>：所有属性</li><li><code>none</code>：无属性</li></ul></li><li><code>transition-duration</code>：转场时长，如 <code>transition-duration: 1s;</code></li><li><code>transition-timing-function</code>：转场速度曲线，如 <code>transition-timing-function: ease;</code><ul><li><code>ease</code>：默认值，慢速开始，然后变快，然后慢速结束</li><li><code>linear</code>：匀速</li><li><code>ease-in</code>：慢速开始</li><li><code>ease-out</code>：慢速结束</li><li><code>ease-in-out</code>：慢速开始和结束</li></ul></li><li><code>transition-delay</code>：转场延迟时间，如 <code>transition-delay: 0.5s;</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML的碎碎念</title>
      <link href="/2025/03/30/html/"/>
      <url>/2025/03/30/html/</url>
      
        <content type="html"><![CDATA[<h2 id="搜索引擎优化SEO"><a href="#搜索引擎优化SEO" class="headerlink" title="搜索引擎优化SEO"></a>搜索引擎优化SEO</h2><p>大多数网站的新浏览者大都来自搜索引擎，而且搜索引擎的用户往往只会留意搜索结果中排名前面的几个网站，因此网站的拥有者不仅要到各大搜索引擎进行登录，还要设法提高网站在搜索结果中的排名。</p><p>搜索引擎优化（SEO）是指通过优化网站结构、内容和性能，使其更容易被搜索引擎识别和索引，从而提高网站在搜索结果中的排名。单页应用（SPA）通常通过 JavaScript 动态渲染内容，搜索引擎在抓取页面时可能无法获取完整的内容，导致内容难以被及时抓取和索引，从而影响 SEO 效果，可以使用服务器端渲染（SSR）或预渲染等技术进行优化。</p><p>SSR（Server-Side Rendering，服务端渲染）是一种由服务器在请求时生成完整 HTML 页面的技术。具体来说，当用户访问一个页面时，服务器会先将 JavaScript 渲染出的页面内容生成静态 HTML 返回给浏览器，浏览器拿到后直接展示，再通过 JavaScript 激活页面上的交互功能（称为 hydration）。</p><h2 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h2><ul><li><code>accessKey</code>：设置将焦点移到元素的按键组合</li><li><code>contentEditable=&quot;&#123; true, false, inherit &#125;&quot;</code>：设置元素是否可编辑</li><li><code>dir=&quot;&#123; ltr, rtl, auto &#125;&quot;</code>：设置元素文本方向</li><li><code>draggable=&quot;&#123; true, false &#125;&quot;</code>：设置元素是否可拖动</li><li><code>hidden</code>：隐藏元素</li><li><code>id</code>：设置元素的唯一标识</li><li><code>lang</code>：设置元素的语言</li><li><code>spellcheck=&quot;&#123; true, false &#125;&quot;</code>：设置元素是否进行拼写检查</li><li><code>style</code>：设置元素的行内样式</li><li><code>tabindex=&quot;n&quot;</code>：设置元素的 tab 键次序</li></ul><h2 id=""><a href="#" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h2><ul><li><code>background</code> 属性：设置页面的背景颜色或背景图片</li><li><code>bgcolor</code> 属性：设置页面的背景颜色</li><li><code>text</code> 属性：设置页面的文本颜色</li><li><code>link</code> 属性：设置页面的链接颜色</li><li><code>alink</code> 属性：设置页面的活动链接颜色</li><li><code>vlink</code> 属性：设置页面的已访问链接颜色<br>在 HTML4 中，这些属性是 <code>&lt;body&gt;</code> 元素的属性，但在 HTML5 中已经被废弃，推荐使用 CSS 来设置样式。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#00f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#551a8b</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">    <span class="attribute">outline</span>: <span class="number">1px</span> dotted <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="-1"><a href="#-1" class="headerlink" title="&lt;p&gt;"></a><code>&lt;p&gt;</code></h2><ul><li>text-align 属性：设置段落的文本对齐方式</li><li>line-height 属性：设置段落的行高</li><li>text-indent 属性：设置段落的首行缩进</li><li>word-spacing 属性：设置段落的单词间距</li><li>letter-spacing 属性：设置段落的字母间距</li><li>text-transform 属性：设置段落的文本转换方式</li><li>text-decoration 属性：设置段落的文本装饰方式,如下划线、删除线等</li></ul><blockquote><p>块级标签（Block-level Elements）和行内标签（Inline Elements）是 HTML 中两类常见元素，它们的默认表现不同：块级元素独占一行，常用于结构布局；行内元素不会换行，常用于文本内嵌。</p><p><strong>常见的块级标签包括：</strong></p><ul><li><code>&lt;div&gt;</code>：通用容器</li><li><code>&lt;p&gt;</code>：段落</li><li><code>&lt;h1&gt;</code>～<code>&lt;h6&gt;</code>：标题</li><li><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>：列表及项</li><li><code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>：语义化布局元素</li><li><code>&lt;table&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;fieldset&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;main&gt;</code> 等也属于块级元素</li></ul><p><strong>常见的行内标签包括：</strong></p><ul><li><code>&lt;span&gt;</code>：通用文本容器</li><li><code>&lt;a&gt;</code>：超链接</li><li><code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>：加粗文本</li><li><code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>：强调或斜体</li><li><code>&lt;img&gt;</code>：图片</li><li><code>&lt;input&gt;</code>、<code>&lt;label&gt;</code>、<code>&lt;select&gt;</code>（尽管 <code>select</code> 视觉上可能较大，但仍属行内）</li><li><code>&lt;abbr&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;code&gt;</code>、<code>&lt;small&gt;</code> 等也都是行内元素</li></ul></blockquote><h2 id="及html5语义化"><a href="#及html5语义化" class="headerlink" title="&lt;div&gt;及html5语义化"></a><code>&lt;div&gt;</code>及html5语义化</h2><p>HTML5 语义化是指使用具有语义的标签（如 <code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;nav&gt;</code> 等）来构建页面结构，使代码更具可读性、结构更清晰，便于开发者理解和维护。</p><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;article&gt;"></a><code>&lt;article&gt;</code></h3><p><code>&lt;article&gt;</code> 元素表示页面中独立的、完整的内容单元，如一篇博客文章、一则新闻、一篇论坛帖子等。<code>&lt;article&gt;</code> 元素可以包含标题、作者、发布日期等信息，也可以包含评论、标签等相关内容。</p><h3 id="-3"><a href="#-3" class="headerlink" title="&lt;section&gt;"></a><code>&lt;section&gt;</code></h3><p><code>&lt;section&gt;</code> 元素表示页面中的一个区块，将网页文本分割成不同的 主题区段，或将一篇文章分成不同的章节和段落。</p><h3 id="-4"><a href="#-4" class="headerlink" title="&lt;nav&gt;"></a><code>&lt;nav&gt;</code></h3><p><code>&lt;nav&gt;</code> 元素表示页面中的导航部分，通常包含一组链接，用于帮助用户浏览或导航到其他页面。</p><h3 id="和"><a href="#和" class="headerlink" title="&lt;header&gt;和&lt;footer&gt;"></a><code>&lt;header&gt;</code>和<code>&lt;footer&gt;</code></h3><p><code>&lt;footer&gt;</code> 元素表示页面或区块的页脚，通常包含版权信息、联系方式、相关链接等内容。</p><p><code>&lt;header&gt;</code> 元素表示页面或区块的页眉，通常包含标题、标语、导航等内容。</p><h3 id="-5"><a href="#-5" class="headerlink" title="&lt;aside&gt;"></a><code>&lt;aside&gt;</code></h3><p><code>&lt;aside&gt;</code> 元素表示页面中的侧边栏、广告、相关链接等内容，通常与主要内容相关，但可以独立于主要内容。</p><h3 id="-6"><a href="#-6" class="headerlink" title="&lt;main&gt;"></a><code>&lt;main&gt;</code></h3><p><code>&lt;main&gt;</code> 元素表示页面的主要内容，一个页面中只能包含一个 <code>&lt;main&gt;</code> 元素，用于包裹页面的主要内容部分。</p><h2 id="区段格式"><a href="#区段格式" class="headerlink" title="区段格式"></a>区段格式</h2><h3 id="-7"><a href="#-7" class="headerlink" title="&lt;pre&gt;"></a><code>&lt;pre&gt;</code></h3><p><code>&lt;pre&gt;</code> 元素表示预格式化文本，文本中的空格、换行符等会被保留，文本内容会按照原始格式显示。</p><h3 id="-8"><a href="#-8" class="headerlink" title="&lt;blockquote&gt;"></a><code>&lt;blockquote&gt;</code></h3><p><code>&lt;blockquote&gt;</code> 元素表示长引用，通常用于引用其他来源的内容，左右缩进显示。</p><h3 id="-9"><a href="#-9" class="headerlink" title="&lt;address&gt;"></a><code>&lt;address&gt;</code></h3><p><code>&lt;address&gt;</code> 元素表示联系信息，通常用于包含作者、版权、联系方式等信息。</p><h3 id="-10"><a href="#-10" class="headerlink" title="&lt;hr&gt;"></a><code>&lt;hr&gt;</code></h3><p><code>&lt;hr&gt;</code> 元素表示水平分隔线，用于分隔内容。</p><h2 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h2><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><ul><li><code>&lt;b&gt;</code>：加粗文本</li><li><code>&lt;i&gt;</code>：斜体文本</li><li><code>&lt;u&gt;</code>：下划线文本</li><li><code>&lt;s&gt;</code>：删除线文本</li><li><code>&lt;sub&gt;</code>：下标文本</li><li><code>&lt;sup&gt;</code>：上标文本</li><li><code>&lt;strong&gt;</code>：强调文本</li><li><code>&lt;em&gt;</code>：强调文本</li><li><code>&lt;small&gt;</code>：小号文本</li><li><code>&lt;dfn&gt;</code>：定义文本</li><li><code>&lt;code&gt;</code>：计算机代码文本</li><li><code>&lt;kbd&gt;</code>：键盘文本</li><li><code>&lt;var&gt;</code>：变量文本</li><li><code>&lt;samp&gt;</code>：样例文本</li><li><code>&lt;cite&gt;</code>：引用文本</li><li><code>&lt;abbr&gt;</code>：缩写文本</li><li><code>&lt;q&gt;</code>：短引用文本</li><li><code>&lt;mark&gt;</code>：标记文本</li></ul><h3 id="-11"><a href="#-11" class="headerlink" title="&lt;br&gt;"></a><code>&lt;br&gt;</code></h3><p><code>&lt;br&gt;</code> 元素表示换行，用于在文本中插入换行符。</p><h3 id="-12"><a href="#-12" class="headerlink" title="&lt;span&gt;"></a><code>&lt;span&gt;</code></h3><p><code>&lt;span&gt;</code> 元素表示行内文本容器，通常用于设置文本样式或添加事件处理。</p><h3 id="-13"><a href="#-13" class="headerlink" title="&lt;time&gt;"></a><code>&lt;time&gt;</code></h3><p><code>&lt;time&gt;</code> 元素表示日期或时间，用于标记时间戳、日期、时间等信息。属性 <code>datetime</code> 用于指定时间戳，机器可以识别，而内容中的时间可以是人类可读的格式。</p><h3 id="和-1"><a href="#和-1" class="headerlink" title="&lt;ins&gt;和&lt;del&gt;"></a><code>&lt;ins&gt;</code>和<code>&lt;del&gt;</code></h3><p><code>&lt;ins&gt;</code> 元素表示插入文本，通常显示为下划线；<code>&lt;del&gt;</code> 元素表示删除文本，通常显示为删除线。</p><h3 id="、和"><a href="#、和" class="headerlink" title="&lt;ul&gt;、&lt;ol&gt;和&lt;li&gt;"></a><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>和<code>&lt;li&gt;</code></h3><p><code>&lt;ul&gt;</code> 元素表示无序列表，列表项使用 <code>&lt;li&gt;</code> 元素表示；<code>&lt;ol&gt;</code> 元素表示有序列表，列表项使用 <code>&lt;li&gt;</code> 元素表示。</p><p><code>&lt;ol&gt;</code>的属性有type和start，type表示列表的类型，start表示列表的起始值。比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;A&quot;</span> <span class="attr">start</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  //C</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  //D</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p><code>&lt;dl&gt;</code> 元素表示定义列表，包含术语（<code>&lt;dt&gt;</code> 元素）和解释（<code>&lt;dd&gt;</code> 元素）。</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p><code>&lt;a&gt;</code> 元素表示超链接，用于跳转到其他页面或下载文件。<code>&lt;a&gt;</code> 元素的 <code>href</code> 属性用于指定链接地址，<code>target</code> 属性用于指定链接打开方式。</p><table><thead><tr><th>target 属性值</th><th>描述</th></tr></thead><tbody><tr><td>_blank</td><td>在新窗口中打开链接</td></tr><tr><td>_self</td><td>在当前窗口中打开链接</td></tr><tr><td>_parent</td><td>在父窗口中打开链接</td></tr><tr><td>_top</td><td>在顶层窗口中打开链接</td></tr></tbody></table><p><em><strong>页内超链接</strong></em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#section1&quot;</span>&gt;</span>跳转到第一节<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;section1&quot;</span>&gt;</span>第一节<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果标识符在其他文件则需要在前面加上文件名，如<code>&lt;a href=&quot;file.html#section1&quot;&gt;跳转到第一节&lt;/a&gt;</code></p><h3 id="-14"><a href="#-14" class="headerlink" title="&lt;base&gt;"></a><code>&lt;base&gt;</code></h3><p><code>&lt;base&gt;</code> 元素用于指定文档中所有相对 URL 的基准地址，它必须位于 <code>&lt;head&gt;</code> 中，且只能有一个。当页面中存在相对路径的链接、图片或脚本资源时，浏览器会以 <code>&lt;base&gt;</code> 的 href 属性作为它们的起点进行解析。如果未设置 <code>&lt;base&gt;</code>，则默认以当前文档的 URL 为基准路径。使用不当可能会导致资源加载异常，因此要谨慎使用。</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="-15"><a href="#-15" class="headerlink" title="&lt;img&gt;"></a><code>&lt;img&gt;</code></h3><p><strong>属性</strong></p><ul><li><code>src</code>：图片地址</li><li><code>alt</code>：替代文本</li><li><code>width</code>：宽度</li><li><code>height</code>：高度</li><li><code>ismap</code>：是否为服务器端图像映射</li><li><code>usemap</code>：映射名称</li></ul><h3 id="和-2"><a href="#和-2" class="headerlink" title="&lt;figure&gt;和&lt;figcaption&gt;"></a><code>&lt;figure&gt;</code>和<code>&lt;figcaption&gt;</code></h3><p><code>&lt;figure&gt;</code> 元素表示独立的内容块，通常包含图片、图表、代码等内容，可以使用 <code>&lt;figcaption&gt;</code> 元素为其添加标题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>图片标题<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li><code>&lt;table&gt;</code><br><code>&lt;table&gt;</code> 元素表示表格，包含一组行（<code>&lt;tr&gt;</code> 元素），每行包含一组单元格（<code>&lt;td&gt;</code> 元素）。<strong>border-collapse</strong> 属性用于设置表格边框的合并方式，<strong>border-spacing</strong> 属性用于设置表格边框的间距。</li><li><code>&lt;tr&gt;</code><br><code>&lt;tr&gt;</code> 元素表示表格中的一行，包含一组单元格（<code>&lt;td&gt;</code> 元素）。</li><li><code>&lt;td&gt;</code><br><code>&lt;td&gt;</code> 元素表示表格中的一个单元格，包含表格中的数据。</li><li><code>&lt;th&gt;</code><br><code>&lt;th&gt;</code> 元素表示表格中的表头单元格，通常显示为粗体居中文本。</li></ul><p>属性 <code>colspan</code> 和 <code>rowspan</code> 用于设置单元格跨列和跨行，<code>scope</code> 属性用于指定表头单元格的作用范围，<code>headers</code> 属性用于指定与表头单元格关联的数据单元格，<code>abbr</code> 属性用于指定单元格的缩写。</p><p><strong>直列式表格</strong><br>针对列来处理，<code>&lt;colgroup&gt;</code> 元素表示表格中的一列或多列，<code>&lt;col&gt;</code> 元素表示表格中的一列。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #f00;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #0f0;&quot;</span> <span class="attr">span</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="影音多媒体"><a href="#影音多媒体" class="headerlink" title="影音多媒体"></a>影音多媒体</h2><h3 id="与"><a href="#与" class="headerlink" title="&lt;vedio&gt;与&lt;audio&gt;"></a><code>&lt;vedio&gt;</code>与<code>&lt;audio&gt;</code></h3><p><code>&lt;video&gt;</code> 元素表示视频，用于在网页中嵌入视频，<code>audio</code> 用于嵌入音频。</p><ul><li><code>src</code>：视频地址</li><li><code>controls</code>：显示播放控件</li><li><code>autoplay</code>：自动播放</li><li><code>loop</code>：循环播放</li><li><code>muted</code>：静音</li><li><code>poster</code>：封面图片</li><li><code>width</code>：宽度</li><li><code>height</code>：高度</li><li><code>preload</code>：预加载,<code>none</code>、<code>metadata</code>、<code>auto</code>,默认<code>auto</code>,表示页面加载时不加载视频，只有在用户点击播放时才加载,<code>metadata</code>表示加载视频的元数据，<code>none</code>表示不加载视频。</li><li><code>crossorigin</code>： 设置如何处理跨文件存取要求</li></ul><h3 id="嵌入浮动框架"><a href="#嵌入浮动框架" class="headerlink" title="嵌入浮动框架&lt;iframe&gt;"></a>嵌入浮动框架<code>&lt;iframe&gt;</code></h3><p><code>&lt;iframe&gt;</code> 元素用于在网页中嵌入其他网页，可以用于显示地图、广告、视频等内容。</p><ul><li><code>src</code>：嵌入页面的地址</li><li><code>srcdoc</code>：嵌入页面的 HTML 内容, 比如<code>&lt;iframe srcdoc=&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;&gt;&lt;/iframe&gt;</code></li><li><code>width</code>：宽度</li><li><code>height</code>：高度</li><li><code>frameborder</code>：是否显示边框</li><li><code>sandbox</code>：沙箱模式，用于限制嵌入页面的行为</li><li><code>allowfullscreen</code>：是否允许全屏显示</li><li><code>name</code>：用于在页面中定位该框架</li></ul><h2 id="窗体"><a href="#窗体" class="headerlink" title="窗体"></a>窗体</h2><h3 id="和-3"><a href="#和-3" class="headerlink" title="&lt;form&gt;和&lt;input&gt;"></a><code>&lt;form&gt;</code>和<code>&lt;input&gt;</code></h3><p><code>&lt;form&gt;</code> 元素表示表单，用于向服务器提交数据。<code>&lt;form&gt;</code> 元素的 <code>action</code> 属性用于指定表单提交的地址，<code>method</code> 属性用于指定提交方式（<code>get</code> 或 <code>post</code>）。</p><ul><li><code>action</code>：表单提交地址</li><li><code>method</code>：提交方式</li><li><code>target</code>：提交后打开方式</li><li><code>enctype</code>：编码方式</li><li><code>autocomplete</code>：自动完成</li><li><code>accept-charset</code>：接受字符集</li></ul><p><code>&lt;input&gt;</code> 元素表示表单中的输入控件，用于接收用户输入的数据。</p><ul><li><code>type</code>：输入类型</li></ul><table><thead><tr><th>type属性值</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>文本框</td></tr><tr><td>password</td><td>密码框</td></tr><tr><td>radio</td><td>单选框</td></tr><tr><td>checkbox</td><td>复选框</td></tr><tr><td>submit</td><td>提交按钮</td></tr><tr><td>reset</td><td>重置按钮</td></tr><tr><td>button</td><td>普通按钮</td></tr><tr><td>file</td><td>文件上传</td></tr><tr><td>hidden</td><td>隐藏域</td></tr><tr><td>image</td><td>图像按钮</td></tr></tbody></table><hr><p>html5新增的input类型</p><table><thead><tr><th>type属性值</th><th>描述</th></tr></thead><tbody><tr><td>date</td><td>日期</td></tr><tr><td>time</td><td>时间</td></tr><tr><td>month</td><td>月份</td></tr><tr><td>email</td><td>邮箱</td></tr><tr><td>url</td><td>网址</td></tr><tr><td>tel</td><td>电话</td></tr><tr><td>search</td><td>搜索</td></tr><tr><td>color</td><td>颜色</td></tr><tr><td>number</td><td>数字</td></tr><tr><td>range</td><td>范围</td></tr><tr><td>datetime-local</td><td>本地日期时间</td></tr><tr><td>week</td><td>周</td></tr></tbody></table><ul><li><code>accept</code>：接受内容类型</li><li><code>alt</code>：替代文本</li><li><code>autocomplete</code>：自动完成</li><li><code>autofocus</code>：自动获取焦点</li><li><code>checked</code>：默认选中</li><li><code>disabled</code>：禁用</li><li><code>form</code>：关联表单</li><li><code>maxlength</code>：最大长度</li><li><code>minlength</code>：最小长度</li><li><code>min</code>，<code>max</code>，<code>step</code>：最小值，最大值，步长</li><li><code>multiple</code>：多选</li><li><code>name</code>：名称</li><li><code>pattern</code>：正则表达式</li><li><code>placeholder</code>：占位符</li><li><code>readonly</code>：只读</li><li><code>required</code>：必填</li><li><code>size</code>：大小</li><li><code>value</code>：值</li><li><code>src</code>：图片地址</li></ul><h3 id="-16"><a href="#-16" class="headerlink" title="&lt;textarea&gt;"></a><code>&lt;textarea&gt;</code></h3><p><code>&lt;textarea&gt;</code> 元素表示多行文本输入框，用于接收用户输入的多行文本。</p><ul><li><code>cols</code>：列数</li><li><code>rows</code>：行数</li><li><code>name</code>：名称</li><li><code>readonly</code>：只读</li><li><code>required</code>：必填</li><li><code>placeholder</code>：占位符</li><li><code>maxlength</code>：最大长度</li><li><code>wrap</code>：换行方式</li></ul><h3 id="和-4"><a href="#和-4" class="headerlink" title="&lt;select&gt;和&lt;option&gt;"></a><code>&lt;select&gt;</code>和<code>&lt;option&gt;</code></h3><p><code>&lt;select&gt;</code> 元素表示下拉列表，用于提供选项供用户选择。</p><ul><li><code>autofocus</code>：自动获取焦点</li><li><code>disabled</code>：禁用</li><li><code>multiple</code>：多选</li><li><code>name</code>：名称</li><li><code>required</code>：必填</li><li><code>size</code>：可见选项数,下拉菜单的高度</li></ul><p><code>&lt;option&gt;</code> 元素表示下拉列表中的选项，包含在 <code>&lt;select&gt;</code> 元素中。</p><ul><li><code>disabled</code>：禁用</li><li><code>selected</code>：默认选中</li><li><code>value</code>：值</li><li><code>label</code>：标签</li></ul><h3 id="-17"><a href="#-17" class="headerlink" title="&lt;label&gt;"></a><code>&lt;label&gt;</code></h3><p><code>&lt;label&gt;</code> 元素表示表单控件的标签，用于关联表单控件。</p><ul><li><code>for</code>：关联控件的 id</li></ul><h3 id="-18"><a href="#-18" class="headerlink" title="&lt;optgroup&gt;"></a><code>&lt;optgroup&gt;</code></h3><p><code>&lt;optgroup&gt;</code> 元素表示下拉列表中的分组，用于将选项分组显示。与 <code>&lt;option&gt;</code> 元素一起使用。</p><h3 id="和-5"><a href="#和-5" class="headerlink" title="&lt;fieldset&gt;和&lt;legend&gt;"></a><code>&lt;fieldset&gt;</code>和<code>&lt;legend&gt;</code></h3><p><code>&lt;fieldset&gt;</code> 元素表示表单中的一组相关控件，用于将表单控件分组显示，通常包含一个 <code>&lt;legend&gt;</code> 元素作为标题。</p>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue(三) ——路由</title>
      <link href="/2025/03/30/router/"/>
      <url>/2025/03/30/router/</url>
      
        <content type="html"><![CDATA[<p>虽然利用动态组件可以实现组件切换，但是用户刷新网页或者通过URL地址重新访问网页时，组件的切换状态无法保留。为了解决这个问题，可以使用路由实现组件切换。</p><h2 id="后端路由和前端路由"><a href="#后端路由和前端路由" class="headerlink" title="后端路由和前端路由"></a>后端路由和前端路由</h2><h3 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h3><p>比如Node.js环境中的Express框架，服务器收到请求后会通过路由寻找当前请求的URL地址对应的处理程序。</p><h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><p>前端路由的整个过程发生在浏览器端，当URL地址改变时不需要向服务器发起一个加载页面的请求，而是维持当前页面的情况下切换页面中的显示内容。</p><ol><li>Hash模式：<code>http://www.example.com/#/user</code><br> 通过URL中从<code>#</code>开始的部分来切换不同的页面内容。</li><li>HTML5模式：<code>http://www.example.com/user</code><br> 利用HTML5的<code>history.pushState</code>方法来改变URL地址，但是需要服务器端支持。</li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>定义路由组件</p></li><li><p>定义路由链接和路由视图</p><ul><li>router-link：导航链接 <code>&lt;router-link to=&quot;/user&quot;&gt;用户&lt;/router-link&gt;</code></li><li>router-view：路由视图 <code>&lt;router-view&gt;&lt;/router-view&gt;</code></li></ul></li><li><p>创建路由模块<br> <em><strong>如果使用Hash模式则导入<code>createWebHashHistory</code>，如果使用HTML5模式则导入<code>createWebHistory</code></strong></em></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./views/About.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 如果希望<strong>懒加载</strong>的话可以使用<code>import</code>函数，比如：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span> , <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./views/Home.vue&#x27;</span>) &#125;</span><br><span class="line">    &#123; <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span> , <span class="attr">component</span>: <span class="function">()=&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./views/About.vue&#x27;</span>) &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>导入并挂载路由模块</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p><strong>当用户在访问一个URL地址时强制跳转到另一个URL地址，从而展示特定的组件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> , <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p><strong>使用children属性定义子路由匹配规则</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">        <span class="attr">children</span>:[</span><br><span class="line">            &#123; <span class="attr">path</span>: <span class="string">&#x27;path1&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Component1</span>&#125;,</span><br><span class="line">            &#123; <span class="attr">path</span>: <span class="string">&#x27;path2&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Component2</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在组件中定义子路由连接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home/path1&quot;</span>&gt;</span>path1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home/path2&quot;</span>&gt;</span>path2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p><strong>组件的内容会根据URL地址的变化而变化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>在组件中监听动态路由的变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> route.<span class="property">path</span>, <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>获取动态路径参数值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($route.<span class="property">params</span>.<span class="property">id</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用props获取路由参数值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="title class_">String</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在router.js中也要开启props穿参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>:<span class="string">&#x27;:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span>, <span class="attr">props</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p><strong>使用name属性定义路由名称</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/home:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span>, <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">route-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name: &#x27;home&#x27; , params:&#123; id: 1 &#125; &#125;&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">route-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><ul><li><p>push：添加一个新的历史记录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"><span class="comment">// 字符串路径</span></span><br><span class="line">router.<span class="title function_">push</span>(<span class="string">&#x27;/home&#x27;</span>) </span><br><span class="line"><span class="comment">// 带有路径的对象</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 命名路由</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125; &#125;)</span><br><span class="line"><span class="comment">// 带查询参数</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125; &#125;)</span><br><span class="line"><span class="comment">// 带Hash值</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">hash</span>: <span class="string">&#x27;#top&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p>replace：替换当前历史记录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">replace</span>(<span class="string">&#x27;/home&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>go：前进或后退</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">go</span>(<span class="number">1</span>) <span class="comment">// 前进</span></span><br><span class="line">router.<span class="title function_">go</span>(-<span class="number">1</span>) <span class="comment">// 后退</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p><strong>用来控制路由的访问权限</strong></p><ul><li>全局导航守卫<ul><li><code>router.beforeEach((to, from, next) =&gt; &#123;&#125;)</code> 全局前置守卫<ul><li>to是要进入的路由，from是要离开的路由，next是一个函数，如果不接受next，则默认允许用户访问每一个路由，如果接受了next，则必须调用next方法才能继续访问路由</li></ul></li><li><code>router.afterEach((to, from) =&gt; &#123;&#125;)</code> 全局后置守卫</li></ul></li><li>导航独享守卫<ul><li>在路由配置中定义<code>beforeEnter</code>属性</li></ul></li><li>组件导航守卫<ul><li><code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue（二）——组件</title>
      <link href="/2025/03/28/vue2/"/>
      <url>/2025/03/28/vue2/</url>
      
        <content type="html"><![CDATA[<h2 id="选项式API和组合式API"><a href="#选项式API和组合式API" class="headerlink" title="选项式API和组合式API"></a>选项式API和组合式API</h2><p><strong>选项式API式一种通过包含多个选项的对象来描述组件逻辑的API</strong>，如data、methods、computed、watch等。在组件的初始化阶段，Vue会处理这些选项，吧选项中定义的数据、方法、计算属性、侦听器等内容添加到组件实例上，当页面渲染完成后，通过this关键字可以访问组件实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">      data()&#123;</span><br><span class="line">          return&#123; &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    methods:&#123; &#125;,</span><br><span class="line">    computed:&#123; &#125;,</span><br><span class="line">    watch:&#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组合式API式将组件中的数据、方法、计算属性、侦听器等代码全部组合在一起，写在setup()函数中。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; computed, ref, watch &#125; from &#x27;vue&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">      setup()&#123;</span><br><span class="line">          return&#123; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><em><strong>语法糖</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123;computed, ref, watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  ...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Vue提供的选项式API和组合式API是同一底层系统所提供的两套不同的接口，选项式API是在组合式API的基础上实现的。使用组合式API可以讲项目的每个功能的数据和方法放到一起，能够快速定位到功能区域的相关代码，便于阅读和维护。同时，组合式API可以通过函数来实现高效的逻辑复用。</p><h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h2><p><strong>组件的生命周期是指每个组件从创建到被销毁的整个过程</strong>，每个组件都有生命周期，如果想要在某个特定的时机进行特定的处理，可以使用生命周期钩子函数。</p><table><thead><tr><th>Vue2生命周期</th><th>Vue3生命周期</th><th>说明</th></tr></thead><tbody><tr><td>beforeCreate</td><td>-</td><td>实例对象创建前</td></tr><tr><td>created</td><td>-</td><td>实例对象创建后</td></tr><tr><td>beforeMount</td><td>onBedoreMount</td><td>挂载前</td></tr><tr><td>mounted</td><td>onMounted</td><td>挂载后</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td><td>更新前</td></tr><tr><td>updated</td><td>onUpdated</td><td>更新后</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td><td>销毁前</td></tr><tr><td>destroyed</td><td>onUnmounted</td><td>销毁后</td></tr></tbody></table><h2 id="组件的注册和引用"><a href="#组件的注册和引用" class="headerlink" title="组件的注册和引用"></a>组件的注册和引用</h2><p><strong>组件是Vue的基本结构单元</strong>，开发者可以将页面中独立的、可重用的部分封装成组件，对组件的结构、样式和行为进行设置，组件之间的可以相互引用。</p><h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><ol><li><p>全局注册</p><p> 在main.js中注册全局组件，可以在任何组件中使用。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import MyComponent from &#x27;./components/MyComponent.vue&#x27;   // 引入组件</span><br><span class="line">const app = createApp(App)</span><br><span class="line">app.component(&#x27;MyComponent&#x27;, MyComponent) //在挂载前注册组件</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure></li><li><p>局部注册</p><p>只能在当前注册范围内使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import MyComponent from &#x27;./components/MyComponent.vue&#x27;</span><br><span class="line">  export default &#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">             MyComponent : MyComponent  // 可以简写为 &#x27;MyComponent&#x27;，组件名和组件对象名一致</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> <em><strong>如果使用setup语法糖，导入的组件会被自动注册，无须手动注册，导入后可以直接在模板中使用。</strong></em></p></li></ol><h3 id="引用组件"><a href="#引用组件" class="headerlink" title="引用组件"></a>引用组件</h3><p><em><strong>被引用的组件需要写成标签的形式，标签名与组件名对应</strong></em>，命名可以使用短横线分隔命名法，如<code>my-component</code>，也可以使用驼峰命名法，如<code>MyComponent</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;MyComponent&gt;&lt;/MyComponent&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="解决组件之间的样式冲突"><a href="#解决组件之间的样式冲突" class="headerlink" title="解决组件之间的样式冲突"></a>解决组件之间的样式冲突</h2><h3 id="scoped属性"><a href="#scoped属性" class="headerlink" title="scoped属性"></a>scoped属性</h3><p><strong>为<code>&lt;style&gt;</code>标签添加scoped属性后，Vue会自动为当前组件的DOM元素添加一个唯一的自定义属性，比如<code>data-v-xxxxxx</code>，然后在CSS选择器中添加该属性，以确保样式只作用于当前组件的DOM元素。</strong></p><h3 id="深度选择器"><a href="#深度选择器" class="headerlink" title="深度选择器"></a>深度选择器</h3><p>如果添加了scoped属性后还需要让某些样式对子组件生效，则可以通过深度选择器实现。<strong>被编译后的选择器为[data-v-xxxxxx] .child</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">  :deep(.child) &#123;</span><br><span class="line">      color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="父组件向子组件传递数据（props）"><a href="#父组件向子组件传递数据（props）" class="headerlink" title="父组件向子组件传递数据（props）"></a>父组件向子组件传递数据（props）</h2><ol><li><p><strong>在子组件中声明props属性，接收父组件传递的数据</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">          msg: String</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 可以不限制props类型，写成字符串数组形式的props，如<code>props: [&#39;msg&#39;]</code>。</p><p> 如果使用setup语法糖：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  const props = defineProps([&#x27;msg&#x27;])  // 可以写成字符串数组形式或多个对象参数</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>在父组件中传递数据</strong></p><p> 如果数据时固定不变的，则通过<strong>静态绑定props</strong>方法。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent msg=&quot;Hello&quot;&gt;&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><p> 使用<strong>v-bind动态绑定props</strong>，可以将父组件的数据动态传递给子组件。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent :msg=&quot;msg&quot;&gt;&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><p> <em><strong>在Vue中，所有的props都遵循单项数据流原则，props数据因父组件的更新而变化，变化后的数据将向下流向子组件，而且不会逆向传递</strong></em><br> 这样可以防止子组件意外变更props导致数据流向难以理解的问题。每次父组件绑定的props发生变更时，子组件中的props都将会刷新为最新的值。</p></li><li><p><strong>验证props</strong></p><ol><li>基础类型检查</li><li>必填项校验</li><li>属性默认值</li><li>自定义验证函数validator()</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 基础类型检查</span></span><br><span class="line">    <span class="attr">propA</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="comment">// 多种类型</span></span><br><span class="line">    <span class="attr">propB</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>],</span><br><span class="line">    <span class="comment">// 必填项</span></span><br><span class="line">    <span class="attr">propC</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 默认值</span></span><br><span class="line">    <span class="attr">propD</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    <span class="attr">propE</span>: &#123;</span><br><span class="line">        <span class="title function_">validator</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value &gt; <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h2><p><strong>子组件向父组件传递数据，可以通过自定义事件来实现</strong></p><ol><li><p>在子组件中声明自定义事件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const emit = defineEmits([&#x27;change&#x27;])  // 字符串数组</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>在子组件中触发自定义事件</p><p> 第一个参数为自定义时间的名称，第二个参数为需要传递的数据。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;$emit(&#x27;change&#x27;, &#x27;Hello&#x27;)&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure><p> setup函数</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    setup(props, ctx) &#123;</span><br><span class="line">        const handleClick = () =&gt; &#123;</span><br><span class="line">            ctx.emit(&#x27;change&#x27;, &#x27;Hello&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123; handleClick &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> setup语法糖</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script setup&gt;</span><br><span class="line"> cosnt update = () =&gt; &#123;</span><br><span class="line">    emit(&#x27;change&#x27;, &#x27;Hello&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>在父组件中监听自定义事件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent @change=&quot;handleChange&quot;&gt;&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const handleChange = (value) =&gt; &#123;</span><br><span class="line">   console.log(value)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="跨级组件之前的数据传递"><a href="#跨级组件之前的数据传递" class="headerlink" title="跨级组件之前的数据传递"></a>跨级组件之前的数据传递</h2><p>通过<strong>依赖注入</strong>实现跨级组件之间的数据传递，父组件作为依赖提供者，使用provide()函数，子组件如果想注入上层组件或整个应用提供的数据，需要使用inject()函数。</p><ol><li><p>provide()函数</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; provide &#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        provide(&#x27;name&#x27;, &#x27;Tom&#x27;)  // 第一个参数是注入名，第二个参数是注入的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 使用语法糖</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; provide &#125; from &#x27;vue&#x27;</span><br><span class="line">provide(&#x27;name&#x27;, &#x27;Tom&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 全局依赖</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const app = createApp(APP)</span><br><span class="line">app.provide(&#x27;name&#x27;, &#x27;Tom&#x27;)</span><br></pre></td></tr></table></figure></li><li><p>inject()函数</p><p> 通过inject可以注入上层组件或者整个应用提供的数据，第一个参数是注入值，第二个参数是默认值，第三个参数是布尔值，代表是否将默认值视为工厂函数。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; inject &#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        // 注入一个值</span><br><span class="line">        const name = inject(&#x27;name&#x27;, &#x27;Jerry&#x27;)  // 第一个参数是注入名，第二个参数是默认值。</span><br><span class="line">        // 当没有匹配到注入的值时，默认值可以是工厂函数</span><br><span class="line">        const baz = inject(&#x27;baz&#x27;, () =&gt; new Map())</span><br><span class="line">        // 注入时为了表明提供的默认值是函数，需要传入第三个参数</span><br><span class="line">        const fn = inject(&#x27;function&#x27;, () =&gt; &#123; &#125;, false)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>工厂函数</p><ol><li>把对象的创建过程封装在一个函数里；</li><li>显式返回一个对象（可以是字面量对象、也可以是其它构造结构）；</li><li>相比于构造函数或类，使用工厂函数无需 new，避免了构造函数中 this 指向的问题。</li></ol></blockquote><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><h3 id="定义动态组件"><a href="#定义动态组件" class="headerlink" title="定义动态组件"></a>定义动态组件</h3><p><strong>使用<code>&lt;component&gt;</code>标签可以动态切换不同的组件</strong>，通过绑定is属性决定哪个组件被渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure><h3 id="利用KeepAlive组件缓存动态组件"><a href="#利用KeepAlive组件缓存动态组件" class="headerlink" title="利用KeepAlive组件缓存动态组件"></a>利用KeepAlive组件缓存动态组件</h3><p>使用动态组件实现组件之间的按需切换时，隐藏的组件会被销毁，展示出来的组件会被重新创建，这样会导致组件的状态丢失。为了解决这个问题，可以使用<code>&lt;KeepAlive&gt;</code>组件对动态组件进行缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;KeepAlive&gt;</span><br><span class="line">    &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/KeepAlive&gt;</span><br></pre></td></tr></table></figure><h3 id="相关生命周期"><a href="#相关生命周期" class="headerlink" title="相关生命周期"></a>相关生命周期</h3><ul><li>onActivated：被包裹的动态组件被激活时触发</li><li>onDeactivated：被包裹的动态组件被停用时触发</li></ul><h3 id="KeepAlive组件的常用属性"><a href="#KeepAlive组件的常用属性" class="headerlink" title="KeepAlive组件的常用属性"></a>KeepAlive组件的常用属性</h3><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>include</td><td>String、RegExp</td><td>只有名称匹配的组件会被缓存</td></tr><tr><td>exclude</td><td>String、RegExp</td><td>名称匹配的组件不会被缓存</td></tr><tr><td>max</td><td>Number</td><td>缓存组件的最大数量</td></tr></tbody></table><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p><strong>组件封装期间为组件的使用者预留的占位符，允许组件的使用者在组件内展示特定的内容</strong></p><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>定义插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>使用插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;</span><br><span class="line">    &lt;p&gt;插槽内容&lt;/p&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>当Vue中需要定义多个插槽时，可以通过具名插槽来区分不同的插槽。具名插槽是给每一个插槽定义一个name名称，默认插槽的名称是default。</p><p>定义具名插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>使用具名插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;</span><br><span class="line">    &lt;template v-slot:header&gt;</span><br><span class="line">        &lt;p&gt;头部插槽内容&lt;/p&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template #footer&gt;</span><br><span class="line">        &lt;p&gt;底部插槽内容&lt;/p&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽时带有数据的插槽，子组件提供一部分数据给插槽，父组件接受子组件的数据进行页面渲染。</p><p>定义数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure><p>使用数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;</span><br><span class="line">    &lt;template v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;slotProps.data&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p><strong>自定义指令方便开发者通过直接操作DOM元素来实现业务逻辑</strong></p><ul><li>私有自定义指令：组件内不定义，只在当前组件内使用</li><li>全局自定义指令：在main.js中定义，全局使用</li></ul><h3 id="自定义指令的生命周期函数"><a href="#自定义指令的生命周期函数" class="headerlink" title="自定义指令的生命周期函数"></a>自定义指令的生命周期函数</h3><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>created</td><td>在绑定元素的属性前调用</td></tr><tr><td>beforeMount</td><td>绑定元素挂载之前调用</td></tr><tr><td>mounted</td><td>绑定元素的父组件及其自身所有子节点都挂载完成后调用</td></tr><tr><td>beforeUpdate</td><td>绑定元素的父组件更新之前调用</td></tr><tr><td>updated</td><td>绑定元素的父组件更新完成后调用</td></tr><tr><td>beforeUnmount</td><td>绑定元素的父组件卸载之前调用</td></tr><tr><td>unmounted</td><td>绑定元素的父组件卸载完成后调用</td></tr></tbody></table><h3 id="常用的自定义指令声明周期函数的参数"><a href="#常用的自定义指令声明周期函数的参数" class="headerlink" title="常用的自定义指令声明周期函数的参数"></a>常用的自定义指令声明周期函数的参数</h3><ul><li>el：指令所绑定的元素，可以用来直接操作DOM</li><li>binding：一个对象，包含多个属性，用于接收属性的参数值<ul><li>value: 传递给指令的值</li><li>arg：传递给指令的参数</li><li>oldValue：之前的值，仅仅在update相关中可用</li><li>modifiers：一个包含修饰符的对象</li><li>instance：指令所绑定的组件实例</li><li>dir： 指令的定义对象</li></ul></li><li>vnode：代表绑定元素底层的虚拟节点</li><li>prevNode：之前页面渲染中指令所绑定元素的虚拟节点</li></ul><h3 id="私有自定义指令"><a href="#私有自定义指令" class="headerlink" title="私有自定义指令"></a>私有自定义指令</h3><p>声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div v-myDirective&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    directives: &#123;</span><br><span class="line">        myDirective:&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><em><strong>使用语法糖则不需要声明directives</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const myDirective = &#123;</span><br><span class="line">    mounted: (el) =&gt; &#123;</span><br><span class="line">        el.style.color = &#x27;red&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><p>声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">const app = createApp(App)</span><br><span class="line">app.directive(&#x27;myDirective&#x27;, &#123;</span><br><span class="line">    mounted: (el) =&gt; &#123;</span><br><span class="line">        el.style.color = &#x27;red&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><h3 id="为自定义指令绑定参数"><a href="#为自定义指令绑定参数" class="headerlink" title="为自定义指令绑定参数"></a>为自定义指令绑定参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div v-color=&quot;color&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div v-demo=&quot;&#123;color: &#x27;red&#x27;, text: &#x27;hello&#x27;&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const vColor = &#123;</span><br><span class="line">  mounted: (el, binding) =&gt; &#123;</span><br><span class="line">    el.style.color = binding.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const vDemo = &#123;</span><br><span class="line">  mounted: (el, binding) =&gt; &#123;</span><br><span class="line">    el.style.color = binding.value.color</span><br><span class="line">    el.innerText = binding.value.text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><em><strong>对于自定义指令来说，通常仅需要在mounted和updated函数中操作DOM元素，如果这两个函数中的操作逻辑相同，可以将操作逻辑提取出来，封装成一个函数，然后在mounted和updated函数中调用。</strong></em></p><h2 id="引用静态资源"><a href="#引用静态资源" class="headerlink" title="引用静态资源"></a>引用静态资源</h2><ul><li>public目录用于存放不可以编译的静态资源文件，该目录下的文件会被复制到打包目录，该目录下的文件需要使用绝对路径访问。</li><li>src\assets目录用于存放可编译的静态资源文件，例如土坯啊样式文件等，该目录下需要使用相对路径访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue（一）——开发基础</title>
      <link href="/2025/03/26/vue1/"/>
      <url>/2025/03/26/vue1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Vue"><a href="#什么是Vue" class="headerlink" title="什么是Vue"></a>什么是Vue</h2><p><strong>Vue是一款用于构建用户界面的渐进式框架。</strong></p><ul><li>其中，”渐进式”是指在使用Vue核心库时，可以在核心库的基础上根据实际需要逐步增加功能。</li><li>基于MVVM模式的框架。MVVM住要包含：<ul><li>Model：数据模型，负责业务数据处理</li><li>View：视图，用户界面，负责视图处理</li><li>ViewModel：视图模型，连接Model和View，负责监听Model或者View的变化。工作原理：<code>DOM Listeners</code>监听DOM变化自动同步Model，<code>Data Bindings</code>监听数据变化自动更新View。</li></ul></li><li>特性：<ul><li>数据驱动的视图：Vue监听数据变化。当页面数据发生变化时，Vue会自动重新渲染页面结构。</li><li>双向数据绑定：数据变化会影响视图，视图变化也会影响数据。</li><li>指令：Vue提供了一些指令，用于操作DOM。</li><li>插件：Vue Router、Vuex、Pinia等。</li></ul></li><li>Vue3的新特性<ul><li>体积更小：采取按需编译</li><li>性能提升</li><li>更好的TypeScript支持</li><li>暴露更底层API</li><li>更先进组件</li><li>提供组合式API</li></ul></li></ul><h2 id="Vue开发环境"><a href="#Vue开发环境" class="headerlink" title="Vue开发环境"></a>Vue开发环境</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p><strong>Node.js是一个基于V8引擎的JavaScript运行环境，提供了一些功能性的API</strong></p><h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><p><strong>npm是node.js默认的包管理工具</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install bootstrap  </span><br><span class="line">npm uninstall bootstrap</span><br><span class="line">npm update bootstrap</span><br></pre></td></tr></table></figure><p><strong>yarn是Facebook开发的包管理工具</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn add bootstrap</span><br><span class="line">yarn remove bootstrap</span><br><span class="line">yarn up bootstrap</span><br><span class="line">yarn add bootstrap@4.5.0</span><br></pre></td></tr></table></figure><p>-g：全局安装</p><p>npm和yarn的区别：</p><ul><li>使用npm安装同一个包时，每次安装都需要重新下载，而yarn会缓存每个下载过的包，再次使用时无需重复下载</li><li>npm按照队列安装每个包，而yarn会并行安装</li><li>npm输出信息冗长，yarn输出信息更简洁，只输出必要的信息</li></ul><h3 id="Vite与Webpack"><a href="#Vite与Webpack" class="headerlink" title="Vite与Webpack"></a>Vite与Webpack</h3><p><strong>Vite是一个轻量级、运行速度快的前端构建工具，支持模块热替换（HMR）</strong></p><blockquote><p>模块热替换可以及时准确的更新模块，当代码修改时无需重新加载页面或清除应用程序状态。</p></blockquote><p>在Vue3出现前，Vue2一般使用Vue CLI创建。Vue CLI基于Webpack构建并配置项目。在项目启动时，Webpack需要从入口文件索引整个项目的文件，编译成一个或多个单独的.js文件。</p><p>虽然Webpack对代码进行了拆分，但是仍可能一次生成所有路由下的编译后的文件，导致项目启动慢。</p><p><strong>而Vite在项目启动时，会对模块代码进行按需加载，启动速度快</strong></p><ol><li>手动创建项目 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest</span><br><span class="line">yarn create vite</span><br></pre></td></tr></table></figure></li><li>通过模板自动创建项目 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest my-vue-app -- --template vue</span><br><span class="line">yarn create vite my-vue-app --template vue</span><br></pre></td></tr></table></figure></li></ol><h3 id="目录结构与运行过程"><a href="#目录结构与运行过程" class="headerlink" title="目录结构与运行过程"></a>目录结构与运行过程</h3><ul><li>node_modules：存放项目依赖和安装的插件</li><li>public：存放不可编译的静态资源文件，项目构建时会原封不动的复制到dist目录下，<strong>用绝对路径访问</strong></li><li>src：存放项目源码</li><li>src\assets：存放可编译的静态资源文件，如图片、样式文件等，<strong>用相对路径访问</strong></li><li>src\components：存放单文件组件，如.vue文件</li><li>src\App.vue：根组件</li><li>src\main.js：入口文件，<strong>创建Vue应用实例</strong></li><li>src\style.css：全局样式文件</li><li>.gitignore：git忽略文件</li><li>index.html：页面入口文件，默认的主渲染页面文件</li><li>package.json：项目配置文件</li><li>README.md：项目说明文件</li><li>vite.config.js：Vite配置文件</li><li>yarn.lock：yarn包管理文件</li></ul><p><strong>启动服务时，项目会通过src\main.js文件创建Vue应用实例，然后将App.vue组件渲染到index.html文件的指定区域。</strong></p><h2 id="Vue-js开发基础"><a href="#Vue-js开发基础" class="headerlink" title="Vue.js开发基础"></a>Vue.js开发基础</h2><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><p>每个单文件组件都包含三个部分：</p><ul><li>模板：搭建当前组件DOM结构，<code>&lt;template&gt;&lt;/template&gt;</code>标签包裹，容器标签，不会渲染为真正的DOM元素</li><li>样式：设置当前组件的样式，<code>&lt;style&gt;&lt;/style&gt;</code>标签包裹。</li><li>逻辑：通过Js代码处理组件的数据与业务逻辑，<code>&lt;script&gt;&lt;/script&gt;</code>标签包裹。</li></ul><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><ul><li>Mustache语法：<code>&#123;&#123;&#125;&#125;</code>，用于绑定数据到视图</li><li>响应式数据绑定：Vue会监听数据的变化，当数据发生变化时，Vue会自动更新视图<ul><li>ref()：将数据转换为响应式数据</li><li>reactive()：创建响应式对象或数组</li><li>toRef()：将响应式对象中某个属性转换为响应式数据，响应式数据 &#x3D; toRef(响应式对象, ‘属性名’)</li><li>toRefs()：将响应式对象中所有属性转换为响应式数据。 所有属性组成的对象 &#x3D; toRefs(响应式对象)</li></ul></li></ul><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ol><li><p>内容渲染指令v-text、v-html<br> <strong>v-text</strong>：替换元素的textContent，不会解析html标签, <strong>v-html</strong>：替换元素的innerHTML，会解析html标签</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-text=&quot;msg&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div v-html=&quot;msg&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>属性绑定指令v-bind<br> <strong>v-bind</strong>：动态绑定元素属性，简写为<code>:</code>，<strong>v-bind:属性名&#x3D;”表达式”</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-bind:src=&quot;imgUrl&quot; alt=&quot;图片&quot;&gt;</span><br><span class="line">&lt;img :src=&quot;imgUrl&quot; alt=&quot;图片&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>事件绑定指令v-on<br> <strong>v-on</strong>：绑定事件监听器，简写为<code>@</code>，<strong>v-on:事件名&#x3D;”事件处理函数”</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;handleClick&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;handleClick&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li><p>双向数据绑定指令v-model<br> <strong>v-model</strong>：实现表单元素和数据的双向绑定，比如处理表单时，输入框与变量保持同步</p><p> 内部为不同元素绑定不同的属性和事件，如input元素绑定value属性和input事件，checkbox元素绑定checked属性和change事件等。</p><p> 3个修饰符：.number(将输入值转换为数字类型)、.trim(去除输入值两侧空格)、.lazy(将输入值转换为change事件触发)</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;msg&quot; type=&quot;text&quot;&gt;</span><br><span class="line">&lt;input v-model.number=&quot;num&quot; type=&quot;number&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>条件渲染指令v-if、v-else、v-else-if、v-show<br> <strong>v-if</strong>：根据表达式的值，动态添加或删除元素，<strong>v-else</strong>：与v-if连用，表示v-if的反向条件，<strong>v-else-if</strong>：与v-if连用，表示v-if的另一条件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;isShow&quot;&gt;显示&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;隐藏&lt;/div&gt;</span><br></pre></td></tr></table></figure><p> <strong>v-show</strong>：根据表达式的值，动态显示或隐藏元素，<strong>v-show&#x3D;”表达式”</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-show=&quot;isShow&quot;&gt;显示&lt;/div&gt;</span><br></pre></td></tr></table></figure><p> <em><strong>二者的区别是v-if是真正的条件渲染，v-show是通过display属性控制元素的显示与隐藏</strong></em></p></li><li><p>列表渲染指令v-for<br> <strong>v-for</strong>：根据数据生成列表，<strong>v-for&#x3D;”item in items”<strong>，</strong>v-for&#x3D;”(item, index) in items”</strong></p><p> <strong>key</strong>：为每个节点设置唯一标识，提高性能,如果list数组中删除一个元素后，index发生变化，Vue会重新渲染整个列表，而key可以保证每个元素的唯一性，以便它能跟踪每个节点的身份，从而对现有元素进行重用和重新排序。</p><ul><li><p>根据一维数组渲染列表</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure></li><li><p>根据对象数组渲染列表</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure></li><li><p>根据对象渲染列表(第一个参数是值，第二个参数是键)</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;(value,key) in obj&quot; :key=&quot;key&quot;&gt;&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p><strong>事件对象是事件触发时产生的对象，保存了事件触发时的相关信息</strong>，例如事件类型，事件发生的时间戳，事件被触发时对应标签的一些属性值集合等。</p><ol><li>通过事件方法等参数获取事件对象 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;button @click=&quot;handleClick&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const handleClick = (e) =&gt; &#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>通过$event获取事件对象&#96;&#96;&#96; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;button @click=&quot;handleClick($event)&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const handleClick = (e) =&gt; &#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ol><li>.prevent：阻止默认行为</li><li>.stop：阻止事件冒泡</li><li>.capture：事件捕获</li><li>.once：只触发一次</li><li>.self：只有事件在该元素本身触发时才会触发</li><li>.passive：滚动事件的默认行为,滑动滚动条立即发生，无需等待onScroll方法执行完毕。</li><li>.enter、.tab、.delete、.esc、.space、.up、.down：键盘事件修饰符</li><li>.left、.right、.middle: 鼠标事件修饰符</li></ol><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p><strong>计算属性监听数据变化，将计算结果缓存起来，只有计算属性中依赖的数据源变化了，计算属性才会自动重新求值，并重新加入缓存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;fullName&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  const firstName = ref(&#x27;Tom&#x27;)</span><br><span class="line">  const lastName = ref(&#x27;Jerry&#x27;)</span><br><span class="line">  const fullName = computed(() =&gt; &#123;</span><br><span class="line">      return firstName.value + &#x27; &#x27; + lastName.value</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="侦听器watch-数据来源，回调函数，可选参数"><a href="#侦听器watch-数据来源，回调函数，可选参数" class="headerlink" title="侦听器watch(数据来源，回调函数，可选参数)"></a>侦听器watch(数据来源，回调函数，可选参数)</h3><p><strong>侦听器监听数据状态，数据更新后进行相应的操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;fullName&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  let firstName = ref(&#x27;Tom&#x27;)</span><br><span class="line">  let lastName = ref(&#x27;Jerry&#x27;)</span><br><span class="line">  const fullName = ref(&#x27;&#x27;)</span><br><span class="line">  watch([firstName, lastName], ([newFirstName, newLastName]) =&gt; &#123;</span><br><span class="line">      fullName.value = newFirstName + &#x27; &#x27; + newLastName</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>数据来源可以是一个有返回值的函数，一个响应式数据， 一个响应式对象，或者一个由以上类型的值组成的数组。</p><p>回调函数中有两个参数，第一个参数是新值，第二个参数是旧值。</p><p>可选参数是一个对象，有两个常用选项：deep和immediate。deep用于监听对象内部属性的变化，immediate用于在侦听器初次加载时立即执行回调函数。</p><h3 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h3><ol><li><p>绑定class属性</p><ul><li>字符串：<code>&lt;div :class=&quot;className&quot;&gt;&lt;/div&gt;</code></li><li>对象：<code>&lt;div :class=&quot;&#123;className: isActive&#125;&quot;&gt;&lt;/div&gt;</code></li><li>数组：<code>&lt;div :class=&quot;[className1, className2]&quot;&gt;&lt;/div&gt;</code></li></ul><p>可以使用三元表达式来切换，比如<code>&lt;div :class=&quot;&#123;isActive ? &#39;active&#39; : &#39;inactive&#39;&#125;&quot;&gt;&lt;/div&gt;</code></p></li><li><p>绑定style属性</p><ul><li>对象：<code>&lt;div :style=&quot;&#123;color: &#39;red&#39;, fontSize: &#39;16px&#39;&#125;&quot;&gt;&lt;/div&gt;</code></li><li>数组：<code>&lt;div :style=&quot;[style1, style2]&quot;&gt;&lt;/div&gt;</code></li></ul><p>CSS中的属性名使用驼峰命名法，如<code>backgroundColor</code>或者短横线分隔命名法，如<code>background-color</code>，如果是第二种需要将属性写成字符串形式。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于跨域...</title>
      <link href="/2025/03/24/cors/"/>
      <url>/2025/03/24/cors/</url>
      
        <content type="html"><![CDATA[<p>今天整理一些有关于跨域的内容…</p><h2 id="为什么需要跨域？"><a href="#为什么需要跨域？" class="headerlink" title="为什么需要跨域？"></a>为什么需要跨域？</h2><p>浏览器实施同源策略，这是一种基本的安全协议。该策略禁止来自不同域的JavaScript脚本与另一个域的资源进行交互。</p><p>其中，同源是指<strong>两个URL的协议、主机和端口号都一致</strong></p><blockquote><p>为什么浏览器需要这种限制呢？<br>“同源策略”是浏览器的安全机制，其目的是：<br>防止恶意网站读取你登录状态下的敏感信息（如银行、邮件、后台管理等）。<br>举个例子：<br>你在 bank.com 登录了账户，浏览器存有 cookie。如果没有同源限制，恶意网站 evil.com 可以伪造请求读取你的银行账户信息，这就是“跨站请求伪造（CSRF）”的根源之一。</p></blockquote><p>跨域是指<strong>当前网页的源和要请求的目标接口的源不一致</strong></p><p>由于浏览器同源策略的限制，将存在以下的跨域问题：</p><ol><li>无法访问来自不同源网页的Cookie、LocalStorage和IndexedDB，也就是说不同源的网页之间不能共享存储数据</li><li>无法操作不同源网页的DOM，每个网页的DOM只能由其自己的脚本访问，不能被其他源的脚本操作。</li><li>无法向不同源地址发起AJAX请求，这限制了网页与不同源服务器之间的数据交互。</li></ol><p>这些限制在确保Web应用安全性防止恶意网站访问其他网站的敏感数据，但同时也给开发跨域Web应用带来了挑战。</p><p>相应的解决方案有：</p><h2 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h2><p>浏览器对<code>&lt;script&gt;</code>标签没有跨域限制，通过动态创建script标签，请求后端返回可执行的代码。</p><p><em><strong>只支持GET请求</strong></em>,使用于一些旧项目，无法配置CORS的第三方服务。</p><p>前端代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;跨域数据：&#x27;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.<span class="property">src</span> = <span class="string">&#x27;http://example.com/data?callback=handleResponse&#x27;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleResponse(&#123; name: &quot;OpenAI&quot;, type: &quot;AI&quot; &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>也就是在请求的时候不仅要写接口路径，还要加一个回调函数名，并将完整的路径写入script的src中，后端返回数据的时候将函数名与内容拼接，这样就可以直接对返回的内容进行操作了。</p></blockquote><h2 id="2-document-domain"><a href="#2-document-domain" class="headerlink" title="2.document.domain"></a>2.document.domain</h2><p>两个页面可以<strong>设置相同的document.domain</strong>，浏览器是通过这个属性来检查两个页面是否同源，只要设置相同的document.domain，两个页面就可以共享Cookie。</p><p>但是仅限于<strong>主域相同，子域不同</strong>的跨应用场景。比如a.example.com和b.example.com</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.example.com 和 b.example.com</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;example.com&quot;</span>; <span class="comment">// 都设置为主域</span></span><br></pre></td></tr></table></figure><p>此时两个页面就可以互相访问DOM和JS了。逐渐被淘汰了。</p><h2 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h2><p>跨资源共享标准新增了一组HTTP标头字段，允许<strong>服务器声明</strong>哪些源站通过浏览器有权限访问哪些资源。</p><p>对于可能对服务器数据产生副作用的HTTP请求方法，浏览器必须先使用<strong>OPTIONS</strong>方法发起一个预检请求，从而获知服务器<strong>是否允许该跨源请求</strong>。服务器允许后，才发起实际的HTTP请求。</p><p>在预检请求的返回中，服务端也可以通知客户端是否需要携带身份凭证。</p><p>CORS请求失败会产生错误，但是为了安全，在JS代码层面<strong>无法获知到底具体是哪里出现了问题</strong>，只能在浏览器的控制台得知。</p><h3 id="简单请求是指不会触发CORS预检请求的请求，"><a href="#简单请求是指不会触发CORS预检请求的请求，" class="headerlink" title="简单请求是指不会触发CORS预检请求的请求，"></a><strong>简单请求</strong>是指不会触发CORS预检请求的请求，</h3><p>需要满足以下条件：</p><ul><li>GET、HEAD、POST</li><li>除了被用户代理自动设置的标头字段，允许人为设置的字段为Fetch规范定义的对CORS安全的标头字段集合（Accept、Accept-Language、Content-Language、Content-Type、Range）</li><li>Content-Type标头所指定的媒体类型仅限于：text&#x2F;plain、multipart&#x2F;form-data、application&#x2F;x-www-form-urlencoded</li><li>如果是使用<code>XMLHttpRequest</code>对象发出的请求，在返回的XMLHttpRequest.upload 对象属性上没有注册任何事件监听器</li><li>请求中没有使用 ReadableStream 对象。</li></ul><p>假如说站点<code>https://foo.example</code>的网页应用想要访问<code>https://bar.other</code>的资源。这个时候，浏览器发送给服务器的请求报文可能如下所示：</p><figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/resources/public-data/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>bar.other</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>https://foo.example</span><br></pre></td></tr></table></figure><p><strong>其中的Origin表明该请求来源于<code>https://foo.example</code></strong></p><p>而服务器的响应如下所示：</p><figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/xml</span><br><span class="line"></span><br><span class="line"><span class="language-crmsh">[…<span class="keyword">XML</span> <span class="title">Data</span>…]</span></span><br></pre></td></tr></table></figure><p><strong>其中，服务端返回的<code>Access-Control-Allow-Origin: *</code>值表明，该资源可以被任意外源访问。</strong></p><h3 id="预检请求可以避免跨域请求对服务器的用户数据产生未预期的影响"><a href="#预检请求可以避免跨域请求对服务器的用户数据产生未预期的影响" class="headerlink" title="预检请求可以避免跨域请求对服务器的用户数据产生未预期的影响"></a><strong>预检请求</strong>可以避免跨域请求对服务器的用户数据产生未预期的影响</h3><p>与简单请求不同的是，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。</p><p>比如，以下是一个<strong>需要执行预检请求的HTTP请求</strong>,该请求包含了一个非标准的HTTP<code>X-PINGOTHRT</code><br>请求标头，请求的Content-Type为application&#x2F;xml，所以要发起预检请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(<span class="string">&quot;https://bar.other/doc&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/xml&quot;</span>,</span><br><span class="line">        <span class="string">&quot;X-PINGOTHER&quot;</span>: <span class="string">&quot;pingpong&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&quot;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fetchPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>首先是预检请求&#x2F;响应</strong></p><figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/doc</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>bar.other</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>https://foo.example</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>POST</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>X-PINGOTHER, Content-Type</span><br><span class="line"></span><br><span class="line"><span class="language-http"><span class="meta">HTTP/1.1</span> <span class="number">204</span> No Content</span></span><br><span class="line"><span class="language-http"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 01:15:39 GMT</span></span><br><span class="line"><span class="language-http"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2</span></span><br><span class="line"><span class="language-http"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://foo.example</span></span><br><span class="line"><span class="language-http"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>POST, GET, OPTIONS</span></span><br><span class="line"><span class="language-http"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-PINGOTHER, Content-Type</span></span><br><span class="line"><span class="language-http"><span class="attribute">Access-Control-Max-Age</span><span class="punctuation">: </span>86400</span></span><br><span class="line"><span class="language-http"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding, Origin</span></span><br><span class="line"><span class="language-http"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=100</span></span><br><span class="line"><span class="language-http"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span></span><br></pre></td></tr></table></figure><p>其中OPTIONS请求中携带了两个标头字段</p><ul><li><strong>Access-Control-Request-Method: POST</strong>，告知服务器实际请求将用POST方法。</li><li><strong>Access-Control-Request-Headers: X-PINGOTHER, Content-Type</strong>，告知服务器实际请求将携带两个自定义请求标头字段。</li></ul><p>服务器的响应中写明了<strong>允许的源域、允许的请求方法、允许的标头</strong>，最后的Access-Control-Max-Age给定了该预检请求<strong>可供缓存的的事件长短</strong>，默认5秒，在有效时间内，浏览器不需要为同一请求再次发起预检请求。</p><blockquote><p>浏览器自身维护一个最大有效时间，如果超过最大有效时间将不会生效。</p></blockquote><p>预检请求完成之后，将发送实际请求:</p><figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/doc</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>bar.other</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-us,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">X-PINGOTHER</span><span class="punctuation">: </span>pingpong</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/xml; charset=UTF-8</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>https://foo.example/examples/preflightInvocation.html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>55</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>https://foo.example</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"></span><br><span class="line"><span class="language-pgsql">&lt;person&gt;&lt;<span class="type">name</span>&gt;Arun&lt;/<span class="type">name</span>&gt;&lt;/person&gt;</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span></span><br><span class="line"><span class="language-pgsql"><span class="type">Date</span>: Mon, <span class="number">01</span> <span class="type">Dec</span> <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">40</span> GMT</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">Server</span>: Apache/<span class="number">2</span></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">Access</span>-Control-Allow-Origin: https://foo.example</span></span><br><span class="line"><span class="language-pgsql">Vary: Accept-<span class="keyword">Encoding</span>, Origin</span></span><br><span class="line"><span class="language-pgsql">Content-<span class="keyword">Encoding</span>: gzip</span></span><br><span class="line"><span class="language-pgsql">Content-Length: <span class="number">235</span></span></span><br><span class="line"><span class="language-pgsql">Keep-Alive: timeout=<span class="number">2</span>, max=<span class="number">99</span></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">Connection</span>: Keep-Alive</span></span><br><span class="line"><span class="language-pgsql">Content-<span class="keyword">Type</span>: <span class="type">text</span>/plain</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">[<span class="keyword">Some</span> <span class="type">XML</span> payload]</span></span><br></pre></td></tr></table></figure><p><strong>但是如果预检请求发生了重定向，一部分浏览器会报错</strong>，解决办法有：</p><ol><li>在服务端去掉对预检请求的重定向</li><li>将实际请求变成一个简单请求</li><li>发出一个简单请求判断真正的预检请求会返回什么地址，然后发送另一个请求在上一步通过response.url获得的URL</li></ol><p><em><strong>但是如果请求是由于存在Authorization字段而引发了预检请求，则这一方法无法使用</strong></em></p><h3 id="附带身份凭证的请求"><a href="#附带身份凭证的请求" class="headerlink" title="附带身份凭证的请求"></a>附带身份凭证的请求</h3><p>一般而言，对于跨源的XMLHttpRequest或Fetch请求，浏览器<strong>不会发送身份凭证信息</strong><br>，如果要发送，需要设置XMLHttpRequest对象的某个特殊标志位，或在构造Request对象时设置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://bar.other/resources/credentialed-content/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(url, &#123;<span class="attr">credentials</span>: <span class="string">&quot;include&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(request);</span><br><span class="line">fetchPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response));</span><br></pre></td></tr></table></figure><p>上面的代码构造了一个Request对象，并在构造器中<strong>将credentials选项设置为”include”<strong>，但是浏览器会</strong>拒绝任何不带<code>Access-Control-Allow-Credentials: true</code>标头的响应，且不会把响应提供给调用的网页内容</strong></p><p><em><strong>预检请求不能包含凭据，预检请求的响应必须指定<code>Access-Control-Allow-Credentials: true</code>来表明可以携带凭据进行实际的请求。</strong></em></p><p>在响应附带身份凭证的请求时，</p><ol><li>服务器<strong>不能</strong>将Access-Control-Allow-Origin 的值设为通配符“*”。</li><li>服务器<strong>不能</strong>将 Access-Control-Allow-Headers 的值设为通配符“*”。</li><li>服务器<strong>不能</strong>将 Access-Control-Allow-Methods 的值设为通配符“*”。</li></ol><h3 id="整理标头字段"><a href="#整理标头字段" class="headerlink" title="整理标头字段"></a>整理标头字段</h3><p>响应标头字段：</p><ol><li>Access-Control-Allow-Origin</li><li>Access-Control-Expose-Headers：指定标头放入允许列表中</li><li>Access-Control-Max-Age</li><li>Access-Control-Allow-Credentials</li><li>Access-Control-Allow-Methods</li><li>Access-Control-Allow-Headers</li></ol><p>请求标头字段：</p><ol><li>Origin</li><li>Access-Control-Request-Method</li><li>Access-Control-Request-Headers</li></ol><blockquote><p>感觉这部分内容有一些难理解，做一个小小的类比…</p><p>你正在网站 <a href="https://foo.example/">https://foo.example</a> 上写前端代码，你的代码像一个“游客”，想去另一个国家 <a href="https://bar.api.com/">https://bar.api.com</a></p><p>获取一些资源（比如用户数据、图片、JSON 数据等）。这就是一个跨域请求（因为两个域名不一样）。</p><p>浏览器是“边境警察”，负责检查这个请求是否合法。</p><p><strong>🎬 第一幕：简单请求 —— 小事一桩，直接放行</strong></p><p>你的小代码只是用 GET 或 POST 方法访问接口，也没有带什么奇怪的行李（特殊 header 或 JSON 内容），这时候警察觉得：</p><p><em><strong>“嗯，你是个正常游客，看起来不危险。”</strong></em></p><p>于是浏览器直接放你过去，但是提醒你一句：</p><p><em><strong>“你可以去，但是我还得看看对面国家（服务器）愿不愿意接你。”</strong></em></p><p>然后浏览器就在请求里加一个身份说明：</p><figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>https://foo.example</span><br></pre></td></tr></table></figure><p>这就像告诉服务端：</p><p><em><strong>“喂！我这边来了一位游客，是从 <a href="https://foo.example/">https://foo.example</a> 出发的，你愿不愿意接待他？”</strong></em></p><p>如果服务器回答说：</p><figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://foo.example</span><br></pre></td></tr></table></figure><p><em><strong>“欢迎欢迎，我们这儿允许你这位游客入境。”</strong></em></p><p>那么浏览器就放心了，把服务器的响应结果传给网页里的 JS 用了！</p><p>但是如果服务器说：</p><figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure><p><em><strong>“我们谁都欢迎！”（广结善缘）</strong></em></p><p>那么浏览器只会允许普通请求，不允许携带 cookie 的请求通过（因为太泛了，怕泄露隐私）。</p><p><strong>🎬 第二幕：预检请求 —— 带刀剑的游客必须先查一查</strong></p><p>如果你发的请求不再那么“简单”了，比如： </p><ul><li>带了 Authorization、X-Custom-Header 这样的自定义头；</li><li>请求方法是 PUT、DELETE 等；</li><li>请求体是 application&#x2F;json（不是默认的表单格式）；</li></ul><p>浏览器会马上警觉：</p><p><em><strong>“这个游客行李太多、身份复杂，必须先发个探查请求去问一下那边边检站。”</strong></em></p><p>于是浏览器会先发一个 预检请求（preflight request），这是一个 OPTIONS 请求，里面写着：</p><figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/api/data</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>https://foo.example</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>POST</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>Authorization</span><br></pre></td></tr></table></figure><p>这意思就是：</p><p><em><strong>“你好，我打算从 <a href="https://foo.example/">https://foo.example</a> 发一个 POST 请求，带上 Authorization，请问你同意吗？”</strong></em></p><p>如果服务器说</p><figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://foo.example</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>POST</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>Authorization</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br></pre></td></tr></table></figure><p><em><strong>“我们查过啦，这个游客可以过关，请让他进来。”</strong></em></p><p>浏览器才允许正式请求发出去！</p><p>如果服务器没回答清楚，比如：</p><ul><li>没有 Access-Control-Allow-Origin</li><li>没有 Access-Control-Allow-Headers</li><li>Allow-Origin: * 却又想接收 Cookie</li></ul><p>那浏览器就会说：</p><p><em><strong>“不行！你那边手续不全，我不让这个请求出去。”</strong></em></p><p>🎬 第三幕：请求携带身份凭证 —— 需要贴身安检！</p><p>如果你的请求想带 cookie、session 或者 Authorization 这种凭证，浏览器会特别小心。</p><p>你得主动告诉浏览器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://bar.api.com/data&quot;</span>, &#123;</span><br><span class="line"><span class="attr">credentials</span>: <span class="string">&quot;include&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就像告诉警察：</p><p><em><strong>“这个游客带着身份证（cookie），得贴身检查！”</strong></em></p><p>这时浏览器只会接受那些：</p><ul><li>Access-Control-Allow-Origin 指定了你的网站（不能是 *）</li><li>Access-Control-Allow-Credentials: true 明确说：我接收带身份的游客！</li></ul><p>否则浏览器直接说：</p><p><em><strong>“你带身份证来，但对方不欢迎，结果我就把这个回应扔掉，不给 JS 用。”</strong></em></p><p>有时候即使你做对了所有 CORS 的设置，浏览器仍然不让你带 cookie！</p><p>这是因为：很多浏览器默认会禁止跨站设置或发送 cookie，比如 Chrome、Safari 都开始阻止所谓的“第三方 cookie”（防广告追踪）。</p><p>这时你要在服务器设置：</p><figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>token=abc123; SameSite=None; Secure</span><br></pre></td></tr></table></figure><p><em><strong>“这个 cookie 是允许跨站的，而且必须在 HTTPS 下使用！”</strong></em></p><p><strong>🎬 第四幕：重定向风波 —— 半路被拉去另一个国家</strong></p><p>结果服务器 bar.api.com 回复说：</p><p><em><strong>“哎哟，我不在这里办公啦，我们搬家了！请你去 <a href="https://api2.other.com/data%E3%80%82%E2%80%9D">https://api2.other.com/data。”</a></strong></em></p><p>这时候就发生了 重定向（服务器返回 302&#x2F;307）！</p><p>这时候浏览器会说：</p><p><em><strong>“等会儿，我这是发预检请求，你怎么半路换个国家让我去？我可不干！”</strong></em></p></blockquote><h2 id="4-Nginx反向代理"><a href="#4-Nginx反向代理" class="headerlink" title="4.Nginx反向代理"></a>4.Nginx反向代理</h2><p>反向代理是一种服务器，它接收客户端的请求，并将这些请求转发给后端的真实服务器处理，然后将响应返回给客户端。</p><p>也就是说：</p><pre><code>浏览器 → 反向代理（如 Nginx） → 后端服务</code></pre><p>最终浏览器看到的是 Nginx，但 Nginx 在背后转发请求。</p><ol><li>在 Nginx 配置文件中，为需要代理的每个服务设置一个特定的前缀。</li><li>配置Nginx将这些前缀的HTTP&#x2F;HTTPS请求转发到对应的真实服务器。</li><li>通过这种方式，所有通过Nginx转发的URL都将具有相同的域名、协议和端口号，从而满足浏览器的同源策略要求。</li></ol><p>由于所有 URL 都指向同一个服务器，浏览器将它们视为同源，从而避免了跨域访问的限制。实际上，这些 URL 背后是由不同的物理服务器提供服务。这样，服务器内部的JavaScript代码就可以自由地跨域调用这些服务器上的资源。</p><h2 id="5-postMessage（跨窗口-iframe-通信）"><a href="#5-postMessage（跨窗口-iframe-通信）" class="headerlink" title="5.postMessage（跨窗口&#x2F;iframe 通信）"></a>5.postMessage（跨窗口&#x2F;iframe 通信）</h2><p>在使用iframe或弹出窗口时，需要跨文档的消息传递。postMessage方法提供一种安全方式实现跨源通信，允许父窗口和子窗口之间进行消息交换。</p><p>发送方（iframe或子窗口）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">opener</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;你好，主窗口！&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接收方（主窗口）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://iframe.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到消息：&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-WebSocket"><a href="#6-WebSocket" class="headerlink" title="6.WebSocket"></a>6.WebSocket</h2><p>WebSocket是HTML5的一个持久化协议，实现了浏览器与服务器的全双工通信。初次握手虽然为HTTP，但是连接建立好了之后客户端与服务器的通信就基于WS协议，与HTTP无关了。</p><p><em><strong>服务端需监听 WebSocket 协议连接。</strong></em>，应用场景一般为实时数据，比如在线聊天室、股票推送等。</p><h2 id="7-window-name-location-hash"><a href="#7-window-name-location-hash" class="headerlink" title="7.window.name &#x2F; location.hash"></a>7.window.name &#x2F; location.hash</h2><p>某些浏览器特性允许在跨页面之间通过window.name或location.hash传递数据。</p><ul><li>页面 A 打开 B.html，B.html 设置 window.name &#x3D; ‘数据’，再跳转回 A</li><li>设置 B 的 location.hash &#x3D; ‘#data’，B 从 location.hash 中读取</li></ul><p><em><strong>仅限页面跳转数据传递，不适合 AJAX 场景。</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域，HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JS的更多...</title>
      <link href="/2025/03/23/question/"/>
      <url>/2025/03/23/question/</url>
      
        <content type="html"><![CDATA[<h2 id="JS模块化"><a href="#JS模块化" class="headerlink" title="JS模块化"></a>JS模块化</h2><p>JavaScript 模块化体系在长期的实践中逐步演化，主要包括 AMD、CMD、CommonJS、RequireJS、Sea.js 等模块规范或工具，它们从不同场景出发，解决了早期 JavaScript 缺乏模块机制的问题。</p><p><strong>CommonJS</strong> 是 Node.js 采用的模块化规范，<strong>每个文件就是一个模块</strong>，通过 <code>require()</code> 引入其他模块，使用 <code>module.exports</code> 导出模块内容。它的特点是<strong>同步加载模块</strong>，适用于服务器端环境，因为模块文件都存在本地磁盘，加载速度快。其底层本质是将模块包裹在一个函数作用域中运行，通过缓存机制避免重复加载。</p><p><strong>AMD（Asynchronous Module Definition）</strong> 是为了解决浏览器端模块加载的异步需求而提出的规范。代表实现是 <strong>RequireJS</strong>。AMD 使用 <code>define(id?, deps?, factory)</code> 定义模块，支持<strong>提前声明依赖、异步并发加载模块</strong>。这种设计非常适合浏览器环境下的资源按需加载，<strong>依赖在模块加载前就被解析出来</strong>，利于并发加载优化。但写法相对复杂，阅读性较弱。</p><p><strong>CMD（Common Module Definition）</strong> 则是 <strong>Sea.js</strong> 所采用的模块化规范。与 AMD 不同，CMD 强调<strong>依赖就近使用</strong>，采用 <code>define(function(require, exports, module)&#123; ... &#125;)</code> 的写法，模块中的 <code>require</code> 可以在需要的地方调用，<strong>依赖是在运行时动态解析的</strong>。CMD 更贴近 CommonJS 的风格，适合以按需加载为导向的前端项目。但它的运行时依赖分析机制，可能会影响并发加载效率。</p><p><strong>RequireJS</strong> 是对 AMD 规范的一个实现，它为浏览器环境提供了模块定义与异步加载能力，支持模块依赖管理、打包优化和懒加载等。开发者需通过 <code>require.config()</code> 配置模块路径、别名等信息。</p><p><strong>Sea.js</strong> 是国人提出的前端模块加载器，实现了 CMD 规范，主张“依赖就近”，适用于脚本按需加载的情境。Sea.js 强调轻量、灵活、简单，适合中小型前端项目，其模块通过 <code>define</code> 定义并用 <code>seajs.use()</code> 使用，配合 <code>alias</code> 与 <code>paths</code> 机制来管理模块路径。</p><p>总结来说，<strong>CommonJS 面向服务器，采用同步加载；AMD 适合浏览器，采用异步并发加载且依赖前置；CMD 同样面向浏览器，但依赖就近、按需执行；RequireJS 是 AMD 的实现；Sea.js 是 CMD 的实现。</strong> 这几种规范各自出现在不同的时间与技术背景下，最终都为 ES6 的模块系统（ESM）铺平了道路。</p><hr><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><h2 id="异步与作用域"><a href="#异步与作用域" class="headerlink" title="异步与作用域"></a>异步与作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个for循环使用let声明变量i,由于let具有块级作用域,每次循环都会创建一个新的作用域,每个setTimeout里的i都是当时循环的值。因此会打印0和1。</p><p>第二个for循环使用var声明变量i,var没有块级作用域,它是函数作用域。当循环结束时i的值为2,而setTimeout是异步执行的,等到真正执行时,两个回调函数中的i都指向同一个变量,此时i的值已经是2了。因此会打印两个2。</p><p>所以最终的打印顺序是:0 1 2 2</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Ajax...</title>
      <link href="/2025/03/23/ajax/"/>
      <url>/2025/03/23/ajax/</url>
      
        <content type="html"><![CDATA[<p>尝试把以前一些很晕的概念连起来…</p><h2 id="什么是AJAX？"><a href="#什么是AJAX？" class="headerlink" title="什么是AJAX？"></a>什么是AJAX？</h2><ul><li>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</li><li>AJAX是一种在Web应用中通过异步发送HTTP请求向服务器获取内容，并使用这些新内容更新页面中相关部分，而无需中心加载整个页面的Web开发技术，这可以让页面更具响应性，因为只请求了需要更新的部分。</li><li>起初，AJAX通过使用<em><strong>XMLHttpRequest</strong></em>接口实现，但是现在，<em><strong>fetch()</strong></em> API更适合用于开发现代Web应用。</li></ul><h2 id="XMLHttpRequest-AJAX的最初实现"><a href="#XMLHttpRequest-AJAX的最初实现" class="headerlink" title="XMLHttpRequest:AJAX的最初实现"></a>XMLHttpRequest:AJAX的最初实现</h2><ul><li>虽然叫XMLHttpRequest，但是它可以用于请求任何类型的数据，而不仅仅是XML。</li><li>甚至支持HTTP以外的协议，比如file和ftp。但是可能受到更多出于安全等原因的限制。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建实例化对象</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 2. 初始化请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/user&quot;</span>);</span><br><span class="line"><span class="comment">// 3， 当readyState属性改变时触发</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 4. states代表请求的响应状态</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 5. 解析响应数据</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 发送请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><ul><li>还有一些其他的属性和方法：<ul><li><code>responseText</code>：返回请求的响应文本</li><li><code>responseXML</code>：返回请求的响应XML文档</li><li><code>responseURL</code>：返回请求的响应URL</li><li><code>timeout</code>：设置请求的超时时间</li><li><code>upload</code>：返回一个XMLHttpRequestUpload对象，用于表示上传的进度</li><li><code>withCredentials</code>：设置是否携带跨域凭证</li><li><code>abort()</code>：取消请求</li></ul></li></ul><h2 id="Promise-更优雅的异步处理"><a href="#Promise-更优雅的异步处理" class="headerlink" title="Promise:更优雅的异步处理"></a>Promise:更优雅的异步处理</h2><ul><li>在进入fetch()这个现代化实现AJAX之前，我们先来看看Promise。</li><li>Promise是一种更优雅的异步处理方式，它是一个对象，代表一个异步操作的最终完成或失败以及其结果值。</li><li>fetch正是基于Promise实现的。</li></ul><p>如果没有Promise，我们需要在一开始把回调函数作为参数传入函数中，一个回调函数在成功时被调用，另一个则在异常时被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">successCallback</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功：&quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">failureCallback</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败：&quot;</span> + error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(settings, successCallback, failureCallback);</span><br></pre></td></tr></table></figure><p>但是如果我们重写doSomething()函数，使其返回一个Promise对象，我们就可以使用then()方法来处理成功和失败的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>(settings).<span class="title function_">then</span>(successCallback, failureCallback);</span><br></pre></td></tr></table></figure><p>那么这种写法有什么好处呢？</p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>如果我们需要连续执行两个或者多个异步操作，在上一个操作执行成功之后，开始下一个操作，并带着上一步操作返回的结果，在旧的回调风格中会导致经典的回调地狱。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>(settings, <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="title function_">doSomethingElse</span>(result, <span class="keyword">function</span> (<span class="params">newResult</span>) &#123;</span><br><span class="line">        <span class="title function_">doThirdThing</span>(newResult, <span class="keyword">function</span> (<span class="params">finalResult</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">        &#125;, failureCallback);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure><p>而在Promise中，我们可以使用then()方法来解决这个问题。因为回调函数是附加到Promise对象上，而不是传入一个函数中的。then()方法返回一个<br><em><strong>新的Promise对象</strong></em>。</p><blockquote><p>then的回调函数传入的参数是上一个Promise对象的resolve()方法传入的参数。<br>如果上一个then的回调函数返回的只是一个普通的值，那么下一个then的回调函数的参数就是这个值。<br>而then函数返回的是一个新的Promise对象，所以可以继续调用then方法。但是兑现值往往是undefined。<br>如果上一个处理器启动了一个Promise但是没有返回，那么就没办法再追踪它的敲定状态了，这个Promise就是漂浮的。<br>一个经验法则是操作每次遇到一个Promise就返回它，并把它的处理推迟到下一个then服务器中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>(settings)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="title function_">doSomethingElse</span>(result))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">newResult</span> =&gt;</span> <span class="title function_">doThirdThing</span>(newResult))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">finalResult</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(failureCallback);</span><br></pre></td></tr></table></figure><p>那么doSomething()函数是如何返回一个Promise对象的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">settings</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 异步操作</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>async&#x2F;await</strong>是Promise的语法糖，可以让我们更优雅地处理异步操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">doSomething</span>(settings);</span><br><span class="line">        <span class="keyword">const</span> newResult = <span class="keyword">await</span> <span class="title function_">doSomethingElse</span>(result);</span><br><span class="line">        <span class="keyword">const</span> finalResult = <span class="keyword">await</span> <span class="title function_">doThirdThing</span>(newResult);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">failureCallback</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-组合"><a href="#2-组合" class="headerlink" title="2. 组合"></a>2. 组合</h3><p><em><strong>Promise.all</strong></em><br>我们可以同时启动所有操作，再等待它们全部完成。</p><p>如果数组中的某个Promise被拒绝，Promise.all返回的Promise会立即被拒绝，并终止其他操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">doSomething</span>(), <span class="title function_">doSomethingElse</span>(), <span class="title function_">doThirdThing</span>()])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">[result1, result2, result3]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + result3);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(failureCallback);</span><br></pre></td></tr></table></figure><h2 id="fetch-现代化的AJAX实现"><a href="#fetch-现代化的AJAX实现" class="headerlink" title="fetch():现代化的AJAX实现"></a>fetch():现代化的AJAX实现</h2><ul><li>fetch 是对 XHR 的替代，是浏览器原生支持的基于 Promise 的 HTTP 客户端。</li><li>Window接口的fetch()方法用于发起获取资源的请求，他会返回一个会在请求响应后兑现的promise。</li><li>该promise会兑现一个表示请求响应的Response对象。</li><li>当请求失败时，fetch()的promise才会被拒绝。fetch()的promise不会因为服务器响应表示错误的HTTP码(404、500等)<br>而被拒绝，因此then()处理器必须检查Response.ok或Response.status属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/user&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>如果换成我们刚刚提到的async&#x2F;await，那么代码会更加简洁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/user&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Axios-更强大的AJAX库"><a href="#Axios-更强大的AJAX库" class="headerlink" title="Axios:更强大的AJAX库"></a>Axios:更强大的AJAX库</h2><ul><li>Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</li><li>特点：<ul><li>支持Promise API</li><li>请求和响应拦截器</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止CSRF（跨站请求伪造）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/api/user&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>具体的方法还有很多，比如post、put、delete，参照官方文档链接：<a href="https://www.axios-http.cn/docs/api_intro">Axios</a></p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul><li>axios的一大特点就是拦截器。</li><li>请求拦截器：在请求被发送之前拦截它们，可以用来修改请求的配置信息。</li><li>响应拦截器：在响应被 then 或 catch 处理前拦截它们，可以用来修改响应的数据。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">eject</span>(myInterceptor);</span><br></pre></td></tr></table></figure><p>1.❓什么是 AJAX？它的作用是什么？</p><p><strong>答：</strong></p><p>AJAX 是 Asynchronous JavaScript and XML 的缩写，指的是在网页无需重新加载的情况下，<strong>通过 JavaScript 异步发送 HTTP 请求并获取数据，从而局部更新页面内容</strong>的一种技术方案。它提升了用户体验，使页面响应更快、交互更自然。</p><p>2.XMLHttpRequest 是什么？是不是只能请求 XML？</p><p><strong>答：</strong></p><p>XMLHttpRequest（XHR）是浏览器早期用于实现 AJAX 的核心 API，尽管名字中包含 XML，但它<strong>可以请求任何类型的数据</strong>，比如 JSON、HTML、纯文本、图片等。XHR 支持 GET、POST 等 HTTP 请求，具备请求状态管理、取消、设置超时、跨域凭证等功能。</p><p>3.Promise 的核心概念是什么？有哪几种状态？</p><p><strong>答：</strong></p><p>Promise 是 ES6 提供的一种用于管理异步操作的机制。它代表一个将来可能完成或失败的操作及其结果。</p><p>Promise 有三种状态：</p><ul><li><code>pending</code>：初始状态，未完成</li><li><code>fulfilled</code>：操作成功完成</li><li><code>rejected</code>：操作失败</li></ul><p>Promise 提供 <code>.then()</code> 和 <code>.catch()</code> 方法来注册成功或失败的回调。</p><p>4.Promise 和回调函数的区别？为什么推荐 Promise？</p><p><strong>答：</strong></p><p>传统异步用回调函数处理，但多层嵌套容易出现“回调地狱”；Promise 通过链式调用 <code>.then()</code>，让异步流程更清晰、更可控，且支持统一错误处理。Promise 是更现代的异步抽象，结合 <code>async/await</code> 更像同步代码。</p><p>5.什么是 <code>then()</code> 的返回值？链式调用是如何实现的？</p><p><strong>答：</strong></p><p>每个 <code>.then()</code> 方法会返回一个新的 Promise，<strong>这个新的 Promise 的状态由 <code>.then()</code> 回调函数的返回值决定</strong>。如果返回的是普通值，该值会传给下一个 <code>.then()</code>；如果返回的是 Promise，则会等待它完成后再传递其结果。</p><p>6.什么是 async&#x2F;await？和 Promise 有什么关系？</p><p><strong>答：</strong></p><p><code>async/await</code> 是基于 Promise 的语法糖：</p><ul><li><code>async</code> 用于定义一个异步函数，它返回一个 Promise。</li><li><code>await</code> 用于等待一个 Promise 完成，<strong>它会暂停当前函数，直到 Promise 完成，并返回结果</strong>。</li></ul><p>它让异步流程写法更接近同步代码，可读性更强。</p><p>7.<code>await Promise.all()</code> 是什么？应用场景是什么？</p><p><strong>答：</strong></p><p><code>Promise.all([p1, p2, ...])</code> 会并发执行所有 Promise，<strong>只有当全部 Promise 成功时，结果才会返回为一个数组</strong>，按顺序对应每个任务结果。若有一个失败，则整个 <code>Promise.all</code> 立即 reject，常用于多个接口并发加载。</p><p>8.fetch 和 XMLHttpRequest 有什么区别？</p><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>fetch</th><th>XMLHttpRequest</th></tr></thead><tbody><tr><td>是否原生 Promise</td><td>✅ 是</td><td>❌ 否，需要手动封装</td></tr><tr><td>是否支持拦截器</td><td>❌ 不支持</td><td>❌ 不支持</td></tr><tr><td>错误处理</td><td>仅网络错误会 reject</td><td>HTTP 错误需手动处理</td></tr><tr><td>语法简洁</td><td>✅ 使用更现代语法</td><td>❌ 写法复杂</td></tr></tbody></table><blockquote><p>fetch 是浏览器对 XHR 的现代替代方案，语法基于 Promise，更清晰，但不自动处理 HTTP 错误。</p></blockquote><p>9.axios 是什么？它和 fetch 的区别是什么？</p><p><strong>答：</strong></p><p>axios 是一个第三方 HTTP 客户端库，<strong>在浏览器中基于 XHR，在 Node.js 中基于 http 模块</strong>。它封装了很多高级功能，比如：</p><ul><li>自动 JSON 转换</li><li>请求和响应拦截器</li><li>请求超时控制</li><li>支持取消请求</li><li>统一错误处理</li></ul><p>相比之下，fetch 是浏览器内置 API，更轻量，但功能基础。</p><p>10.axios 如何设置请求&#x2F;响应拦截器？常用场景有哪些？</p><p><strong>答：</strong></p><p>拦截器是 axios 提供的中间层机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="string">&#x27;Bearer token&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>常见应用：</strong></p><ul><li>请求前统一添加 token</li><li>响应后统一剥离结构（只返回 data）</li><li>错误状态统一弹窗或跳转</li></ul><p>11.axios 为什么被称为“HTTP 客户端”？</p><p><strong>答：</strong></p><p>因为它的职责是“<strong>发起 HTTP 请求并处理响应</strong>”，这正是客户端行为（请求方）的定义。HTTP 客户端包括：浏览器、Postman、curl、axios。它们不监听端口、不处理传入请求，只是发出请求。</p><p>12.axios 和 fetch 都是 XMLHttpRequest 的封装吗？</p><p><strong>答：</strong></p><ul><li>fetch：不是封装，而是原生替代（浏览器新内核实现）</li><li>axios：在浏览器中基于 XMLHttpRequest 实现，在 Node 中则用 <code>http</code> 模块</li></ul><p>可以认为 axios 是对 XHR 的更高级封装，提供统一接口。</p><p>13.fetch 为什么要调用两次 <code>.then()</code> 才能拿到数据？</p><p><strong>答：</strong></p><p>fetch 第一次 <code>.then()</code> 返回的是 <code>Response</code> 对象，必须调用 <code>response.json()</code> 或 <code>.text()</code> 等方法才能读取真正的数据。因为 <code>response.body</code> 是可读流，要异步解析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/user&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())  <span class="comment">// 第一次解包</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data));  <span class="comment">// 真正的数据</span></span><br></pre></td></tr></table></figure><p>14.axios 默认会处理哪些事情？fetch 要手动做什么？</p><table><thead><tr><th>功能</th><th>axios ✅（自动）</th><th>fetch ❌（手动）</th></tr></thead><tbody><tr><td>JSON 自动解析</td><td>✅ <code>res.data</code></td><td>❌ 要 <code>.json()</code></td></tr><tr><td>HTTP 错误抛异常</td><td>✅ 自动进入 catch</td><td>❌ 需手动 <code>res.ok</code> 判断</td></tr><tr><td>设置请求头</td><td>✅ 自动设 Content-Type</td><td>❌ 需手动设置</td></tr><tr><td>请求超时</td><td>✅ 支持 timeout</td><td>❌ 需自封装</td></tr><tr><td>请求取消</td><td>✅ 支持 CancelToken</td><td>✅ 支持 AbortController（较新）</td></tr></tbody></table><p>15.写一个 async 函数调用 axios 请求，并加上错误处理？</p><p><strong>答：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/api/user&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求失败&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>16.解释下这段代码的流程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/user&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data));</span><br></pre></td></tr></table></figure><p><strong>答：</strong></p><ul><li>fetch 发出 HTTP 请求，返回一个 <code>Promise&lt;Response&gt;</code></li><li>第一个 <code>.then()</code> 处理响应，将 response.body 解析为 JSON，返回 <code>Promise&lt;object&gt;</code></li><li>第二个 <code>.then()</code> 拿到 JSON 数据，打印结果</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Ajax </tag>
            
            <tag> XMLHttpRequest，fetch，Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful架构风格</title>
      <link href="/2025/03/22/restful/"/>
      <url>/2025/03/22/restful/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RESTful？"><a href="#什么是RESTful？" class="headerlink" title="什么是RESTful？"></a>什么是RESTful？</h1><ul><li>RESTful是一种接口设计风格，它的核心思想是“资源导向”，我们可以把服务器上的数据看作一个个资源，每个资源用一个 URL 来表示，然后通过标准的 HTTP 方法去操作它，比如用 GET 获取资源、POST 新增资源、PUT 或 PATCH 更新资源、DELETE 删除资源。它强调接口要简洁、统一，并且无状态，也就是说每个请求都应该包含完成这个请求所需要的所有信息，服务器不会去记住之前发生了什么。在实际项目中，RESTful 这种风格很常见，比如我们做一个用户管理的接口，像 GET &#x2F;users 是获取用户列表，POST &#x2F;users 是新增用户，GET &#x2F;users&#x2F;1 是查某个用户，整体逻辑清晰，前后端对接也方便。</li></ul><h1 id="一个用户管理系统"><a href="#一个用户管理系统" class="headerlink" title="一个用户管理系统"></a>一个用户管理系统</h1><hr><h2 id="场景设定：开发一个用户管理系统"><a href="#场景设定：开发一个用户管理系统" class="headerlink" title="场景设定：开发一个用户管理系统"></a>场景设定：开发一个用户管理系统</h2><p>假设正在开发一个“用户管理系统”（User Management System），功能包括：</p><ul><li>创建新用户  </li><li>查询用户信息  </li><li>更新用户资料  </li><li>删除用户  </li><li>管理用户与订单的关系</li></ul><p>接下来设计一组接口，供前端页面（或移动端 App）调用。</p><hr><h2 id="第一原则：资源是主角，URI-是地址"><a href="#第一原则：资源是主角，URI-是地址" class="headerlink" title="第一原则：资源是主角，URI 是地址"></a>第一原则：资源是主角，URI 是地址</h2><p>在 RESTful 架构中，系统中“可以被操作的对象”就是资源。</p><blockquote><p>资源的命名用<strong>名词</strong>而不是动词，并且通常使用复数。</p></blockquote><p>在用户系统中，以下是典型的资源与 URI 映射：</p><table><thead><tr><th>资源类型</th><th>URI 示例</th><th>说明</th></tr></thead><tbody><tr><td>用户集合</td><td><code>/users</code></td><td>表示所有用户</td></tr><tr><td>单个用户</td><td><code>/users/123</code></td><td>表示 ID 为 123 的用户</td></tr><tr><td>用户订单</td><td><code>/users/123/orders</code></td><td>表示该用户的订单列表</td></tr><tr><td>单个订单</td><td><code>/orders/456</code></td><td>表示 ID 为 456 的订单</td></tr></tbody></table><p>URI <strong>不包含动词</strong>，动词行为由 HTTP 方法表达，体现了 REST 的“表述性状态转移”。</p><hr><h2 id="第二原则：HTTP方法表达行为"><a href="#第二原则：HTTP方法表达行为" class="headerlink" title="第二原则：HTTP方法表达行为"></a>第二原则：HTTP方法表达行为</h2><p>RESTful 利用标准的 HTTP 动词表达行为，不再用路径拼动作名。</p><p>我们用一个完整的用户生命周期来说明这些方法的使用：</p><h3 id="1-创建用户（POST）"><a href="#1-创建用户（POST）" class="headerlink" title="1. 创建用户（POST）"></a>1. 创建用户（POST）</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /users</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Alice&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;alice@example.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>含义：向 <code>/users</code> 资源集合中添加一个新用户。</p><p>返回：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">201 Created</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>/users/101</span><br></pre></td></tr></table></figure><h3 id="2-获取用户（GET）"><a href="#2-获取用户（GET）" class="headerlink" title="2. 获取用户（GET）"></a>2. 获取用户（GET）</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /users/101</span><br></pre></td></tr></table></figure><p>获取 ID 为 101 的用户详情。</p><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">101</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-更新用户信息（PUT）"><a href="#3-更新用户信息（PUT）" class="headerlink" title="3. 更新用户信息（PUT）"></a>3. 更新用户信息（PUT）</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /users/101</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Alice Zhang&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;alice.z@example.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示将原有用户<strong>整体替换</strong>为新数据（字段缺失会被清空）。</p><h3 id="4-局部更新用户（PATCH）"><a href="#4-局部更新用户（PATCH）" class="headerlink" title="4. 局部更新用户（PATCH）"></a>4. 局部更新用户（PATCH）</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PATCH /users/101</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;email&quot;: &quot;alice.new@example.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🚨 实际项目中，PUT 和 PATCH 经常混用，但原则上 PATCH 更适合字段修改操作。</p></blockquote><p>表示只修改部分字段，其他保持不变。</p><h3 id="5-删除用户（DELETE）"><a href="#5-删除用户（DELETE）" class="headerlink" title="5. 删除用户（DELETE）"></a>5. 删除用户（DELETE）</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /users/101</span><br></pre></td></tr></table></figure><p>服务器会删除用户记录，返回 <code>204 No Content</code> 表示删除成功但无内容返回。</p><hr><h2 id="幂等性与安全性解析（很关键）"><a href="#幂等性与安全性解析（很关键）" class="headerlink" title="幂等性与安全性解析（很关键）"></a>幂等性与安全性解析（很关键）</h2><h3 id="幂等性（Idempotent）"><a href="#幂等性（Idempotent）" class="headerlink" title="幂等性（Idempotent）"></a>幂等性（Idempotent）</h3><p>多次请求的结果与一次请求相同。例如：</p><ul><li><code>GET /users/101</code> —— 获取几次都一样   </li><li><code>PUT /users/101</code> —— 相同数据更新多次没影响 </li><li><code>POST /users</code> —— 每次创建一个新用户 不幂等</li></ul><h3 id="安全性（Safe）"><a href="#安全性（Safe）" class="headerlink" title="安全性（Safe）"></a>安全性（Safe）</h3><p>不会对服务器状态造成影响。例如：</p><ul><li><code>GET</code> 是安全的  </li><li><code>DELETE</code>、<code>PUT</code> 不是安全的（会改变数据）</li></ul><p>RESTful 架构强调幂等和安全，不仅是哲学，也是工程保障（防止重试造成混乱）。</p><hr><h2 id="资源之间的关系设计"><a href="#资源之间的关系设计" class="headerlink" title="资源之间的关系设计"></a>资源之间的关系设计</h2><p>在我们的例子中，用户与订单存在关系：</p><ul><li>URI 设计建议：用嵌套 URI 表达从属关系</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /users/101/orders</span><br></pre></td></tr></table></figure><p>表示获取 ID 为 101 的用户的所有订单。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /users/101/orders/555</span><br></pre></td></tr></table></figure><p>表示该用户的具体某个订单。</p><p>优点是层级清晰、语义明确。</p><hr><h2 id="URI-设计原则总结"><a href="#URI-设计原则总结" class="headerlink" title="URI 设计原则总结"></a>URI 设计原则总结</h2><table><thead><tr><th>原则</th><th>示例</th></tr></thead><tbody><tr><td>使用名词、复数形式</td><td><code>/users</code>, <code>/orders</code></td></tr><tr><td>使用嵌套表达从属关系</td><td><code>/users/101/orders</code></td></tr><tr><td>不使用动词</td><td>❌ <code>/getUser</code>, ✅ <code>/users/101</code></td></tr><tr><td>用查询参数做过滤</td><td><code>/users?name=Alice</code></td></tr></tbody></table><hr><h2 id="状态码设计：让前端明白你在干嘛"><a href="#状态码设计：让前端明白你在干嘛" class="headerlink" title="状态码设计：让前端明白你在干嘛"></a>状态码设计：让前端明白你在干嘛</h2><p>常用 HTTP 状态码应与接口行为语义一致：</p><table><thead><tr><th>状态码</th><th>场景</th></tr></thead><tbody><tr><td>200 OK</td><td>正常响应</td></tr><tr><td>201 Created</td><td>创建成功（如 POST 创建用户）</td></tr><tr><td>204 No Content</td><td>删除成功或 PUT 无返回体</td></tr><tr><td>400 Bad Request</td><td>请求参数错误</td></tr><tr><td>401 Unauthorized</td><td>未登录或 token 失效</td></tr><tr><td>403 Forbidden</td><td>登录了但没有权限</td></tr><tr><td>404 Not Found</td><td>请求资源不存在</td></tr><tr><td>500 Internal Server Error</td><td>服务器异常</td></tr></tbody></table><hr><p>RESTful 的魅力：<strong>结构化、表达清晰、贴合协议、无需文档就能猜出接口行为</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度拷贝、异常、this、防抖与节流</title>
      <link href="/2025/03/21/js/"/>
      <url>/2025/03/21/js/</url>
      
        <content type="html"><![CDATA[<h2 id="深度拷贝"><a href="#深度拷贝" class="headerlink" title="深度拷贝"></a>深度拷贝</h2><ul><li><p>开发时复制一个对象会出现一些问题： 对象的属性值是对象，复制的时候只是复制了引用，修改复制的对象的属性值会影响原对象的属性值。</p></li><li><p>浅拷贝和深拷贝只针对引用数据类型。</p></li></ul><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝只是复制了对象的引用，修改复制的对象的属性值会影响原对象的属性值。</p><ul><li>拷贝对象：<code>Object.assign(&#123;&#125;, obj)</code> 或者 <code>...obj</code></li><li>拷贝数组：<code>Array.prototype.concat()</code> 或者 <code>[...arr]</code></li></ul><p>但是浅拷贝会存在一些问题，比如拷贝对象的属性值是对象，修改拷贝对象的属性值会影响原对象的属性值。</p><p>因为浅拷贝只拷贝了最外面一层的对象，内部的对象只是拷贝了引用。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝是指完全复制一个对象，即使对象的属性值是对象，修改复制的对象的属性值不会影响原对象的属性值。</p><ol><li><p>通过递归实现</p><ul><li>递归很容易发生栈溢出，所以需要限制递归的深度，加退出条件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">newObj, oldObj</span>) &#123;  <span class="comment">// newObj是新对象，oldObj是旧对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> oldObj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            newObj[key] = oldObj[key] <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;</span><br><span class="line">            <span class="title function_">deepClone</span>(newObj[key], oldObj[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newObj[key] = oldObj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lodash&#x2F;cloneDeep</p><ul><li>lodash是一个工具库，提供了很多常用的方法，cloneDeep是lodash提供的深拷贝方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">friend</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;Jerry&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj)</span><br></pre></td></tr></table></figure></li><li><p>JSON.stringify()和JSON.parse()</p><ul><li><p>缺点：不能拷贝函数、正则、undefined、symbol</p></li><li><p>优点：简单易用</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">friend</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;Jerry&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol><li><p>throw抛异常</p><ul><li>throw抛出异常信息后，程序也会终止执行，后面的代码不会执行。</li><li>Error对象配合throw使用，可以自定义错误信息。</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;除数不能为0&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>try…catch捕获异常</p><ul><li>拦截错误，提示浏览器提供的错误信息，但是不会终止程序的执行。</li><li>将预估可能发生错误的代码卸载try代码段中</li><li>如果try代码段出现错误后会执行catch代码段，并截获到错误信息</li><li>finally不管是否有错误，都会执行</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">   p.<span class="property">innerHTML</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    <span class="comment">// throw new Error(&#x27;error&#x27;)  // 如果这里抛出异常，后面的代码不会执行</span></span><br><span class="line">    <span class="comment">// return </span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;finally&#x27;</span>)  <span class="comment">// 不管有没有异常，都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>debugger</p><ul><li>debugger是一个调试工具，可以在代码中设置断点，当代码执行到断点的时候会暂停执行，可以查看变量的值、调用栈等信息。</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">debugger</span> <span class="comment">// 设置断点</span></span><br><span class="line">    <span class="keyword">if</span> (b === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;除数不能为0&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="处理this"><a href="#处理this" class="headerlink" title="处理this"></a>处理this</h2><h3 id="普通函数的this指向"><a href="#普通函数的this指向" class="headerlink" title="普通函数的this指向"></a>普通函数的this指向</h3><ul><li>普通函数的调用方式决定了this的值，即<strong>谁调用this的值指向谁</strong></li><li>普通函数是没有明确调用者时this的值为window，严格模式下没有调用者时this的值为undefined(‘use strict’)</li></ul><h3 id="箭头函数的this指向"><a href="#箭头函数的this指向" class="headerlink" title="箭头函数的this指向"></a>箭头函数的this指向</h3><ul><li>箭头函数中<strong>不存在this</strong>，箭头函数会默认绑定外层this值，所以在箭头函数中的this值和外层的this值是一样的。</li><li>箭头函数中的this引用的就是最近作用域中的this</li><li>向外层作用域中，一层一层查找this，直到有this的定义</li></ul><p>在开发中，使用箭头函数前需要考虑函数中的this值，事件回调函数使用箭头函数时，this为全局的window，因此DOM事件回调函数如果里面需要DOM对象的this，则不推荐使用箭头函数。</p><p><em><strong>构造函数、原型函数、DOM事件函数等不适用箭头函数</strong></em></p><h3 id="改变this"><a href="#改变this" class="headerlink" title="改变this"></a>改变this</h3><p>下面三个方法可以动态指定普通函数中this的值</p><ol><li><p>call()，使用场景较少</p><ul><li>call()方法调用一个对象，<strong>用另一个对象替换当前对象</strong></li><li>call()方法可以接受多个参数，第一个参数是this的值，后面的参数是函数的参数</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun.call(thisArg,arg1,arg2)  thisArg是在fun函数运行时指定的this值，arg1,arg2是fun函数的参数，返回值就是fun函数的返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">fn.<span class="title function_">call</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>&#125;, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// &#123;name: &#x27;Tom&#x27;&#125; 1 2</span></span><br></pre></td></tr></table></figure></li><li><p>apply()</p><ul><li>apply()方法和call()方法类似，<strong>区别在于apply()方法接受的是一个数组</strong></li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun.apply(thisArg,[arg1,arg2])  thisArg是在fun函数运行时指定的this值，[arg1,arg2]是fun函数的参数，返回值就是fun函数的返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">fn.<span class="title function_">apply</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>])  <span class="comment">// &#123;name: &#x27;Tom&#x27;&#125; 1 2</span></span><br></pre></td></tr></table></figure></li><li><p>bind()</p><ul><li>bind()方法不会调用函数，<strong>返回由指定的this值和初始化参数改造的原函数拷贝（新函数）</strong></li><li>适用于只是想改变this指向，并且不想调用这个函数的时候。</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun.bind(thisArg,arg1,arg2)  thisArg是在fun函数运行时指定的this值，arg1,arg2是fun函数的参数，返回值是一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> newFn = fn.<span class="title function_">bind</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>&#125;, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="title function_">newFn</span>()  <span class="comment">// &#123;name: &#x27;Tom&#x27;&#125; 1 2</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p><img src="/./images/debounce.png" alt="性能优化"></p><h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h3><p>单位时间内，频繁触发事件，只执行最后一次。</p><ul><li>使用场景：搜索框搜索输入、手机号、邮箱验证输入检测</li></ul><ol><li><p>lodash库中的debounce方法</p><ul><li>lodash是一个工具库，提供了很多常用的方法，debounce是lodash提供的防抖方法</li><li>第一个参数是函数，第二个参数是延迟时间</li><li>_.debounce(func,[wait&#x3D;0],[option&#x3D;])</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newFn = _.<span class="title function_">debounce</span>(fn, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li></ol><p>2.手写一个防抖函数</p><ul><li>防抖函数的原理是通过定时器，延迟执行函数，如果在延迟时间内再次触发事件，清除定时器，重新设置定时器。</li></ul>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) <span class="comment">// 保证this指向</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h3><p>单位时间内，频繁触发事件，只执行一次。</p><ul><li>使用场景：页面滚动、尺寸缩放、滚动条等高频事件</li></ul><ol><li><p>lodash库中的throttle方法</p><ul><li>第一个参数是函数，第二个参数是延迟时间</li><li>_.throttle(func,[wait&#x3D;0],[option&#x3D;])</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newFn = _.<span class="title function_">throttle</span>(fn, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li><li><p>手写一个节流函数</p><ul><li>节流函数的原理是通过定时器，延迟执行函数，如果在延迟时间内再次触发事件，不执行函数。</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) <span class="comment">// 保证this指向</span></span><br><span class="line">                timer = <span class="literal">null</span>  <span class="comment">// 在setTimeout中无法删除定时器，因为定时器还在运作，不能用clearTimeout删除。</span></span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><h2 id="typeof、instanceof、Object-prototype-toString-call-三者区别"><a href="#typeof、instanceof、Object-prototype-toString-call-三者区别" class="headerlink" title="typeof、instanceof、Object.prototype.toString.call() 三者区别"></a>typeof、instanceof、Object.prototype.toString.call() 三者区别</h2><h3 id="1-✅-typeof"><a href="#1-✅-typeof" class="headerlink" title="1. ✅ typeof"></a>1. ✅ <code>typeof</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>           <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;hello&#x27;</span>     <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// &quot;object&quot; ❌（历史遗留）</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> []          <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;          <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="title function_">typeof</span> () =&gt; &#123;&#125;    <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>不适合判断复杂对象类型（如数组、正则、日期等）</p></blockquote><hr><h3 id="2-✅-instanceof"><a href="#2-✅-instanceof" class="headerlink" title="2. ✅ instanceof"></a>2. ✅ <code>instanceof</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span>            <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>() <span class="keyword">instanceof</span> <span class="title class_">Date</span>     <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="title class_">Object</span>         <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>        <span class="comment">// false（因为是原始值）</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>) <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>原理：沿着 <code>value.__proto__</code> 一直向上找，看是否能找到 <code>Constructor.prototype</code></p></blockquote><p>⚠️ <strong>注意</strong>：</p><ul><li>基本类型（如字符串）不是对象，不适用</li><li>在跨 iframe&#x2F;窗口场景中 <code>instanceof</code> 判断会失效，因为构造函数不同</li></ul><hr><h3 id="3-✅-Object-prototype-toString-call-value"><a href="#3-✅-Object-prototype-toString-call-value" class="headerlink" title="3. ✅ Object.prototype.toString.call(value)"></a>3. ✅ <code>Object.prototype.toString.call(value)</code></h3><p>这是最强大、最精准的方法，能判断几乎所有类型。</p><h3 id="📌-常见类型返回值对照表："><a href="#📌-常见类型返回值对照表：" class="headerlink" title="📌 常见类型返回值对照表："></a>📌 常见类型返回值对照表：</h3><table><thead><tr><th>类型</th><th>返回结果</th></tr></thead><tbody><tr><td><code>undefined</code></td><td><code>[object Undefined]</code></td></tr><tr><td><code>null</code></td><td><code>[object Null]</code></td></tr><tr><td><code>Boolean</code></td><td><code>[object Boolean]</code></td></tr><tr><td><code>Number</code></td><td><code>[object Number]</code></td></tr><tr><td><code>String</code></td><td><code>[object String]</code></td></tr><tr><td><code>Symbol</code></td><td><code>[object Symbol]</code></td></tr><tr><td><code>BigInt</code></td><td><code>[object BigInt]</code></td></tr><tr><td><code>Object</code></td><td><code>[object Object]</code></td></tr><tr><td><code>Array</code></td><td><code>[object Array]</code></td></tr><tr><td><code>Function</code></td><td><code>[object Function]</code></td></tr><tr><td><code>Date</code></td><td><code>[object Date]</code></td></tr><tr><td><code>RegExp</code></td><td><code>[object RegExp]</code></td></tr><tr><td><code>Error</code></td><td><code>[object Error]</code></td></tr><tr><td><code>Map</code></td><td><code>[object Map]</code></td></tr><tr><td><code>Set</code></td><td><code>[object Set]</code></td></tr><tr><td><code>WeakMap</code></td><td><code>[object WeakMap]</code></td></tr><tr><td><code>WeakSet</code></td><td><code>[object WeakSet]</code></td></tr><tr><td><code>Promise</code></td><td><code>[object Promise]</code></td></tr><tr><td><code>Arguments</code></td><td><code>[object Arguments]</code></td></tr><tr><td><code>Int8Array</code></td><td><code>[object Int8Array]</code></td></tr><tr><td><code>Uint8Array</code></td><td><code>[object Uint8Array]</code></td></tr><tr><td><code>ArrayBuffer</code></td><td><code>[object ArrayBuffer]</code></td></tr></tbody></table><h3 id="✅-使用方式封装："><a href="#✅-使用方式封装：" class="headerlink" title="✅ 使用方式封装："></a>✅ 使用方式封装：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getType</span>([])          <span class="comment">// &quot;Array&quot;</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">null</span>)        <span class="comment">// &quot;Null&quot;</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="function">() =&gt;</span> &#123;&#125;)    <span class="comment">// &quot;Function&quot;</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="keyword">new</span> <span class="title class_">Map</span>())   <span class="comment">// &quot;Map&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-✅-constructor"><a href="#4-✅-constructor" class="headerlink" title="4. ✅ constructor"></a>4. ✅ <code>constructor</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">123</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>        <span class="comment">// true</span></span><br><span class="line">(<span class="string">&quot;abc&quot;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>      <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>         <span class="comment">// true</span></span><br><span class="line">([]).<span class="property">constructor</span> === <span class="title class_">Array</span>          <span class="comment">// true</span></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="property">constructor</span> === <span class="title class_">Date</span>   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>⚠️ 缺点：</p><ul><li><code>constructor</code> 可被人为修改（不安全）</li><li>某些特殊对象可能没有 <code>constructor</code> 属性</li></ul><hr></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 深度拷贝 </tag>
            
            <tag> 防抖与节流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS构造函数及原型</title>
      <link href="/2025/03/21/constructor/"/>
      <url>/2025/03/21/constructor/</url>
      
        <content type="html"><![CDATA[<h2 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h2><ol><li>使用对象字面量</li><li>通过<code>new Object()</code>创建对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>通过构造函数创建对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jerry&#x27;</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><ul><li>构造函数中的this指向当前对象，通过new关键字调用构造函数时，this指向新创建的对象。</li><li>构造函数的<em><strong>首字母大写</strong></em>，约定俗成。</li><li>实例化构造函数时没有参数可以省略，不需要写return，返回值是新创建的对象。</li></ul><p><strong>❓实例化执行过程</strong></p><ol><li>创建新对象</li><li>构造函数this指向新对象</li><li>执行构造函数代码，修改this，添加新的属性</li><li>返回新对象</li></ol><h2 id="实例成员-静态成员"><a href="#实例成员-静态成员" class="headerlink" title="实例成员&amp;静态成员"></a>实例成员&amp;静态成员</h2><ul><li>实例成员： 通过构造函数创建的对象称为实例对象，实例对象中的<strong>属性和方法</strong>称为实例成员。</li><li>静态成员：构造函数的属性和方法称为静态成员，通过构造函数直接访问。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">hobby</span> = <span class="string">&#x27;swim&#x27;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eat&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">hobby</span>) <span class="comment">// swim</span></span><br></pre></td></tr></table></figure><h2 id="内置构造函数"><a href="#内置构造函数" class="headerlink" title="内置构造函数"></a>内置构造函数</h2><p>基本数据类型，比如String、Number、Boolean等也都有专门的构造函数，称为<strong>包装类型</strong>，JS中几乎所有的数据都可以通过构造函数创建。</p><h3 id="Object构造函数"><a href="#Object构造函数" class="headerlink" title="Object构造函数"></a>Object构造函数</h3><ol><li><code>Object.keys()</code>：返回对象的所有属性，返回值是一个数组。</li><li><code>Object.values()</code>：返回对象的所有属性值，返回值是一个数组。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)) <span class="comment">// [&#x27;Tom&#x27;, 18]</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>Object.assign()</code>：拷贝对象,被拷贝的放在第二个参数，拷贝的放在第一个参数。使用场景为追加属性。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj2, obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2) <span class="comment">// &#123;name: &#x27;Tom&#x27;, age: 18&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Array构造函数"><a href="#Array构造函数" class="headerlink" title="Array构造函数"></a>Array构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>, <span class="number">5</span>) <span class="comment">// [3, 5]</span></span><br></pre></td></tr></table></figure><ol><li><code>forEach()</code>：遍历数组，不返回数组，经常用于查找遍历数组元素</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><code>filter()</code>：过滤数组，返回一个新数组,返回的是筛选满足条件的数组元素</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>map()</code>：遍历数组，返回一个新数组，返回的是处理之后的数组元素。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>reduce()</code>：累加数组元素，返回累计处理的结果，经常用于求和。<br>没有初始值的时候，prev是数组的第一个元素，cur是数组的第二个元素，遍历次数是数组长度减一，有初始值的时候，prev是初始值，cur是数组的第一个元素，遍历次数是数组长度。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev + cur, <span class="number">0</span>) <span class="comment">// 0是初始值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><ol start="5"><li><code>join()</code>：将数组元素连接成一个字符串，返回一个字符串。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> str = arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>) <span class="comment">// 1-2-3-4-5，默认是逗号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br></pre></td></tr></table></figure><ol start="6"><li><code>find()</code>：查找数组元素，返回第一个满足条件的元素，找到就返回，没有符合条件的就返回undefined。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> res = arr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ol start="7"><li><code>every()</code>：判断数组元素是否都满足条件，返回布尔值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> res = arr.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol start="8"><li><code>some()</code>：判断数组元素是否有一个满足条件，返回布尔值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> res = arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="9"><li><code>concat()</code>：合并数组，返回一个新数组。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr.<span class="title function_">concat</span>(arr2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><ol start="10"><li><code>sort()</code>：排序数组，返回一个新数组。</li><li><code>splice()</code>：删除、替换、添加数组元素，返回一个新数组。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2, 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">// [1, 4, 5]</span></span><br></pre></td></tr></table></figure><ol start="12"><li><code>reverse()</code>：反转数组，返回一个新数组。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr.<span class="title function_">reverse</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">// [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><ol start="13"><li><code>findIndex()</code>：查找数组元素的索引，返回第一个满足条件的元素的索引，找到就返回，没有符合条件的就返回-1。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> index = arr.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>Array.from()</strong><br>用来把伪数组对象或可遍历对象转换为真数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="String构造函数"><a href="#String构造函数" class="headerlink" title="String构造函数"></a>String构造函数</h3><ol><li><code>length</code>：字符串长度。</li><li><code>split(&#39;分隔符&#39;&#39;)</code>：将字符串分割成数组，返回一个数组。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">const</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>substring(需要截取的第一个字符的索引，结束的索引号)</code>：截取字符串，返回一个新字符串。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>startsWith(&#39;检测字符串&#39;, 检测位置索引号)</code>：判断字符串是否以某个字符串开头，返回布尔值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">const</span> res = str.<span class="title function_">startsWith</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="5"><li><code>includes(&#39;检测字符串&#39;, 检测位置索引号)</code>：判断字符串是否包含某个字符串，返回布尔值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">const</span> res = str.<span class="title function_">includes</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="6"><li><code>toUpperCase()</code>：将字符串转换为大写。</li><li><code>toLowerCase()</code>：将字符串转换为小写。</li><li><code>indexOf()</code>：查找字符串，返回索引号。</li><li><code>endsWith()</code>：判断字符串是否以某个字符串结尾，返回布尔值。</li><li><code>replace(&#39;被替换的字符串&#39;, &#39;替换的字符串&#39;)</code>：替换字符串，返回一个新字符串。支持正则匹配</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.<span class="title function_">replace</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr) <span class="comment">// hi world</span></span><br></pre></td></tr></table></figure><ol start="11"><li><code>match()</code>：查找字符串，返回一个数组。支持正则匹配</li></ol><h3 id="Number构造函数"><a href="#Number构造函数" class="headerlink" title="Number构造函数"></a>Number构造函数</h3><ol><li>toFixed()：保留小数位数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">3.1415926</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>)) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><h3 id="构造函数存在浪费内存的问题"><a href="#构造函数存在浪费内存的问题" class="headerlink" title="构造函数存在浪费内存的问题"></a>构造函数存在浪费内存的问题</h3><ul><li>构造函数中如果有方法，每次实例化都会在堆上创建一个方法对象，浪费内存</li><li>如果希望所有的对象使用同一个函数来节省内存，可以使用<strong>原型</strong></li></ul><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><ul><li>构造函数通过原型分配的函数是所有对象<em><strong>共享</strong></em>的，JS规定，每一个构造函数都有一个prototype属性，指向另一个对象，也称为原型对象。</li><li>这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节省内存</li><li>我们可以把不变的方法直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。</li><li>构造函数和原型对象中的this都指向实例化的对象。</li></ul><h3 id="1-Constructor属性"><a href="#1-Constructor属性" class="headerlink" title="1. Constructor属性"></a>1. Constructor属性</h3><ul><li>每个原型对象都有一个constructor属性，该属性指向该原型对象的构造函数</li><li>如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象constructor就不指向当前构造函数了，这个时候可以在修改后的原型对象中，添加一个constructor指向原来的构造函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">sing</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sing&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">dance</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dance&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>   <span class="comment">// 添加constructor指向构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>❓为什么实例对象可以访问原型对象里的属性和方法呢？</p><h3 id="2-对象原型"><a href="#2-对象原型" class="headerlink" title="2. 对象原型"></a>2. 对象原型</h3><p>在每一个实例对象中都有一个属性<code>__proto__</code>，指向构造函数的原型对象，也就是<code>Person.prototype</code>。</p><ul><li><code>__proto__</code>是JS非标准属性，与<code>[[Prototype]]</code>意义相同，都是用来表明当前实例对象指向哪个原型对象prototype</li><li><code>__proto__</code>对象原型中也有一个constructor属性，指向创建该实例对象的构造函数<br><img src="/images/prototype.png" alt="三者关系图"></li></ul><h3 id="3-原型继承"><a href="#3-原型继承" class="headerlink" title="3. 原型继承"></a>3. 原型继承</h3><p>JavaScript中大多是借助原型对象实现继承的特性。</p><p><strong>子类的原型 &#x3D; new 父类的实例对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eye</span> = <span class="number">2</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span></span><br></pre></td></tr></table></figure><h3 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4. 原型链"></a>4. 原型链</h3><p>基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链。</p><p><img src="/images/proto.png" alt="原型链"></p><p>原型链是查找规则：</p><ol><li>当访问一个对象的属性（包括方法）的时候，首先查找这个对象自身有没有该属性。</li><li>如果没有就查找它的原型，也就是**<strong>proto</strong>**指向的对象。</li><li>如果还没有就查找原型对象的原型</li><li>以此类推一直找到Object为止。</li><li>__proto__对象的原型的意义是为对象成员查找机制提供一个方向，或者说是一条路线</li><li>可以使用instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS函数、解构赋值</title>
      <link href="/2025/03/19/jsStudy4/"/>
      <url>/2025/03/19/jsStudy4/</url>
      
        <content type="html"><![CDATA[<h2 id="☁️-函数"><a href="#☁️-函数" class="headerlink" title="☁️ 函数"></a>☁️ 函数</h2><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>与变量提升相似，是指函数在声明之前即可被调用。</p><ul><li>会把所有函数声明提升到当前作用域的最前面，只提升函数声明，不提升函数调用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数提升</span></span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数表达式必须先声明赋值再调用</li></ul><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li>动态参数：函数的参数个数不固定，可以通过arguments对象获取所有参数。argument是伪数组，可以通过下标访问。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum += <span class="variable language_">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))  <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))  <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><ul><li>剩余参数：允许将不定数量的参数表示为一个数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev + next)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))  <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))  <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>两者的区别：剩余参数中<code>...</code>是语法符号，置于最末函数形参之前，用于获取多余的实参，是一个真数组。开发中，提倡使用<em><strong>剩余参数</strong></em>。</p><blockquote><p><strong>展开运算符</strong></p><ul><li>展开运算符<code>...</code>可以将数组展开，不会改变原数组。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr)  <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li>用于合并数组, 求数组最大值等。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr = [...arr1, ...arr2]  <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...arr)  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="箭头函数（ES6）"><a href="#箭头函数（ES6）" class="headerlink" title="箭头函数（ES6）"></a>箭头函数（ES6）</h3><p>适用于匿名函数，简化函数定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数，可以省略括号</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = a =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个参数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有返回值，可以省略大括号和return</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params">a, b</span>) =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象，需要用小括号包裹，加括号的函数题返回对象字面量表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params">uname</span>) =&gt; (&#123;<span class="attr">uname</span>: uname&#125;) </span><br></pre></td></tr></table></figure><ul><li>箭头函数中没有<code>arguments</code>对象，有剩余参数。</li><li>this：箭头函数没有自己的this，只会从自己的作用域链的<strong>上一层</strong>沿用this。</li><li>DOM事件回调函数为了简便，不推荐使用箭头函数，因为this指向的是window。</li></ul><h2 id="☁️-解构赋值"><a href="#☁️-解构赋值" class="headerlink" title="☁️ 解构赋值"></a>☁️ 解构赋值</h2><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><ul><li><p>是将数组的单元值快速批量赋值给一系列变量的简洁语法。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">60</span>, <span class="number">80</span>]</span><br><span class="line"><span class="keyword">const</span> [max, min, avg] = arr</span><br></pre></td></tr></table></figure></li><li><p>典型应用：交换变量值</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;  <span class="comment">// 加分号，防止代码压缩时出错</span></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure></li><li><p>如果变量多，单元值少，多余的变量值为undefined。</p></li><li><p>如果变量少，单元值多，多余的单元值会被忽略。</p></li><li><p>可以利用剩余参数</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span>  [a,...b] = arr  <span class="comment">// b = [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>可以设置默认值</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> [a, b = <span class="number">2</span>] = arr  <span class="comment">// b = 2</span></span><br></pre></td></tr></table></figure></li><li><p>按需导入，忽略不需要的值</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> [,,a,,b] = arr  <span class="comment">// a = 3, b = 5</span></span><br></pre></td></tr></table></figure></li><li><p>多维数组解构</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">const</span> [a, b, [c, d]] = arr  <span class="comment">// a = 1, b = 2, c = 3, d = 4</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>是将对象的属性和方法快速批量赋值给一系列变量的简洁语法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name, age&#125; = obj</span><br></pre></td></tr></table></figure><ul><li><p>对象属性的值将复制给与属性名<strong>相同的</strong>变量</p></li><li><p>解构的变量名不要和外面的变量名重复</p></li><li><p>对象中找不到与变量名一致的属性时变量值为undefined</p></li><li><p>如果对象属性名和变量名不一致，可以使用别名 <strong>旧变量名: 新变量名</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>: uname, <span class="attr">age</span>: uage&#125; = obj</span><br></pre></td></tr></table></figure></li><li><p>数组对象解构</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = [&#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Jerry&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;]</span><br><span class="line"><span class="keyword">const</span> [&#123; name, age &#125;, &#123; <span class="attr">name</span>: uname, <span class="attr">age</span>: uage &#125;] = obj</span><br></pre></td></tr></table></figure></li><li><p>多级对象解构</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">friend</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;Jerry&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age, <span class="attr">friend</span>: &#123; <span class="attr">name</span>: uname, <span class="attr">age</span>: uage &#125; &#125; = obj</span><br></pre></td></tr></table></figure></li><li><p><strong>传参</strong>可以使用对象解构</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端返回数据</span></span><br><span class="line"><span class="keyword">const</span> msg = &#123;</span><br><span class="line">   <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">   <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">   <span class="string">&quot;data&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">         <span class="string">&quot;age&quot;</span>: <span class="number">18</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jerry&quot;</span>,</span><br><span class="line">         <span class="string">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">&#123;data&#125;</span>) &#123;  <span class="comment">// 直接使用对象解构</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">show</span>(msg)  <span class="comment">// 直接传入对象</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>forEach方法，用于调用数组的每个元素，并将元素传递给回调函数。起遍历作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(item, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>与map的区别是：forEach没有返回值，map有返回值。</p></blockquote><blockquote><p>filter方法，用于过滤数组中的元素，返回符合条件的元素组成的新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)  <span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 函数 </tag>
            
            <tag> 解构赋值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript作用域</title>
      <link href="/2025/03/19/jsScope/"/>
      <url>/2025/03/19/jsScope/</url>
      
        <content type="html"><![CDATA[<h3 id="💭局部作用域"><a href="#💭局部作用域" class="headerlink" title="💭局部作用域"></a>💭局部作用域</h3><ul><li>函数作用域：函数内部声明的变量只能在函数内部访问<ul><li>函数的参数也是局部变量</li><li>不同函数内部的同名变量互不影响</li><li>函数执行完毕后，局部变量会被销毁</li></ul></li><li>块级作用域：<code>let</code>和<code>const</code>声明的变量只能在块级作用域内访问（<strong>ES6新增</strong>）<ul><li>块级作用域：<code>&#123;&#125;</code>包裹的代码块，比如<code>if</code>、<code>for</code>、<code>while</code>等</li><li>代码块内部声明的比那两外部<strong>有可能</strong>无法访问（var声明的变量可以访问）</li></ul></li></ul><h3 id="💭全局作用域"><a href="#💭全局作用域" class="headerlink" title="💭全局作用域"></a>💭全局作用域</h3><ul><li>全局作用域：在函数外部声明的变量，所有函数内部都可以访问<ul><li>为window对象动态添加的属性也是全局变量（不推荐）</li><li>函数中未使用<code>var</code>、<code>let</code>、<code>const</code>声明的变量也是全局变量（不推荐）</li><li>尽可能避免全局变量，会造成全局变量污染</li></ul></li></ul><h3 id="💭作用域链"><a href="#💭作用域链" class="headerlink" title="💭作用域链"></a>💭作用域链</h3><p>本质是底层的变量查找机制，当访问一个变量时，会先在当前作用域查找，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域。</p><ul><li>嵌套关系的作用域串联起来形成了作用域链</li><li>相同作用域链中按着从小到大的规则查找变量</li><li>子作用域能够访问父作用域的变量，反之不行</li></ul><h3 id="💭JS垃圾回收机制GC（Garbage-Collection）"><a href="#💭JS垃圾回收机制GC（Garbage-Collection）" class="headerlink" title="💭JS垃圾回收机制GC（Garbage Collection）"></a>💭JS垃圾回收机制GC（Garbage Collection）</h3><p>JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。</p><ul><li>内存的生命周期：<ul><li>内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存。</li><li>内存使用：即读写内存，也就是使用变量、函数等。</li><li>内存回收，使用完毕，由垃圾回收器自动回收不再使用的内存。</li></ul></li><li>全局变量一般不会回收（关闭页面回收）</li><li>一般情况下局部变量的值会被自动回收。</li><li>内存泄漏：程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏。</li><li><strong>💻 算法说明</strong><ul><li><p>栈、堆</p><ul><li>栈：由<em><strong>操作系统自动分配释放</strong></em>函数的参数值、局部变量等，基本数据类型放到栈里面。</li><li>堆：一般由程序员分配释放，若程序员不释放，由<em><strong>垃圾回收机制回收</strong></em>，复杂数据类型放到堆里面。</li></ul></li><li><p>引用计数法（不常使用）</p><ul><li>定义内存不再使用就是看<strong>一个对象是否有指向它的引用</strong>，没有引用了就会被回收。<ol><li>跟踪记录被引用的次数</li><li>如果被引用了一次，那么记录次数为1，多次引用会累加，减少引用次数会减少。</li><li>如果引用次数为0，则释放内存。</li></ol></li><li><strong>缺点</strong>：嵌套引用（循环引用），如果两个对象相互引用，尽管他们已经不再被使用，但是引用次数不为0，导致无法回收，也就是内存泄漏。</li></ul></li><li><p>标记清除法</p><ul><li>定义不再使用的对象为<strong>无法达到的对象</strong>，即从根部（在js中是全局对象）出发定时扫描内存中的对象。凡是能从<strong>根部到达</strong><br>的对象，都是还需要使用的。</li><li>无法从根部出发触及到的对象标记为不再使用，稍后进行回收。</li></ul></li></ul></li></ul><h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><p>一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域。</p><ul><li><p><strong>闭包 &#x3D; 内层函数 + 外层函数的变量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>  <span class="comment">// a定义在outer函数内部，外部无法访问</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;  <span class="comment">// inner函数是闭包，如果外部想访问a，就可以通过inner函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="title function_">outer</span>() </span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>作用：封闭数据，实现数据私有，外部也可以访问函数内部的变量。允许将函数与其所操作的某些数据关联起来，但可能引起内存泄漏。</p></li></ul><ol><li>统计函数调用次数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        num++</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="title function_">count</span>()</span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>允许在声明变量之前使用变量，仅存在于var声明的变量。</p><p>当代码在执行之前，会把在当前作用域下所有用var声明的变量和函数声明提升到当前作用域的最前面。只提升声明，不提升赋值。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 作用域 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> 变量提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2025/03/18/reg/"/>
      <url>/2025/03/18/reg/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是正则表达式"><a href="#1-什么是正则表达式" class="headerlink" title="1. 什么是正则表达式"></a>1. 什么是正则表达式</h2><p>正则表达式是一种用来匹配字符串的强有力的工具，它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，就认为是匹配的。</p><p>在JavaScript中，正则表达式是对象，通常用来检索、替换那些符合某个模式的文本。匹配（验证表单）、替换（过滤敏感词）、提取（爬虫）等。</p><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h2><h3 id="定义正则表达式"><a href="#定义正则表达式" class="headerlink" title="定义正则表达式"></a>定义正则表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment">// 1. 字面量定义：`/正则表达式/修饰符`</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/hello/</span></span><br><span class="line"><span class="comment">// 2. 构造函数定义：`new RegExp(&#x27;正则表达式&#x27;, &#x27;修饰符&#x27;)`</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="判断字符串是否符合规则"><a href="#判断字符串是否符合规则" class="headerlink" title="判断字符串是否符合规则"></a>判断字符串是否符合规则</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="检索（查找）符合规则的字符串"><a href="#检索（查找）符合规则的字符串" class="headerlink" title="检索（查找）符合规则的字符串"></a>检索（查找）符合规则的字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regObj.<span class="title function_">exec</span>(str) <span class="comment">// 返回一个数组，包含匹配的字符串，index，input</span></span><br></pre></td></tr></table></figure><h2 id="3-元字符"><a href="#3-元字符" class="headerlink" title="3.元字符"></a>3.元字符</h2><ul><li>普通字符：字母、数字，仅仅描述字符本身。</li><li>元字符：具有特殊含义的字符，用来描述字符的组合规则，比如26字母可以写成<code>[a-z]</code>。</li></ul><h3 id="🦮边界符"><a href="#🦮边界符" class="headerlink" title="🦮边界符"></a>🦮边界符</h3><p><strong>表示位置，开头和结尾，必须用什么开头，用什么结尾。</strong></p><ul><li><code>^</code>：匹配字符串的开始。</li><li><code>$</code>：匹配字符串的结束。</li><li>比如：<code>/^hello$/</code>表示字符串必须是<code>hello</code>，或者<code>/^hello/</code>表示字符串必须以<code>hello</code>开头，<code>/hello$/</code>表示字符串必须以<code>hello</code>结尾。</li></ul><h3 id="🦮量词"><a href="#🦮量词" class="headerlink" title="🦮量词"></a>🦮量词</h3><p><strong>描述字符出现的次数。</strong></p><ul><li><code>*</code>：匹配前一个字符0次或多次，比如<code>/a*/</code>可以匹配<code>&#39;&#39;</code>、<code>&#39;a&#39;</code>、<code>&#39;aa&#39;</code>等。</li><li><code>+</code>：匹配前一个字符1次或多次，比如<code>/a+/</code>可以匹配<code>&#39;a&#39;</code>、<code>&#39;aa&#39;</code>、<code>&#39;aaa&#39;</code>等。</li><li><code>?</code>：匹配前一个字符0次或1次，比如<code>/a?/</code>可以匹配<code>&#39;&#39;</code>、<code>&#39;a&#39;</code>。</li><li><code>&#123;n&#125;</code>：匹配前一个字符n次，比如<code>/a&#123;3&#125;/</code>可以匹配<code>&#39;aaa&#39;</code>。</li><li><code>&#123;n,&#125;</code>：匹配前一个字符至少n次，比如<code>/a&#123;3,&#125;/</code>可以匹配<code>&#39;aaa&#39;</code>、<code>&#39;aaaa&#39;</code>。</li><li><code>&#123;n,m&#125;</code>：匹配前一个字符n到m次，比如<code>/a&#123;3,5&#125;/</code>可以匹配<code>&#39;aaa&#39;</code>、<code>&#39;aaaa&#39;</code>、<code>&#39;aaaaa&#39;</code>。</li></ul><h3 id="🦮字符类"><a href="#🦮字符类" class="headerlink" title="🦮字符类"></a>🦮字符类</h3><ul><li><code>[]</code>：匹配方括号中的任意一个字符。</li><li><code>[^]</code>：匹配除了方括号中的任意一个字符。</li><li><code>-</code>：连字符，表示范围，比如<code>[a-z]</code>表示26个小写字母。</li><li><code>\d</code>：匹配任意一个数字，等价于<code>[0-9]</code>。</li><li><code>\D</code>：匹配任意一个非数字，等价于<code>[^0-9]</code>。</li><li><code>\w</code>：匹配任意一个字母、数字、下划线，等价于<code>[a-zA-Z0-9_]</code>。</li><li><code>\W</code>：匹配任意一个非字母、数字、下划线，等价于<code>[^a-zA-Z0-9_]</code>。</li><li><code>\s</code>：匹配任意一个空白字符，包括空格、制表符、换行符等。</li><li><code>\S</code>：匹配任意一个非空白字符。</li><li><code>.</code>：匹配除了换行符之外的任意一个字符。</li></ul><h2 id="4-修饰符"><a href="#4-修饰符" class="headerlink" title="4.修饰符"></a>4.修饰符</h2><p>修饰符约束正则执行的某些细节行为，如是否区分大小写、是否多行匹配等。</p><ul><li><code>i</code>：忽略大小写。</li><li><code>g</code>：全局匹配，匹配所有符合规则的字符串。</li><li><code>m</code>：多行匹配，匹配每一行的开头和结尾。</li><li><code>s</code>：单行匹配，<code>.</code>可以匹配换行符。</li><li><code>u</code>：Unicode模式，处理大于<code>\uFFFF</code>的Unicode字符。</li><li><code>y</code>：粘连模式，匹配从上次匹配的位置开始。<br>例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/hello/gi</span>  <span class="comment">// 忽略大小写，全局匹配</span></span><br></pre></td></tr></table></figure></li><li>.replace()方法,替换字符串,第一个参数是正则表达式,第二个参数是要替换的字符串<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">replace</span>(<span class="regexp">/hello/</span>, <span class="string">&#x27;hi&#x27;</span>) <span class="comment">// 又发返回值,不会改变原字符串，并且只会替换第一个匹配到的字符串</span></span><br><span class="line"><span class="keyword">const</span> result2 = str.<span class="title function_">replace</span>(<span class="regexp">/hello/g</span>, <span class="string">&#x27;hi&#x27;</span>) <span class="comment">// 全局匹配,会替换所有匹配到的字符串</span></span><br></pre></td></tr></table></figure><blockquote><p><code>|</code>：或者，匹配多个规则中的一个。’</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web APIs学习 --BOM（三）</title>
      <link href="/2025/03/18/bomStudy/"/>
      <url>/2025/03/18/bomStudy/</url>
      
        <content type="html"><![CDATA[<h2 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h2><h3 id="1-BOM对象"><a href="#1-BOM对象" class="headerlink" title="1.BOM对象"></a>1.BOM对象</h3><ul><li><p><code>BOM</code>是浏览器对象模型，是浏览器提供的对象模型，用于操作浏览器窗口。</p></li><li><p>全局对象，document、location、navigator、history都是window的属性。</p></li></ul><h3 id="2-定时器-延时函数"><a href="#2-定时器-延时函数" class="headerlink" title="2.定时器-延时函数"></a>2.定时器-延时函数</h3><ul><li><code>setTimeout</code>：延时执行一次，返回值是一个定时器ID。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;延时执行&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li><li>清除延时函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clearTimeout</span>(timer)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-JS执行机制"><a href="#3-JS执行机制" class="headerlink" title="3.JS执行机制"></a>3.JS执行机制</h3><ul><li>浏览器有两个引擎：JS引擎和渲染引擎。</li><li>单线程执行，同一时间只能执行一个任务。</li><li>同步和异步任务：同步任务会阻塞后续任务，异步任务不会阻塞后续任务。</li><li>同步任务在主线程执行，形成一个执行栈。</li><li>异步任务相关会放到任务队列中，等待主线程空闲时执行。</li><li>异步任务有三种类型：普通事件、资源加载、定时器。</li><li>一旦执行栈中所有的同步任务执行完毕，就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</li><li><strong>事件循环</strong>：主线程从任务队列中读取事件，这个过程是循环不断的，所以叫事件循环。</li></ul><h3 id="4-location对象"><a href="#4-location对象" class="headerlink" title="4.location对象"></a>4.location对象</h3><ul><li>location的数据类型是对象，拆分并保存了URL地址的各个组成部分</li><li>location对象的属性：<ul><li><code>href</code>：获取或设置整个URL地址。</li><li><code>protocol</code>：获取或设置协议部分。</li><li><code>host</code>：获取或设置主机部分。</li><li><code>hostname</code>：获取或设置主机名。</li><li><code>port</code>：获取或设置端口号。</li><li><code>pathname</code>：获取或设置路径部分。</li><li><code>search</code>：获取或设置查询部分，以<code>?</code>开头。</li><li><code>hash</code>：获取或设置哈希部分，以<code>#</code>开头。</li><li><code>.reload()</code>：重新加载页面,true强制从服务器加载，false从缓存加载。</li></ul></li></ul><h3 id="5-navigator对象"><a href="#5-navigator对象" class="headerlink" title="5.navigator对象"></a>5.navigator对象</h3><ul><li>navigator对象包含了浏览器的信息，比如浏览器的名称、版本、操作系统等。</li><li>userAgent属性：检测浏览器的版本及平台。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> userAgent = navigator.<span class="property">userAgent</span></span><br><span class="line">    <span class="keyword">const</span> android = userAgent.<span class="title function_">match</span>(<span class="regexp">/(Android);?[\s\/]+([\d.]+)?/</span>)</span><br><span class="line">    <span class="keyword">const</span> iphone = userAgent.<span class="title function_">match</span>(<span class="regexp">/(iPhone\sOS)\s([\d_]+)/</span>)</span><br><span class="line">    <span class="keyword">if</span>(android||iphone) &#123;</span><br><span class="line">        location.<span class="property">href</span> = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-history对象"><a href="#6-history对象" class="headerlink" title="6.history对象"></a>6.history对象</h3><ul><li>history对象管理历史记录，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等。</li><li>back()：后退</li><li>forward()：前进</li><li>go()：前进或后退，1为前进，-1为后退。</li></ul><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><ul><li>起因：存在需要存储在本地的数据。</li><li>HTML5提供了两种本地存储方式：<code>localStorage</code>和<code>sessionStorage</code>，约5MB左右。</li><li>数据存储在用户浏览器中，设置、读取方便、页面刷新不会丢失。</li></ul><h3 id="本地存储分类"><a href="#本地存储分类" class="headerlink" title="本地存储分类"></a>本地存储分类</h3><ul><li><code>localStorage</code>：永久存储，除非手动删除。可以跨窗口，以键值对的形式存储，只能存储字符串。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(key, value)</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key)</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(key)</span><br></pre></td></tr></table></figure></li><li><code>sessionStorage</code>：会话存储，关闭浏览器窗口后自动删除。在同一个窗口下可以共享数据。</li></ul><h3 id="存储复杂数据类型"><a href="#存储复杂数据类型" class="headerlink" title="存储复杂数据类型"></a>存储复杂数据类型</h3><ul><li>想要存储对象，需要先将对象转换为字符串，再存储。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;obj&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line"><span class="keyword">const</span> objStr = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;obj&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(objStr)</span><br></pre></td></tr></table></figure>其中，<code>JSON.stringify()</code>将对象转换为字符串，<code>JSON.parse()</code>将字符串转换为对象。</li></ul><blockquote><p>利用map方法和join方法实现字符串的拼接</p><p>map方法：遍历数组，返回<strong>一个新数组</strong>,map也称为映射，指两个元素的集之间元素相互对应的关系，map重点有返回值，forEach没有返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>) <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line"><span class="keyword">const</span> newArr2 = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>item+index)</span><br></pre></td></tr></table></figure><p>join方法：将数组中的所有元素连接成一个字符串，返回<strong>一个字符串</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> str = arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>) <span class="comment">// 1-2-3-4-5，默认是逗号</span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web APIs学习 --DOM（二）</title>
      <link href="/2025/03/18/domStudy2/"/>
      <url>/2025/03/18/domStudy2/</url>
      
        <content type="html"><![CDATA[<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><p>用来表示时间的对象，可以得到当前系统时间。</p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="keyword">const</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2021-01-01&#x27;</span>) <span class="comment">// 获取指定时间</span></span><br></pre></td></tr></table></figure><h3 id="时间对象方法"><a href="#时间对象方法" class="headerlink" title="时间对象方法"></a>时间对象方法</h3><p>返回的数据不适用于直接使用，该怎么转换为实际开发中常用的格式呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date) <span class="comment">// 2021-01-01T00:00:00.000Z</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getFullYear</span>()) <span class="comment">// 2021 年份</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getMonth</span>()) <span class="comment">// 0 月份 0-11 注意是从0开始！</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getDate</span>()) <span class="comment">// 1 日期</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getDay</span>()) <span class="comment">// 5 星期 0-6 0是星期天</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getHours</span>()) <span class="comment">// 8 小时</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getMinutes</span>()) <span class="comment">// 0 分钟</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getSeconds</span>()) <span class="comment">// 0 秒</span></span><br></pre></td></tr></table></figure><p>常见的拼接方式，写成函数的格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatDate</span>(<span class="params">date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;date.getFullYear()&#125;</span>-<span class="subst">$&#123;date.getMonth() + <span class="number">1</span>&#125;</span>-<span class="subst">$&#123;date.getDate()&#125;</span> <span class="subst">$&#123;date.getHours()&#125;</span>:<span class="subst">$&#123;date.getMinutes()&#125;</span>:<span class="subst">$&#123;date.getSeconds()&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想让月份和日期显示两位数，可以使用<strong>padStart</strong>方法，这个方法是ES6新增的方法，用于字符串补全长度。第一个参数是字符串的最小长度，第二个参数是用来补全的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatDate</span>(<span class="params">date</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> year = date.<span class="title function_">getFullYear</span>()</span><br><span class="line">    <span class="keyword">const</span> month = (date.<span class="title function_">getMonth</span>() + <span class="number">1</span>).<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> day = date.<span class="title function_">getDate</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> hour = date.<span class="title function_">getHours</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> minute = date.<span class="title function_">getMinutes</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> second = date.<span class="title function_">getSeconds</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;month&#125;</span>-<span class="subst">$&#123;day&#125;</span> <span class="subst">$&#123;hour&#125;</span>:<span class="subst">$&#123;minute&#125;</span>:<span class="subst">$&#123;second&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么才能让时间实时更新呢？可以使用定时器，每隔一秒更新一次时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatDate</span>(date))</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>还有一些内置的格式化方法，比如<strong>toLocaleString</strong>方法，可以根据本地时间格式化日期。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleString</span>()) <span class="comment">// 2021/1/1 04:00:00</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleDateString</span>()) <span class="comment">// 2021/1/1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleTimeString</span>()) <span class="comment">// 04:00:00</span></span><br></pre></td></tr></table></figure><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><blockquote><p>时间戳是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数，可以用来表示一个时间点。</p></blockquote><p>使用场景比如说要计算倒计时效果，可以使用时间戳来计算。算法是：目标时间戳减去当前时间戳，得到的是毫秒数，再除以1000得到秒数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetTime = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2021-01-01&#x27;</span>).<span class="title function_">getTime</span>()</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">const</span> second = (targetTime - nowTime) / <span class="number">1000</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(second)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>还有更简洁的办法！下面是三个获取时间戳的方法，都是获取当前时间戳。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time1 = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="keyword">const</span> time2 = +<span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">//推荐</span></span><br><span class="line"><span class="keyword">const</span> time3 = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 只能获取当前时间戳</span></span><br></pre></td></tr></table></figure><p>拿到相差的毫秒数后，可以转换为天、时、分、秒的格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetTime = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2021-01-01&#x27;</span>).<span class="title function_">getTime</span>()</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">const</span> second = (targetTime - nowTime) / <span class="number">1000</span></span><br><span class="line">    <span class="keyword">const</span> day = <span class="title class_">Math</span>.<span class="title function_">floor</span>(second / <span class="number">3600</span> / <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">const</span> hour = <span class="title class_">Math</span>.<span class="title function_">floor</span>(second / <span class="number">3600</span> % <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">const</span> minute = <span class="title class_">Math</span>.<span class="title function_">floor</span>(second / <span class="number">60</span> % <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">const</span> sec = <span class="title class_">Math</span>.<span class="title function_">floor</span>(second % <span class="number">60</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;day&#125;</span>天<span class="subst">$&#123;hour&#125;</span>时<span class="subst">$&#123;minute&#125;</span>分<span class="subst">$&#123;sec&#125;</span>秒`</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><p>DOM节点是HTML文档中的元素，可以通过JS来操作DOM节点，比如增删改查。节点类型有：</p><ul><li><strong>元素节点</strong>：HTML标签</li><li>文本节点</li><li>属性节点</li><li>其他</li></ul><h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><p>利用<strong>parentNode</strong>属性可以找到父节点，返回最近一级的父节点，找不到返回null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = son.<span class="property">parentNode</span></span><br></pre></td></tr></table></figure><h4 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h4><ul><li>利用<strong>childNodes</strong>属性可以找到子节点，返回一个伪数组，包含所有子节点，包括文本节点和注释节点等。</li><li><strong>children属性只包含元素节点，不包含文本节点，返回的依旧是伪数组。</strong></li></ul><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><ul><li><strong>previousElementSibling</strong>属性可以找到前一个兄弟节点。</li><li><strong>nextElementSibling</strong>属性可以找到后一个兄弟节点。</li></ul><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><p>很多情况需要在页面中新增节点，比如点击发布按钮后新增一条信息。</p><p><strong>两个步骤：创建节点、追加节点。</strong></p><ul><li><strong>createElement</strong>方法可以创建元素节点。</li><li><strong>appendChild</strong>方法可以追加节点，插入到某个父元素的最后。</li><li><strong>insertBefore</strong>方法可以插入到某个父元素的某个子元素前。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建节点</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. 追加节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line"><span class="comment">// 父元素.insertBefore(新元素, 参考元素)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><p><strong>cloneNode</strong>方法可以克隆节点，参数是一个布尔值，true表示深拷贝，克隆节点及其子节点，false表示浅拷贝，只克隆节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> div2 = div.<span class="title function_">cloneNode</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 追加</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div2)</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p><strong>removeChild</strong>方法可以删除节点，参数是要删除的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父元素.removeChild(子元素)</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(div)</span><br></pre></td></tr></table></figure><blockquote><p>M端事件，移动端又一些独特的地方，比如触屏事件touch，可以响应用户手指或触控笔对屏幕或触控版的操作。</p><p>常见的touch事件有：touchstart、touchmove、touchend。</p></blockquote><h2 id="JS插件"><a href="#JS插件" class="headerlink" title="JS插件"></a>JS插件</h2><p>插件就是别人写好的一些代码，我们只需要复制对应的代码，就可以直接实现对应的效果，比如轮播图、日历等。</p><p>swiper是一个轮播图插件，可以实现轮播图效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span> = <span class="string">./css/swiper.min.css</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/swiper.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web APIs学习 --DOM（一）</title>
      <link href="/2025/03/17/domstudy1/"/>
      <url>/2025/03/17/domstudy1/</url>
      
        <content type="html"><![CDATA[<h3 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h3><ul><li>尽量用const，少用let，不用var。</li><li>数组和对象用const，数组和对象的元素和属性可以改变。因为const只是保证变量指向的内存地址不变，不保证内存地址的值不变。</li></ul><h3 id="基本认知"><a href="#基本认知" class="headerlink" title="基本认知"></a>基本认知</h3><ul><li>Web API就是使用js去操作html和浏览器</li><li>分类：DOM（文档对象模型）、BOM（浏览器对象模型）</li><li>DOM是用来呈现以及与任意HTML或XML文档交互的API，主要<strong>操作网页内容</strong>，比如对页面元素进行移动、大小、添加删除等操作。开发网页内容特效和实现用户交互</li></ul><h4 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h4><p>将HTML文档以树状结构直观的表现出来，文档树直观的体现了标签与标签之间的关系。<br><img src="/images/js/domtree.png" alt="DOM树"></p><ul><li>DOM树的节点类型<ul><li>元素节点：HTML标签</li><li>文本节点：HTML文本</li><li>属性节点：HTML属性</li><li>注释节点：HTML注释</li></ul></li></ul><h4 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h4><p>浏览器根据html标签生成的js对象，所有的标签属性都可以在这个对象上面找到，修改这个对象的属性会自动映射到标签身上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元素对象,在html中是标签，在js中获取到的是对象。</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure><p>DOM的核心思想：<strong>把网页内容当作对象来处理，通过js操作DOM对象，从而改变页面内容</strong></p><ul><li>document对象：代表整个文档，是DOM树的根节点，所以它所提供的属性和方法都是用来访问和操作网页内容的，网页所有内容都在document中。</li></ul><h4 id="获取DOM对象"><a href="#获取DOM对象" class="headerlink" title="获取DOM对象"></a>获取DOM对象</h4><ul><li>根据CSS选择器获取元素对象<ul><li><code>document.querySelector(&#39;css选择器&#39;)</code>：获取第一个符合条件的元素对象，返回值是一个HTMLElement对象</li><li><code>document.querySelectorAll(&#39;css选择器&#39;)</code><br>：获取所有符合条件的元素对象，返回值是一个NodeList对象集合,获取到的是伪数组，有长度有索引，但是不能使用pop、push等数组方法。想要得到里面的每一个对象，可以使用forEach遍历。</li><li><code>document.getElementById(&#39;id&#39;)</code>：根据id获取元素对象，返回值是一个HTMLElement对象</li><li><code>document.getElementsByClassName(&#39;class&#39;)</code>：根据class获取元素对象，返回值是一个HTMLCollection对象集合</li><li><code>document.getElementsByTagName(&#39;tag&#39;)</code>：根据标签名获取元素对象，返回值是一个HTMLCollection对象集合</li></ul></li></ul><blockquote><p>CSS选择器</p><ul><li>标签选择器：<code>div</code>，<code>p</code>，<code>span</code></li><li>类选择器：<code>.class</code>，<code>.active</code>，<code>.container</code></li><li>id选择器：<code>#id</code></li><li>属性选择器：<code>div[class=&quot;container&quot;]</code></li><li>伪类选择器：<code>:hover</code>，<code>:active</code>，<code>:first-child</code></li><li>伪元素选择器：<code>::before</code>，<code>::after</code></li><li>后代选择器：<code>div p</code> 指的是div下的所有p</li><li>子元素选择器：<code>div &gt; p</code> 指的是div下的直接子元素p</li><li>相邻兄弟选择器：<code>div + p</code> 指的是div后面的第一个p</li><li>通用选择器：<code>*</code></li><li>分组选择器：<code>div, p</code> 指的是div和p</li></ul></blockquote><h4 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h4><ul><li><p>操作元素内容</p><ul><li><code>element.innerHTML</code>：获取元素内部的html内容，比如<code>&lt;div&gt;hello&lt;/div&gt;</code>，获取到的是<code>hello</code>，将html内容添加到元素中，会解析html标签。</li><li><code>element.innerText</code>：获取元素内部的文本内容，比如<code>&lt;div&gt;hello&lt;/div&gt;</code>，获取到的是<code>hello</code>，将文本内容添加到元素中，会自动转义，不会解析html标签。</li></ul></li><li><p>操作元素属性</p><ul><li><code>element.style</code>：获取元素的样式，返回一个对象，可以通过这个对象修改元素的样式。如果是background-color这种属性，需要改成<br><strong>小驼峰命名法</strong>，比如<code>backgroundColor</code>。</li><li><code>element.className</code>：获取元素的class属性，返回一个字符串，可以通过这个字符串修改元素的class属性。具体来说，事先在css中定义好样式，然后通过js修改元素的class属性，从而改变元素的样式。<br>如果原先有类名，要注意保留原来的类名。</li><li><code>element.classList</code>：<strong>终极解决方案</strong>，为了解决className容易覆盖以前的类型，我们可以通过classList的方式追加和删除类名。  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">element.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">element.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;active&#x27;</span>) <span class="comment">// 如果有就删除，没有就添加 切换</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>操作表单元素属性</p><ul><li><code>element.value</code>：获取表单元素的值，比如input、textarea、select等。</li><li>复选框、单选框、下拉框等表单元素，需要通过<code>element.checked</code>、<code>element.selected</code>、<code>element.disabled</code>等属性来操作。</li><li>checked：复选框是否选中，selected：下拉框是否选中，disabled：表单元素是否禁用。</li></ul></li><li><p>自定义属性<br>这是HTML5新增的属性，可以在标签上自定义属性，比如<code>&lt;div data-id=&quot;1&quot;&gt;&lt;/div&gt;</code>，可以通过<code>element.dataset.id</code><br>获取到这个属性的值。意义是可以在标签上存储一些数据，方便js操作。<br>例子：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-id</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">dataset</span>.<span class="property">id</span>) <span class="comment">// 1</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="定时器-间歇函数"><a href="#定时器-间歇函数" class="headerlink" title="定时器-间歇函数"></a>定时器-间歇函数</h4><p>情景：比如每隔一段时间就弹出一个警告框，或者每隔一段时间就改变一下页面的颜色等，倒计时。</p><ul><li>开启定时器<ul><li><code>setInterval(callback, time)</code>：每隔一段时间执行一次回调函数</li><li><code>setTimeout(callback, time)</code>：延迟一段时间执行一次回调函数</li></ul></li><li>关闭定时器<ul><li><code>clearInterval(timer)</code>：关闭间歇函数</li><li><code>clearTimeout(timer)</code>：关闭延时函数</li></ul></li><li>例子：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>什么是事件？ 事件是浏览器或用户自身执行的某种动作，比如点击、滚动、输入等。</p><ul><li>click：点击事件</li><li>mouseover：鼠标移入事件</li><li>mouseout：鼠标移出事件</li><li>keydown：键盘按下事件</li><li>keyup：键盘抬起事件</li><li>scroll：滚动事件</li><li>change：表单元素值改变事件</li><li>focus：表单元素获取焦点事件</li><li>blur：表单元素失去焦点事件</li><li>input：表单元素输入事件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">  element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>事件监听三要素：事件源、事件类型、事件处理函数</p><h4 id="事件监听版本"><a href="#事件监听版本" class="headerlink" title="事件监听版本"></a>事件监听版本</h4><ul><li>DOM L0级事件监听：<code>element.onclick = function() &#123;&#125;</code></li><li>DOM L2级事件监听：<code>element.addEventListener(&#39;click&#39;, function() &#123;&#125;)</code></li><li>区别：DOM L0级事件监听只能绑定一个事件，DOM L2级事件监听可以绑定多个事件。</li></ul><h4 id="利用js可以调用点击事件"><a href="#利用js可以调用点击事件" class="headerlink" title="利用js可以调用点击事件"></a>利用js可以调用点击事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发点击事件</span></span><br><span class="line">  element.<span class="title function_">click</span>()</span><br></pre></td></tr></table></figure><h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><ul><li>例子：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;focus&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;focus&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;blur&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;blur&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><ul><li>例子：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;keydown&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;keyup&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="用户输入文本事件"><a href="#用户输入文本事件" class="headerlink" title="用户输入文本事件"></a>用户输入文本事件</h4><ul><li>例子：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>什么事事件对象？事件对象是浏览器自动传递给事件处理函数的一个对象，包含了事件的相关信息，比如事件源、事件类型、事件坐标等。比如点击事件，事件对象中包含了点击的坐标。</p><p>使用场景比如：可以判断用户按下的是哪个键，可以获取鼠标点击的坐标等，从而做出相应的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件对象</span></span><br><span class="line">  element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>常见的事件对象属性：</p><ul><li><code>event.target</code>：事件源，触发事件的元素</li><li><code>event.type</code>：事件类型，比如click、mouseover等</li><li><code>event.clientX</code>：鼠标点击的x坐标（<strong>相对于窗口左上角</strong>）</li><li><code>event.clientY</code>：鼠标点击的y坐标</li><li><code>event.keyCode</code>：键盘按下的键的键码（不提倡）</li><li><code>event.key</code>：键盘按下的键的键名（推荐），比如<code>a</code>、<code>b</code>、<code>Enter</code>等</li><li><code>event.offsetX</code>：鼠标点击的x坐标相对于事件源的x坐标（<strong>相对于DOM元素左上角</strong>）</li><li><code>event.offsetY</code>：鼠标点击的y坐标相对于事件源的y坐标</li></ul><h4 id="环境对象"><a href="#环境对象" class="headerlink" title="环境对象"></a>环境对象</h4><p>能够分析判断函数运行在不同环境中this的指向，比如在浏览器中，this指向window对象。代表当前运行环境。</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><ul><li>什么是回调函数？回调函数是作为参数传递给另一个函数的函数，当满足某种条件时，另一个函数会调用这个函数。</li></ul><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><h4 id="事件流与两个阶段说明"><a href="#事件流与两个阶段说明" class="headerlink" title="事件流与两个阶段说明"></a>事件流与两个阶段说明</h4><ul><li>事件流指的是事件完整执行过程中的流动路径</li><li>两个阶段：捕获 &#x2F; 冒泡</li><li>捕获阶段是从Document-&gt;ELement html-&gt;Element body-&gt;Element div，冒泡阶段是倒过来</li><li>实际工作都是使用<strong>事件冒泡</strong>为主</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DOM</span>.<span class="title function_">addEventListener</span>(事件类型,事件处理函数,是否使用捕获机制)</span><br><span class="line"><span class="comment">// true是捕获，false是冒泡，默认是false</span></span><br></pre></td></tr></table></figure><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>从DOM根元素开始去执行对应的事件</p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p><strong>当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发，这一过程被称为事件冒泡</strong></p><p>事件冒泡是默认存在的。</p><h4 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h4><p>因为默认有冒泡模式的存在，容易导致事件影响到父级元素，若想把事件限制在当前的元素内，就需要阻止事件冒泡。</p><p>组建事件冒泡需要拿到事件对象，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事件对象.<span class="title function_">stopPropagation</span>()</span><br><span class="line"><span class="comment">// 阻断事件流动传播，包括冒泡阶段和捕获阶段</span></span><br></pre></td></tr></table></figure><h4 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h4><p>传统的on事件方法，如onclick可以直接使用null覆盖就可以实现。</p><p>removeEventListener(事件类型，事件处理函数，[获取捕获或者冒泡阶段])</p><p><strong>匿名函数无法解绑</strong></p><h4 id="鼠标经过事件的区别"><a href="#鼠标经过事件的区别" class="headerlink" title="鼠标经过事件的区别"></a>鼠标经过事件的区别</h4><ol><li>mouseover和mouseout 会有冒泡效果的</li><li>mouseenter和mouseleave 没有冒泡效果 <strong>推荐</strong></li></ol><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>以前要用for循环来给多个元素注册事件，利用事件冒泡减少注册次数，提高程序性能。</p><p>给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件。</p><p>通过事件对象中的<strong>target</strong>可以找到子元素，<strong>target.tagName</strong>（大写）可以获得真正触发事件的元素</p><h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>比如，阻止链接的跳转，表单域跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件对象.<span class="title function_">preventDefault</span>()</span><br></pre></td></tr></table></figure><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><h4 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h4><ol><li><p>加载外部资源，比如图片、音频、视频等完毕后触发的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;load&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 也可以任意一个dom元素增加load事件，意思是这个元素加载完毕后触发</span></span><br></pre></td></tr></table></figure></li><li><p>当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，无需等待样式表、图像和子框架的加载完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="元素滚动事件"><a href="#元素滚动事件" class="headerlink" title="元素滚动事件"></a>元素滚动事件</h4><p>滚动条在滚动的时候持续触发的事件，应该将事件添加给window对象，因为滚动条是window对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll&#x27;</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> <span class="comment">// 滚动条距离顶部的距离</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>scrollTop：元素滚动条距离顶部的距离</li><li>scrollLeft：元素滚动条距离左边的距禿</li><li>scrollHeight：元素内容的总高度</li><li>scrollWidth：元素内容的总宽度</li></ul><blockquote><p>document.documentElement是html元素，document.body是body元素</p><p>scrollTo(x,y)：滚动到指定坐标</p><p>scroll_behavior: smooth; 平滑滚动</p></blockquote><h4 id="页面尺寸事件"><a href="#页面尺寸事件" class="headerlink" title="页面尺寸事件"></a>页面尺寸事件</h4><p>窗口尺寸改变触发事件resize</p><blockquote><p>clientWidth和clientHeight：元素可视区域的宽度，不包括滚动条、margin、border，包括padding</p><p>offsetWidth和offsetHeight：获取元素自身的设置的宽高、padding、border。可视宽高，如果隐藏，获取的是0 <strong>只读</strong></p><p>offsetLeft和offsetTop: <strong>只读</strong> 获取元素距离自己定位父级的距离</p><p>元素尺寸位置 element.getBoundingClientRect() 返回一个对象，元素的大小及其相对于<strong>视口</strong>的位置</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础语法学习</title>
      <link href="/2025/03/10/jsStudy/"/>
      <url>/2025/03/10/jsStudy/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript是什么？做什么？"><a href="#JavaScript是什么？做什么？" class="headerlink" title="JavaScript是什么？做什么？"></a>JavaScript是什么？做什么？</h2><ul><li>是一种运行在客户端（浏览器）的编程语言，实现人机交互效果。</li><li>网页特效、表单验证、数据交互。</li><li>服务端编程（Node.js）。</li><li>组成：ECMAScript（语言基础）、Web API（浏览器提供的API）（包括页面文档对象模型DOM、浏览器对象模型BOM）</li><li>DOM：操作文档，比如对页面元素进行移动、大小、添加删除等操作。</li><li>BOM：操作浏览器，比如页面弹窗，检测窗口宽度，存储数据到浏览器等。</li></ul><h2 id="JavaScript书写位置"><a href="#JavaScript书写位置" class="headerlink" title="JavaScript书写位置"></a>JavaScript书写位置</h2><ul><li>内部嵌入：在HTML文件中使用<code>&lt;script&gt;</code>标签嵌入JavaScript代码。（</body>上方）<br>原因：浏览器会按照代码在文件中的顺序加载HTML，如果先加载的JavaScript想修改下方的HTML，可能由于HTML尚未加载而失效。</li><li>外部引入：在HTML文件中使用<code>&lt;script&gt;</code>标签引入外部JavaScript文件。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--中间写内容也会被忽略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>内联：在HTML标签中使用<code>onclick</code>等事件属性。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="JavaScript结束符"><a href="#JavaScript结束符" class="headerlink" title="JavaScript结束符"></a>JavaScript结束符</h2><ul><li>JavaScript语句以分号<code>;</code>结尾，但是可以省略。风格统一，要么都加要么都不加。</li></ul><h2 id="输入、输出语法"><a href="#输入、输出语法" class="headerlink" title="输入、输出语法"></a>输入、输出语法</h2><h3 id="输出语法"><a href="#输出语法" class="headerlink" title="输出语法"></a>输出语法</h3><ul><li>第一种，向body输出内容，如果内容是标签，也会被解析成网页元素。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>第二种，页面弹出警告对话框<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>第三种，控制台输出语法，程序员调试使用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="输入语法"><a href="#输入语法" class="headerlink" title="输入语法"></a>输入语法</h3><ul><li>弹出输入对话框，用户输入的内容会被赋值给变量<code>name</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="title function_">prompt</span>(<span class="string">&quot;请输入你的名字：&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="代码执行顺序"><a href="#代码执行顺序" class="headerlink" title="代码执行顺序"></a>代码执行顺序</h2><ul><li>按HTML文档流顺序执行JavaScript代码，alert()和prompt()会跳过页面渲染先执行。</li></ul><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><ul><li>字面量是一种固定值，不可改变，比如数字、字符串、布尔值、数组、对象等。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><ul><li>变量是存储数据的容器，可以存储任何类型的数据。</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>声明变量：let、var</li><li>区别：let和const是ES6新增的，var是ES5的，let和const有块级作用域，var没有。</li><li>赋值：<code>let name = &quot;Tom&quot;;</code></li><li>更新：<code>name = &quot;Jerry&quot;;</code></li></ul><h3 id="变量的本质"><a href="#变量的本质" class="headerlink" title="变量的本质"></a>变量的本质</h3><ul><li>变量是存储在内存中的数据，变量名是对数据的引用。</li></ul><h3 id="命名规则与规范"><a href="#命名规则与规范" class="headerlink" title="命名规则与规范"></a>命名规则与规范</h3><ul><li>变量名只能包含字母、数字、下划线、美元符号，不能以数字开头。</li><li>变量名区分大小写。</li><li>变量名不能使用保留字。</li><li>变量名要有意义，驼峰命名法。</li><li>变量名不能使用中文。</li><li>变量名不能使用特殊符号。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var有一些不合理之处，比如变量提升、全局变量污染等，所以在ES6中引入了let和const。</span><br><span class="line">可以先使用再声明，重复声明，并不合理。</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>数组是一种特殊的对象，用于存储多个数据。</li><li>可以存储不同类型的数据。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>]  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>常量是一种固定值，不可改变。</li><li>声明常量：<code>const PI = 3.14;</code></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JavaScript是一种弱类型语言，变量不需要指定数据类型，可以存储任何类型的数据。</p><ul><li>number 数字</li><li>string 字符串 单引号（推荐）、双引号、反引号（模板字符串）</li><li>boolean 布尔值</li><li>null 空值</li><li>undefined 未定义 声明变量但未赋值</li><li>object 对象 <strong>引用数据类型</strong></li></ul><p><em><strong>NaN</strong></em>：Not a Number，表示不是一个数字，黏性，任何数和NaN计算都是NaN。NaN与NaN不相等。</p><p><em><strong>模版字符串</strong></em>：反引号包裹，可以换行，可以插入变量，使用<code>$&#123;&#125;</code>。</p><p><em><strong>null和undefined的区别</strong></em>:</p><ul><li>null表示空值，是一个对象，表示没有对象。</li><li>undefined表示未定义，是一个数据类型，表示未定义的值。</li><li>null &#x3D;&#x3D; undefined &#x2F;&#x2F; true</li><li>null &#x3D;&#x3D;&#x3D; undefined &#x2F;&#x2F; false</li></ul><p><em><strong>检测数据类型</strong></em>:</p><ul><li>typeof() &#x2F;&#x2F; 返回数据类型的字符串形式 </li><li>Object.prototype.toString.call() &#x2F;&#x2F; 返回对象的类型</li></ul><p><em><strong>类型转换</strong></em>:</p><ul><li>强制类型转换：Number()、String()、Boolean()、parseInt()、parseFloat()。</li><li>自动类型转换：隐式类型转换，比如字符串和数字相加，数字会转换成字符串。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>对变量进行赋值的运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">5</span>; <span class="comment">// a = a + 5</span></span><br><span class="line">a -= <span class="number">5</span>; <span class="comment">// a = a - 5</span></span><br><span class="line">a *= <span class="number">5</span>; <span class="comment">// a = a * 5</span></span><br><span class="line">a /= <span class="number">5</span>; <span class="comment">// a = a / 5</span></span><br><span class="line">a %= <span class="number">5</span>; <span class="comment">// a = a % 5</span></span><br></pre></td></tr></table></figure><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p>对一个变量进行操作的运算符。正负号、自增自减。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">a++; <span class="comment">// a = a + 1</span></span><br><span class="line">a--; <span class="comment">// a = a - 1</span></span><br></pre></td></tr></table></figure><p>前置自增自减：先加先减。<br>后置自增自减：先赋值再加减。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较两个值的大小，返回布尔值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">a &gt; b; <span class="comment">// false</span></span><br><span class="line">a &lt; b; <span class="comment">// true</span></span><br><span class="line">a &gt;= b; <span class="comment">// false</span></span><br><span class="line">a &lt;= b; <span class="comment">// true</span></span><br><span class="line">a == b; <span class="comment">// false 两个等号是比较值是否相等</span></span><br><span class="line">a != b; <span class="comment">// true</span></span><br><span class="line">a === b; <span class="comment">// false 三个等号是比较值和类型是否相等</span></span><br><span class="line">a !== b; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>; <span class="comment">// false</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>字符串比较：比较的是Unicode编码，从第一个字符开始比较，如果相等则继续比较下一个字符，直到不相等为止。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符用于连接两个或多个表达式，返回布尔值。</p><ul><li>与：&amp;&amp; 两个表达式都为真，结果为真。</li><li>或：|| 两个表达式有一个为真，结果为真。</li><li>非：! 表达式为真，结果为假。</li><li>短路逻辑：如果第一个表达式的结果可以确定整个表达式的结果，就不会执行第二个表达式。</li><li>逻辑运算符的优先级：! &gt; &amp;&amp; &gt; ||</li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><ul><li>一元运算符 &gt; 算术运算符 &gt; 比较运算符 &gt; 逻辑运算符 &gt; 赋值运算符</li><li>优先级相同的运算符，从左到右执行。</li><li>可以使用括号改变运算顺序。</li></ul><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ul><li>语句是一组指令，用于执行特定的任务。</li></ul><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><ul><li>表达式是一个值或变量或运算符的组合，可以计算出一个值。</li><li>语句是一组表达式的组合，用于执行特定的任务。</li></ul><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><p>顺序结构、分支结构、循环结构。</p><ul><li>if语句<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 条件为真执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件为假执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>if…else if…else<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 条件1为真执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 条件2为真执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件1和条件2都为假执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>switch语句<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 表达式等于值1执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 表达式等于值2执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="comment">// 表达式不等于值1和值2执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>三元运算符：<code>条件 ? 成功执行 : 失败执行</code></li></ul><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h4><ul><li>断点：在代码中设置一个断点，程序执行到断点时会暂停。</li><li>单步执行：逐行执行代码。</li><li>查看变量：查看变量的值。</li><li>查看调用栈：查看函数的调用关系。</li><li>重启：重新执行代码。</li></ul><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>三要素：变量起始值、终止条件、变量更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 条件为真执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>break: 跳出循环。</li><li>continue: 跳过本次循环。</li></ul><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 条件为真执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>无限循环是一种循环结构，没有终止条件，只能通过break跳出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环嵌套：在循环中再嵌套一个循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><ul><li>数组是一种特殊的对象，用于存储多个数据。</li><li>可以存储不同类型的数据。</li><li>数组的本质是对象，数组的索引是对象的属性名。</li><li>数组的长度是动态的，可以随时增加或删除元素。</li><li>数组的索引是从0开始的。</li><li>数组的最后一个元素的索引是数组长度减1。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> array = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">arr[<span class="number">0</span>]  <span class="comment">// 1</span></span><br><span class="line">arr[<span class="number">1</span>]  <span class="comment">// 2</span></span><br><span class="line">arr[<span class="number">2</span>]  <span class="comment">// 3</span></span><br><span class="line">arr[<span class="number">3</span>]  <span class="comment">// 4</span></span><br><span class="line">arr[<span class="number">4</span>]  <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line">arr.<span class="property">length</span>  <span class="comment">// 5</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">6</span>);  <span class="comment">// 6 这是从数组末尾添加元素 返回数组的新长度</span></span><br><span class="line">arr.<span class="title function_">pop</span>();  <span class="comment">// 5 这是从数组末尾删除元素</span></span><br><span class="line">arr.<span class="title function_">shift</span>();  <span class="comment">// 1 这是从数组开头删除元素</span></span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">0</span>);  <span class="comment">// 0 这是从数组开头添加元素 返回数组的新长度</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 2, 3 这是删除元素，第一个参数是索引，第二个参数是删除的个数</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 1, 2, 3, 2, 3, 4, 5 这是添加元素，第一个参数是索引，第二个参数是删除的个数，后面是添加的元素</span></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">arr.<span class="title function_">sort</span>();  <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line">arr.<span class="title function_">reverse</span>();  <span class="comment">// 5, 4, 3, 2, 1</span></span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数是一段可以重复使用的代码块。</li><li>函数可以接受参数，也可以返回值。</li><li>函数的本质是对象。</li><li>函数的参数是局部变量，只能在函数内部使用。</li><li>函数的返回值是函数执行的结果。<strong>默认返回undefined</strong></li><li>函数的参数可以有默认值。</li><li>函数的参数可以有不定参数。</li><li>函数的参数可以有解构赋值。</li><li>函数的参数可以有剩余参数。</li><li>如果形参和实参个数不一致，多余的实参会被忽略，缺少的实参会被赋值为undefined。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认值，如果没有传入参数，就使用默认值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a = <span class="number">0</span>, b = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>作用域：全局作用域、局部作用域、块级作用域。</li><li><em><strong>作用域链：函数的作用域是嵌套的，内部函数可以访问外部函数的变量，外部函数不能访问内部函数的变量。</strong></em></li><li><em><strong>闭包：函数嵌套函数，内部函数可以访问外部函数的变量，外部函数不能访问内部函数的变量。</strong></em><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="title function_">outer</span>();</span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li>闭包的作用：保护变量、延长变量的生命周期。</li><li>闭包的缺点：内存泄漏，变量无法被释放。</li><li>递归：函数调用自身。</li><li>尾递归：递归调用是函数的最后一步操作。</li><li>递归的缺点：占用内存，调用栈溢出。</li><li><strong>如果函数内部变量没有声明直接赋值，会自动声明为全局变量。（不推荐）</strong></li><li>在能够访问到的情况下先使用局部变量，再使用全局变量。</li></ul><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ul><li>匿名函数没有函数名，可以赋值给变量，也可以作为函数的参数。</li><li>区别：函数声明会提升，匿名函数不会提升。</li><li>避免全局污染。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h4><ul><li>立即执行函数是匿名函数的一种，定义完立即执行。</li><li>避免全局污染。</li><li><strong>必须要加分号</strong></li><li>不需要调用，自动执行。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;)();  </span><br></pre></td></tr></table></figure></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li>箭头函数是匿名函数的简写，可以省略function关键字。</li><li>箭头函数没有this，this指向的是定义时所在的对象，而不是执行时所在的对象。</li><li>箭头函数没有arguments，可以使用剩余参数代替。</li><li>箭头函数没有new.target，不能使用new调用。</li><li>箭头函数没有原型，不能作为构造函数。</li><li>箭头函数不能使用yield命令，不能用作Generator函数。</li><li>箭头函数不能使用call、apply、bind方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="逻辑中断"><a href="#逻辑中断" class="headerlink" title="逻辑中断"></a>逻辑中断</h2><ul><li>&amp;&amp; 逻辑与：都是真，返回最后一个真值；有一个假，返回第一个假值。</li><li>|| 逻辑或：有一个真，返回第一个真值；都是假，返回最后一个假值。</li></ul><h2 id="转换为Boolean型"><a href="#转换为Boolean型" class="headerlink" title="转换为Boolean型"></a>转换为Boolean型</h2><ul><li>0、NaN、null、undefined、空字符串、false转换为false，其他转换为true。</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>对象是一种复合数据类型，可以存储多个数据。</li><li>对象的本质是键值对的集合。</li><li>对象的键是字符串，值可以是任意类型的数据。</li><li>对象的键是唯一的，值可以重复。</li><li>对象的键可以是变量，值可以是变量。</li><li>无序的，不能通过索引访问。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li>对象字面量：<code>let obj = &#123;name: &quot;Tom&quot;, age: 18&#125;;</code></li><li>带有方法的对象：<code>let obj = &#123;name: &quot;Tom&quot;, age: 18, say: function() &#123;console.log(&quot;Hello&quot;)&#125;&#125;;</code></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>查：<code>obj.name</code> &#x2F; <code>obj[&quot;name&quot;]</code></li><li>改：<code>obj.name = &quot;Jerry&quot;</code></li><li>增：<code>obj.hobby=&quot;swim&quot;</code></li><li>删：<code>delete obj.hobby</code>(了解)</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li>for…in 这个是遍历对象的键<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Object.keys() 这个是遍历对象的键<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>Object.values() 这个是遍历对象的值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>Object.entries() 这个是遍历对象的键值对<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>foreach()是数组的方法，是用来遍历数组的，具体用法是：其中item是数组的元素，index是数组的索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item, index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="数学内置对象"><a href="#数学内置对象" class="headerlink" title="数学内置对象"></a>数学内置对象</h3><h4 id="内置对象是什么？"><a href="#内置对象是什么？" class="headerlink" title="内置对象是什么？"></a>内置对象是什么？</h4><ul><li>内置对象是JavaScript自带的对象，不需要引入，可以直接使用。</li><li>内置对象有很多种，比如Math、Date、RegExp等。</li><li>内置对象是全局对象的属性，可以直接使用。</li></ul><h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><ul><li>Math对象是数学内置对象，提供了很多数学方法。</li><li>Math对象的方法是静态方法，直接通过Math调用。</li><li>比如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">PI</span>  <span class="comment">// 3.141592653589793</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(-<span class="number">10</span>)  <span class="comment">// 10 绝对值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">3.1</span>)  <span class="comment">// 4 向上取整</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">3.9</span>)  <span class="comment">// 3 向下取整</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">3.5</span>)  <span class="comment">// 4 四舍五入</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment">// 5 最大值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment">// 1 最小值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// 8 2的3次方</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">9</span>)  <span class="comment">// 3 开平方</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>()  <span class="comment">// 0-1之间的随机数</span></span><br><span class="line"><span class="comment">// m和n之间的随机数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">random</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (n - m + <span class="number">1</span>) + m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他数据结构"><a href="#其他数据结构" class="headerlink" title="其他数据结构"></a>其他数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>Set是一种数据结构，类似于数组，但是成员的值是唯一的。</li><li>Set的本质是对象，不是数组。</li><li>Set的成员是无序的，不能通过索引访问。</li><li>详细用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 通过数组创建</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">6</span>); <span class="comment">// 添加元素</span></span><br><span class="line">set.<span class="title function_">delete</span>(<span class="number">6</span>); <span class="comment">// 删除元素</span></span><br><span class="line">set.<span class="title function_">has</span>(<span class="number">6</span>); <span class="comment">// 判断是否存在</span></span><br><span class="line">set.<span class="title function_">clear</span>(); <span class="comment">// 清空元素</span></span><br><span class="line">set.<span class="property">size</span>; <span class="comment">// 元素个数</span></span><br></pre></td></tr></table></figure></li><li>遍历：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>Map是一种数据结构，类似于对象，但是键可以是任意类型的数据。</li><li>Map的本质是对象，不是数组。</li><li>Map的成员是有序的，可以通过键访问。</li><li>详细用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>], [<span class="number">2</span>, <span class="string">&quot;Jerry&quot;</span>]]); <span class="comment">// 通过数组创建</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="number">1</span>); <span class="comment">// Tom 通过键获取值</span></span><br><span class="line">map.<span class="title function_">entries</span>(); <span class="comment">// 返回键值对</span></span><br><span class="line">map.<span class="title function_">keys</span>(); <span class="comment">// 返回键</span></span><br><span class="line">map.<span class="title function_">values</span>(); <span class="comment">// 返回值</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&quot;Spike&quot;</span>); <span class="comment">// 添加元素</span></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">3</span>); <span class="comment">// 删除元素</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="number">3</span>); <span class="comment">// 判断是否存在</span></span><br><span class="line">map.<span class="title function_">clear</span>(); <span class="comment">// 清空元素</span></span><br><span class="line">map.<span class="property">size</span>; <span class="comment">// 元素个数</span></span><br></pre></td></tr></table></figure></li><li>遍历：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>引用数据类型：对象、数组、函数、Set、Map等。<br>简单数据类型放在栈内存，引用数据类型在栈内存中存储地址，堆内存中存储数据。</p><p><strong>如果一个对象定义了一个叫[Symbol.iterator]的方法，那么这个对象就是一个迭代器。比如数组、字符串、Set、Map等。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript异步编程</title>
      <link href="/2025/03/03/jsasync/"/>
      <url>/2025/03/03/jsasync/</url>
      
        <content type="html"><![CDATA[<h2 id="📌-1-JavaScript-为什么需要异步？"><a href="#📌-1-JavaScript-为什么需要异步？" class="headerlink" title="📌 1. JavaScript 为什么需要异步？"></a>📌 1. JavaScript 为什么需要异步？</h2><p>JavaScript 是 单线程（Single-threaded）语言，它的执行方式是<strong>逐行执行</strong>，但有时候代码的执行可能会遇到等待：</p><ul><li>你去点咖啡（等待制作）。</li><li>你从服务器请求数据（等待网络）。</li><li>你读取一个文件（等待磁盘）。</li></ul><p>如果JavaScript只能同步执行，遇到等待时，整个程序都会卡住，无法继续执行。为了解决这个问题，JavaScript引入了<strong>异步编程</strong>。</p><h2 id="📌-2-回调函数（Callback）——-传统异步"><a href="#📌-2-回调函数（Callback）——-传统异步" class="headerlink" title="📌 2. 回调函数（Callback）—— 传统异步"></a>📌 2. 回调函数（Callback）—— 传统异步</h2><p>最原始的异步方案是回调函数（callback），即当任务完成时，调用一个函数来处理结果。</p><h3 id="💡-例子：回调函数点咖啡"><a href="#💡-例子：回调函数点咖啡" class="headerlink" title="💡 例子：回调函数点咖啡"></a>💡 例子：回调函数点咖啡</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">orderCoffee</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始制作咖啡...&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;咖啡制作完成 ☕&quot;</span>);</span><br><span class="line">        <span class="title function_">callback</span>(<span class="string">&quot;☕ 咖啡&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">orderCoffee</span>(<span class="function"><span class="params">coffee</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 你拿到了:&quot;</span>, coffee);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>📌 运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始制作咖啡...</span><br><span class="line">（<span class="number">2</span> 秒后）</span><br><span class="line">咖啡制作完成 ☕</span><br><span class="line">✅ 你拿到了: ☕ 咖啡</span><br></pre></td></tr></table></figure><h3 id="🔹-回调的缺点"><a href="#🔹-回调的缺点" class="headerlink" title="🔹 回调的缺点"></a>🔹 回调的缺点</h3><ol><li>   回调地狱（Callback Hell）：<ul><li>如果有多个步骤（如：点咖啡 → 加糖 → 加奶），代码会变得嵌套很多层，难以维护。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">orderCoffee</span>(<span class="function"><span class="params">coffee</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">addSugar</span>(coffee, <span class="function"><span class="params">sugaredCoffee</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">addMilk</span>(sugaredCoffee, <span class="function"><span class="params">finalCoffee</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 你的最终咖啡:&quot;</span>, finalCoffee);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>   可读性差，难以调试。</li></ol><h2 id="📌-3-事件循环（Event-Loop）——-JavaScript-异步的核心"><a href="#📌-3-事件循环（Event-Loop）——-JavaScript-异步的核心" class="headerlink" title="📌 3. 事件循环（Event Loop）—— JavaScript 异步的核心"></a>📌 3. 事件循环（Event Loop）—— JavaScript 异步的核心</h2><p>JavaScript 的 异步任务（如 setTimeout()、Promise、fetch）不是立即执行的，而是放入任务队列，等主线程（同步任务）完成后再执行。这就是事件循环（Event Loop）的工作方式。</p><h3 id="💡-事件循环的运作"><a href="#💡-事件循环的运作" class="headerlink" title="💡 事件循环的运作"></a>💡 事件循环的运作</h3><ol><li>   JavaScript代码会先执行同步任务（如变量声明、函数调用）。</li><li>   遇到异步任务（如 setTimeout()），它会交给浏览器（WebAPI）执行，完成后将回调函数放入任务队列。</li><li>   当主线程空闲时，事件循环（Event Loop）会把任务队列里的任务放入主线程执行。</li></ol><h3 id="💡-例子：事件循环"><a href="#💡-例子：事件循环" class="headerlink" title="💡 例子：事件循环"></a>💡 例子：事件循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1. 我先来杯咖啡&quot;</span>);  <span class="comment">// 同步任务</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3. 咖啡做好了 ☕&quot;</span>);  <span class="comment">// 异步任务</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2. 先看看手机等咖啡&quot;</span>);  <span class="comment">// 同步任务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📌 执行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 我先来杯咖啡</span><br><span class="line"><span class="number">2.</span> 先看看手机等咖啡</span><br><span class="line">（<span class="number">2</span> 秒后）</span><br><span class="line"><span class="number">3.</span> 咖啡做好了 ☕</span><br></pre></td></tr></table></figure><h2 id="📌-4-Promise——-解决回调地狱"><a href="#📌-4-Promise——-解决回调地狱" class="headerlink" title="📌 4. Promise—— 解决回调地狱"></a>📌 4. Promise—— 解决回调地狱</h2><p>Promise 是 异步任务的容器，它有三种状态：</p><ul><li>pending（等待中）</li><li>fulfilled（已完成）</li><li>rejected（已拒绝）</li></ul><h3 id="💡-例子：用-Promise-处理点咖啡"><a href="#💡-例子：用-Promise-处理点咖啡" class="headerlink" title="💡 例子：用 Promise 处理点咖啡"></a>💡 例子：用 Promise 处理点咖啡</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">orderCoffee</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始制作咖啡...&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;☕ 咖啡&quot;</span>);  <span class="comment">// 成功</span></span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">orderCoffee</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">coffee</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 你拿到了:&quot;</span>, coffee);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;❌ 失败:&quot;</span>, error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>📌 执行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始制作咖啡...</span><br><span class="line">（<span class="number">2</span> 秒后）</span><br><span class="line">✅ 你拿到了: ☕ 咖啡</span><br></pre></td></tr></table></figure><h3 id="Promise-的优势："><a href="#Promise-的优势：" class="headerlink" title="Promise 的优势："></a>Promise 的优势：</h3><ul><li>链式调用，比回调函数更清晰。</li><li>错误处理更优雅，可以用 .catch()。</li></ul><h2 id="📌-5-async-await——-最清晰的异步写法"><a href="#📌-5-async-await——-最清晰的异步写法" class="headerlink" title="📌 5. async&#x2F;await—— 最清晰的异步写法"></a>📌 5. async&#x2F;await—— 最清晰的异步写法</h2><p><strong>async&#x2F;await</strong>是Promise的语法糖，让代码更像同步代码。</p><h3 id="💡-例子：async-await-版的点咖啡"><a href="#💡-例子：async-await-版的点咖啡" class="headerlink" title="💡 例子：async&#x2F;await 版的点咖啡"></a>💡 例子：async&#x2F;await 版的点咖啡</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">orderCoffee</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始制作咖啡...&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;☕ 咖啡&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getCoffee</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我点了一杯咖啡...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> coffee = <span class="keyword">await</span> <span class="title function_">orderCoffee</span>();  <span class="comment">// 等待咖啡完成</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 我拿到了:&quot;</span>, coffee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getCoffee</span>();</span><br></pre></td></tr></table></figure><p>📌 执行顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我点了一杯咖啡...</span><br><span class="line">开始制作咖啡...</span><br><span class="line">（2 秒后）</span><br><span class="line">✅ 我拿到了: ☕ 咖啡</span><br></pre></td></tr></table></figure><p>为什么async&#x2F;await更好？</p><ul><li>代码更直观，没有 .then() 链式调用。</li><li>结构更清晰，像同步代码一样易读。</li></ul><h2 id="📌-6-Promise-all-和-Promise-race"><a href="#📌-6-Promise-all-和-Promise-race" class="headerlink" title="📌 6. Promise.all() 和 Promise.race()"></a>📌 6. Promise.all() 和 Promise.race()</h2><h3 id="🔹-Promise-all-——-并行执行"><a href="#🔹-Promise-all-——-并行执行" class="headerlink" title="🔹 Promise.all() —— 并行执行"></a>🔹 Promise.all() —— 并行执行</h3><p>如果你同时点 咖啡、蛋糕、面包，可以用 Promise.all() 并行执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> coffee = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;☕ 咖啡&quot;</span>), <span class="number">2000</span>));</span><br><span class="line"><span class="keyword">const</span> cake = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;🍰 蛋糕&quot;</span>), <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">const</span> bread = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;🥪 面包&quot;</span>), <span class="number">1500</span>));</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([coffee, cake, bread])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 早餐准备好啦:&quot;</span>, results));</span><br></pre></td></tr></table></figure><p>📌 输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">✅ 早餐准备好啦: [<span class="string">&quot;☕ 咖啡&quot;</span>, <span class="string">&quot;🍰 蛋糕&quot;</span>, <span class="string">&quot;🥪 面包&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="🔹-Promise-race-——-谁先完成返回谁"><a href="#🔹-Promise-race-——-谁先完成返回谁" class="headerlink" title="🔹 Promise.race() —— 谁先完成返回谁"></a>🔹 Promise.race() —— 谁先完成返回谁</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([coffee, cake, bread])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 最快的食物是:&quot;</span>, result));</span><br></pre></td></tr></table></figure><p>📌 输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">✅ 最快的食物是: 🥪 面包</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是一棵小树🌳</title>
      <link href="/2024/12/11/tree/"/>
      <url>/2024/12/11/tree/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的遍历（非递归）"><a href="#二叉树的遍历（非递归）" class="headerlink" title="二叉树的遍历（非递归）"></a>二叉树的遍历（非递归）</h3><ul><li><p>前序遍历<br>基本思路是把根节点入栈，然后出栈并访问，接着把右子节点入栈，最后把左子节点入栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) stack.push(node.right); <span class="comment">// 右子节点先入栈</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) stack.push(node.left);   <span class="comment">// 左子节点后入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历<br>基本思路就是从根开始把左子节点都入栈，当没有左子节点时，出栈并访问右子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;            <span class="comment">// 左子节点依次入栈</span></span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = stack.pop();               <span class="comment">// 访问栈顶节点</span></span><br><span class="line">        System.out.print(curr.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        curr = curr.right;                <span class="comment">// 转向右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历<br>后序遍历的顺序是左右根，而前序遍历的顺序是根左右，所以可以先按照根右左的顺序遍历，然后再逆序输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrderIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; output = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        output.push(node);                <span class="comment">// 根节点先入辅助栈</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) stack.push(node.left);   <span class="comment">// 左子节点入栈</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) stack.push(node.right); <span class="comment">// 右子节点入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!output.isEmpty()) &#123;</span><br><span class="line">        System.out.print(output.pop().val + <span class="string">&quot; &quot;</span>);       <span class="comment">// 按后序输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>层序遍历<br>层级遍历需要借助队列，先把根节点入队，然后出队并访问，接着把左右子节点入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.offer(node.left);  <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.offer(node.right); <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>做了一道<strong>leecode102</strong>题，也是层序遍历，但是要返回的是[[3],[9,20],[15,7]]这种把每一层的点再包在一个list中的形式。<br>这个时候就需要在每一层遍历的时候，记录下当前层的节点个数（也就是此时队列的长度），然后再遍历这个个数的节点，把他们的值加入到一个list中，最后再把这个list加入到结果中。</p><h3 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h3><p>二叉搜索树是一种特殊的二叉树，对于每个节点，其左子树上的所有节点的值都小于根节点的值，右子树上的所有节点的值都大于根节点的值。</p><p><strong>leecode98题</strong>验证二叉搜索树，我太想当然把二叉搜索树当成左孩子小于当前节点，右孩子大于当前节点了。。<br>应该是左子树的所有节点值都必须小于当前节点值，而右子树的所有节点值都必须大于当前节点值。在调用递归的时候应该判断的是左节点和右节点<strong>在一个区域low和high之间</strong>。对于左节点，应该更新他的最大值high为当前节点的值，而对于右节点，应该更新他的最小值low为当前节点的值。</p><p>还有一种办法是用中序遍历的方式。根据二叉搜索树的性质可知，二叉搜索树<strong>中序遍历</strong>得到的值构成的序列一定是升序的。所以我们可以在中序遍历的时候检查当前节点的值是否大于前一个中序遍历的节点的值即可。</p><p><strong>leecode96题</strong>不同的二叉搜索树。这道题是求1到n这n个数能组成多少种不同的二叉搜索树。这道题的思路是，对于每个节点i，以i为根节点的二叉搜索树的数量是左子树的数量乘以右子树的数量。<br>所以可以用<strong>动态规划</strong>的方法，dp[i]表示1到i这i个数能组成的不同二叉搜索树的数量。对于每个i，我们可以把1到i中的每个数都作为根节点，然后分别计算左子树和右子树的数量，然后相乘即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] G = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; G.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>动态规划的核心思想是将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。动态规划的实现通常是自底向上的，即先解决子问题，再逐步解决原问题。</p></blockquote><p><strong>leecode95题</strong>是按任意顺序返回二叉搜索树，不想做。。有时间记得看看。。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程</title>
      <link href="/2024/12/11/netprogram/"/>
      <url>/2024/12/11/netprogram/</url>
      
        <content type="html"><![CDATA[<p>无论是 Web 服务器处理网页请求、即时通讯工具的消息传递，还是在线游戏的数据同步，都离不开 Socket 的支持。Socket 的本质，是将复杂的网络通信抽象成一个简单的接口，让开发者可以通过像操作文件一样的方式实现数据的收发。这也是”Unix中万物皆文件”。本文将以 TCP Socket 编程为例，逐步拆解从服务器端到客户端的交互过程，解析系统调用的作用，建立清晰的理解框架。</p><h2 id="什么是-Socket？"><a href="#什么是-Socket？" class="headerlink" title="什么是 Socket？"></a>什么是 Socket？</h2><p>Socket 提供了一种通信的端点，就像电器与电源的插座。通过 Socket，两个设备之间可以建立通信链接。<br>程序员只需要按照 Socket 提供的接口进行操作，不需要关心底层的复杂网络协议。</p><p>Socket 的现代实现被称为 Berkeley Sockets，因为它起源于 Berkeley Unix（BSD Unix）中，是基于 Unix 操作系统设计的。Berkeley Sockets 的出现奠定了今天网络编程的基础。</p><ul><li>在Web浏览器与Web服务器通信：浏览器通过 Socket 向服务器发送 HTTP 请求，服务器通过 Socket 返回 HTTP 响应。</li><li>在即时通讯工具中传递消息：客户端通过 Socket 向服务器发送消息，服务器通过 Socket 将消息推送给其他客户端。</li><li>在在线游戏中同步数据：客户端通过 Socket 向服务器发送操作指令，服务器通过 Socket 将操作结果推送给其他客户端。</li></ul><h2 id="工作原理，怎么打电话？"><a href="#工作原理，怎么打电话？" class="headerlink" title="工作原理，怎么打电话？"></a>工作原理，怎么打电话？</h2><ul><li>首先，我们需要一个电话，也就是创建一个 Socket 对象。</li><li>如果想给朋友打电话，首先要知道朋友的电话号码。Socket 通信也是一样，需要知道对方的 IP 地址和端口号。<blockquote><p>IP类似于大楼的地址，而Socket端口号类似于房间号。即我们通过IP地址实现主机到主机的通信，通过端口号实现主机内的进程到进程的通信。</p></blockquote></li><li>打通电话后，可以开始通话。你说一句话（发送数据），对方听到并回复（接收数据）。Socket 通信也是一样，建立连接后，可以开始传输数据。</li><li>通话结束后，挂断电话。Socket通信结束后，关闭 Socket。</li></ul><h2 id="TCP与UDP，就像是打电话和写信"><a href="#TCP与UDP，就像是打电话和写信" class="headerlink" title="TCP与UDP，就像是打电话和写信"></a>TCP与UDP，就像是打电话和写信</h2><p>Socket 通信可以基于两种协议：TCP 和 UDP。TCP需要建立连接，而UDP不需要建立连接。</p><ul><li><strong>TCP（Transmission Control Protocol）</strong>：面向连接的协议，提供可靠的数据传输。TCP 保证数据的顺序和完整性，适用于要求数据准确无误的场景（网页、聊天、文件传输）。</li><li><strong>UDP（User Datagram Protocol）</strong>：面向无连接的协议，提供高效的数据传输。UDP 不保证数据的顺序和完整性，适用于实时性要求高的场景（在线游戏、直播）。</li></ul><h2 id="TCP-Socket通信模型"><a href="#TCP-Socket通信模型" class="headerlink" title="TCP Socket通信模型"></a>TCP Socket通信模型</h2><h3 id="TCP-Socket-通信模型是一种客户端-服务器模型。"><a href="#TCP-Socket-通信模型是一种客户端-服务器模型。" class="headerlink" title="TCP Socket 通信模型是一种客户端-服务器模型。"></a>TCP Socket 通信模型是一种客户端-服务器模型。</h3><ul><li><strong>服务器（Server）</strong>：被叫方（接线员）随时准备接电话。在程序中表示为一个服务器进程，而不是硬件服务器。</li><li><strong>客户端（Client）</strong>：主动拨打电话。在程序中表示为一个客户端进程。</li></ul><h3 id="双工文件描述符"><a href="#双工文件描述符" class="headerlink" title="双工文件描述符"></a>双工文件描述符</h3><p>使用TCP Socket进行通信后，客户端和服务器各自都会获得一个文件描述符，这使得网络通信就像在操作文件。<br>写操作即是发送字节给对方，而读操作就是接受对方发送的字节。</p><blockquote><p>文件描述符是操作系统中对文件的引用，是一个非负整数。在Linux系统中，文件描述符0、1、2分别对应标准输入、标准输出和标准错误。<br>每次打开一个文件或资源，操作系统都会返回一个文件描述符，用于后续对文件的操作。</p></blockquote><h3 id="TCP服务器系统调用过程"><a href="#TCP服务器系统调用过程" class="headerlink" title="TCP服务器系统调用过程"></a>TCP服务器系统调用过程</h3><p><img src="/images/linux/net_map.png" alt="模型"></p><ul><li>socket() <font color="pink" weigh="bold">–准备好电话啦☎️</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建服务器的 Socket</span></span><br><span class="line"><span class="comment">// socket() 函数创建一个 Socket，返回一个文件描述符</span></span><br><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// - AF_INET: 表示使用 IPv4,AF_INET6 表示 IPv6</span></span><br><span class="line"><span class="comment">// - SOCK_STREAM: 表示使用 TCP（流式传输）.SOCK_DGRAM 表示 UDP（数据报传输）</span></span><br><span class="line"><span class="comment">// - 0: 默认协议（通常是 TCP）</span></span><br><span class="line">server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (server_fd == <span class="number">-1</span>) &#123;               <span class="comment">// 如果返回 -1，表示创建失败</span></span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);                <span class="comment">// 打印错误信息</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);              <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置服务器地址</span></span><br><span class="line">server_addr.sin_family = AF_INET;    <span class="comment">// 地址族，AF_INET 表示 IPv4</span></span><br><span class="line">server_addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 监听所有网络接口（本机 IP）</span></span><br><span class="line">server_addr.sin_port = htons(PORT); <span class="comment">// 将端口号转换为网络字节序</span></span><br></pre></td></tr></table></figure>上述代码除了创建服务器的socket外，还对服务器地址进行了配置。配置过程的主要任务就是告诉操作系统，使用哪种地址类型，绑定到哪个IP地址和端口号。<br>而这些信息都存储在struct sockaddr_in结构体中，通过该结构体的成员变量进行配置。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;   <span class="comment">// 地址族 (AF_INET 表示 IPv4)</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;       <span class="comment">// 16 位端口号（网络字节序）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>  <span class="comment">// IPv4 地址</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];         <span class="comment">// 填充字段，保持与 struct sockaddr 大小一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在配置IP地址时用到了INADDR_ANY，它表示监听所有网络接口，即服务器将接受来自任何网络接口的连接请求。<blockquote><p>网络接口是连接设备和网络的桥梁，每个接口可以有自己的IP地址，例如有线网卡、无线网卡等。一台服务器可能有多个网络接口，一个连接到内网，一个连接到外网。所以一台服务器可能有多个IP地址。<br>INADDR_ANY表示监听所有网络接口，而INADDR_LOOPBACK表示监听本地回环接口，即只接受来自本机的连接请求。</p></blockquote></li></ul><p>在配置端口号时，使用了htons()函数将端口号转换为网络字节序。网络字节序是大端字节序，即高位字节存储在低地址，低位字节存储在高地址。</p><ul><li><p>bind() <font color="pink" weigh="bold">给电话装上号码📞</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 绑定地址到服务器的 Socket</span></span><br><span class="line"><span class="comment">// bind() 函数将服务器地址绑定到服务器 Socket</span></span><br><span class="line"><span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind&quot;</span>);                  <span class="comment">// 如果失败，打印错误信息</span></span><br><span class="line">    close(server_fd);                <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);              <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>listen() <font color="pink" weigh="bold">准备接听来电🤭</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 开始监听端口</span></span><br><span class="line"><span class="comment">// listen() 函数使服务器进入监听状态，准备接受连接</span></span><br><span class="line"><span class="comment">// 第二个参数指定连接队列的最大长度（这里为 5）</span></span><br><span class="line"><span class="keyword">if</span> (listen(server_fd, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;listen&quot;</span>);                <span class="comment">// 如果失败，打印错误信息</span></span><br><span class="line">    close(server_fd);                <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);              <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d...\n&quot;</span>, PORT);</span><br></pre></td></tr></table></figure></li><li><p>accept() <font color="pink" weigh="bold">电话接通了🤩</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 接受客户端连接</span></span><br><span class="line"><span class="comment">// accept() 函数等待客户端连接，成功后返回一个新的文件描述符（用于与客户端通信）</span></span><br><span class="line">client_fd = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line"><span class="keyword">if</span> (client_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;accept&quot;</span>);                <span class="comment">// 如果失败，打印错误信息</span></span><br><span class="line">    close(server_fd);                <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);              <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client connected!\n&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>(struct sockaddr *)&amp;client_addr的含义<br>在网络编程中，许多函数（如 bind() 和 connect()）需要传递地址参数，类型为 struct sockaddr *，而不是 struct sockaddr_in *。<br>struct sockaddr 是一个通用的地址结构，可以表示多种类型的地址（IPv4、IPv6 等）。 struct sockaddr_in 是 IPv4 专用的地址结构。<br>函数要求地址参数的类型为 struct sockaddr *，以便支持多种协议。<br>为了解决这个问题，可以使用类型转换将 struct sockaddr_in * 转换为 struct sockaddr *，这样就可以传递给函数了。</p></blockquote></li></ul><p>accept()函数会阻塞等待客户端连接，一旦有客户端连接，就会返回一个新的文件描述符，用于与客户端通信。<br>这两个文件描述符各司其职，server_fd用于监听客户端连接，而client_fd用于与客户端通信。</p><ul><li><p>read() write() <font color="pink" weigh="bold">通话中…🤔</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6. 接收客户端发送的消息</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);      <span class="comment">// 清空缓冲区</span></span><br><span class="line">read(client_fd, buffer, BUFFER_SIZE); <span class="comment">// 从客户端接收数据，存入缓冲区</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client says: %s\n&quot;</span>, buffer); <span class="comment">// 打印接收到的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 回复客户端</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *response = <span class="string">&quot;Hello from server!&quot;</span>;</span><br><span class="line">write(client_fd, response, <span class="built_in">strlen</span>(response));  <span class="comment">// 将消息发送给客户端</span></span><br></pre></td></tr></table></figure></li><li><p>close() <font color="pink" weigh="bold">挂断电话👋</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8. 关闭文件描述符</span></span><br><span class="line">close(client_fd);                    <span class="comment">// 关闭客户端文件描述符</span></span><br><span class="line">close(server_fd);                    <span class="comment">// 关闭服务器文件描述符</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="TCP客户端系统调用过程"><a href="#TCP客户端系统调用过程" class="headerlink" title="TCP客户端系统调用过程"></a>TCP客户端系统调用过程</h3><p>对于客户端呢，和TCP服务器一样，都要先准备电话，所以socket系统调用与TCP服务器是完全一致的。<br>客户端要想连接服务器，不需要限定自己的IP地址和端口号，只需要知道服务器的IP地址和端口号即可。</p><blockquote><p>IPv4的地址是32位的，通常用点分十进制表示，例如本机回送地址是”127.0.0.1”‘,如果用32位整数表示，就是0x7F000001。十进制就是127<em>256^3+0</em>256^2+0*256+1&#x3D;2130706433。<br>为了方便，我们可以使用inet_addr库函数将点分十进制的IP地址转换为网络字节序的整数。</p></blockquote><p>connect()的调用格式与bind很类似，但是connect后的文件描述符不是通过返回值获得的，而是通过参数sockfd传递的。connect成功后，通过read&#x2F;write操作文件描述符socket就可以与服务器通信了。通信结束后，<br>同样通过close()关闭文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="comment">// connect() 函数尝试连接服务器</span></span><br><span class="line"><span class="keyword">if</span> (connect(sock_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;connect&quot;</span>);            <span class="comment">// 如果失败，打印错误信息</span></span><br><span class="line">    close(sock_fd);               <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);           <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Connected to server!\n&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件项目管理课程</title>
      <link href="/2024/10/17/ManagementCourse/"/>
      <url>/2024/10/17/ManagementCourse/</url>
      
        <content type="html"><![CDATA[<h1 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h1><h2 id="（一）项目管理的定义"><a href="#（一）项目管理的定义" class="headerlink" title="（一）项目管理的定义"></a>（一）项目管理的定义</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>a temporary endeavor undertaken to create a unique product, service, or result.<br>（一个临时性的工作，为了创造一个独特的产品、服务或结果） </p><h3 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h3><ul><li>过程上，临时性的有时限性、不确定性、逐步精化</li><li>输入：特定目的    输出：推动变革创造价值</li><li>投入上，有发起人、需要资源、有经理人</li></ul><h3 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h3><p>成功的项目意味着满足三个目标：Scope goal、Time goal、Cost goal 并让发起者满意</p><h3 id="项目约束"><a href="#项目约束" class="headerlink" title="项目约束"></a>项目约束</h3><ul><li>六个约束：成本、风险、资源、质量、时间、范围（Cost, Risk, Resource, Quality, Time, Scope） </li><li>怎么平衡约束？<br><img src="/images/manage/img.png" alt="img.png"></li></ul><h3 id="项目群管理"><a href="#项目群管理" class="headerlink" title="项目群管理"></a>项目群管理</h3><ul><li>项目群：一组相互关联的项目，被协调和管理以获得更好的效益，这些效益单独管理项目无法获得</li><li>将项目合并为组，有助于管理、招聘员工、采购以及其他工作快捷化，而且要经济些。</li></ul><h3 id="项目组合管理"><a href="#项目组合管理" class="headerlink" title="项目组合管理"></a>项目组合管理</h3><ul><li>项目组合：一组项目、子项目、项目群、子项目群、以及运营工作，被协调和管理以实现一些特定的战略目标</li></ul><blockquote><p><em><strong>项目Projects、项目群Programs、项目组合Portfolios归纳</strong></em></p><p>定义上，</p><ul><li>项目：一个临时性的工作，为了创造一个独特的产品、服务或结果</li><li>项目群：一组相互关联的项目，被协调和管理以获得更好的效益</li><li>项目组合：组织将项目以及项目群合并进行管理，使其作为一个投资组合，从而促成整个企业的成功。</li></ul><p>管理上，</p><ul><li>项目管理：项目经理管理项目团队以满足项目要求目标。</li><li>项目群管理：项目群经理通过协调项目群各个组成部分的活动，确保项目效益按预期达成。</li><li>项目组合管理：组合管理者可以管理或协调组合管理、项目群或项目工作人员，从战略视角帮助组织挑选并分析项目，帮助组织做出明智的投资决策。</li></ul><p>监控上，</p><ul><li>项目监控：项目经理监督和控制生产产品、服务或成果所需的工作。</li><li>项目群监控：项目群经理监督项目群各个组成部分的进度，以确保项目群的总体目标、进度、预算和效益得到满足。</li><li>项目组合监控：组合经理监控投资组合的战略变化和聚集资源分配、绩效结果和风险。</li></ul><p>成功上，</p><ul><li>项目：成功与否取决于项目的质量、及时性、预算合规性和客户满意度</li><li>项目群：项目向组织提供其预期利益的能力，以及项目提供这些利益的效率和有效性。</li><li>项目组合：投资组合的成功</li></ul></blockquote><h3 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h3><ul><li>SPM工具集：综合工具、任务管理、缺陷跟踪、代码管理、团队协作、进度管理、文档管理、原型设计</li></ul><h2 id="（二）确定范围"><a href="#（二）确定范围" class="headerlink" title="（二）确定范围"></a>（二）确定范围</h2><h3 id="范围管理概念"><a href="#范围管理概念" class="headerlink" title="范围管理概念"></a>范围管理概念</h3><ul><li>界定和控制项目中应包括什么和不包括什么所涉及的过程，该过程确保了项目团队和干系人对项目的可交付成果以及生成这些可交付成果所进行的工作达成共识。</li></ul><h3 id="组域映射"><a href="#组域映射" class="headerlink" title="组域映射"></a>组域映射</h3><ul><li>五大过程组：启动Initiating、规划Planning、执行Executing、监控与控制Monitoring and Controlling、收尾Closing</li><li>五大过程组和范围管理知识域的映射：</li></ul><p>规划Planning上：</p><ol><li><p>规划范围管理：计划如何在整个项目的生命周期内管理范围</p><p> <strong>输入</strong>：项目章程、项目管理计划（质量管理计划、项目生命周期描述、开发方法）、事业环境因素、组织过程资产</p><p> <strong>工具与技术</strong>：专家判断、数据分析（备选方案分析）、会议</p><p> <strong>输出</strong>：范围管理计划、需求管理计划</p></li><li><p>收集需求；定义并记录产品的特点和功能，以及开发过程<br><img src="/images/manage/img_1.png" alt="/images/manage/img_1.png"></p></li><li><p>定义范围：审查范管计划等，指定和维护范管说明书<br><img src="/images/manage/img_2.png" alt="/images/manage/img_2.png"><br><img src="/images/manage/img_3.png" alt="/images/manage/img_3.png"></p></li><li><p>创建WBS： 将可交付成果分解为更细小和更易管理的部分<br><img src="/images/manage/img_4.png" alt="/images/manage/img_4.png"></p></li></ol><p>监控Monitoring and Controlling上：</p><ol><li>确认范围：可交付成果的正式验收<br><img src="/images/manage/img_5.png" alt="/images/manage/img_5.png"></li><li>控制范围： 对项目范围的变化进行控制<br><img src="/images/manage/img_6.png" alt="/images/manage/img_6.png"></li></ol><h3 id="WBS工作分解结构-Work-Breakdown-Structure"><a href="#WBS工作分解结构-Work-Breakdown-Structure" class="headerlink" title="WBS工作分解结构 Work Breakdown Structure"></a>WBS工作分解结构 Work Breakdown Structure</h3><ul><li>WBS是把项目细分为更小的、更易于管理的组成部分的一个层级结构。每向下一个层级，就是对项目工作更详细的定义。</li><li>优点：<img src="/images/manage/img_7.png" alt="/images/manage/img_7.png"><br><img src="/images/manage/img_8.png" alt="/images/manage/img_8.png"></li><li>WBS的标志、编码、组件、工作包和要素</li><li>特殊组件：项目管理（第2层级），计划管理、风险管理…（第3层级）</li><li>WBS的分解粒度（何时停止分解?）<ul><li>基于目前的分解程度，可以把这个组件分配给一个人吗？</li><li>团队能够合理估算这个组件的成本和工期吗？</li><li>团队能够确认完成本组件所需的活动和里程碑吗？</li><li>我能够有效监控与本组件有关的工作吗？</li></ul></li><li>常用编排方法：<ul><li>按主要交付成果 ： 调研总结、项目管理、软件评估、评估报表</li><li>按项目阶段 ： 图景、路线、原型、产品、上线、项目管理</li><li>按子项目 ： 桌面工具、Web网站、SaaS服务平台、项目管理</li><li>按地理位置 ： 南京、西安、杭州、沈阳</li><li>按部门 ： 软件开发1部、软件开发2部、基础软件事业部、项目管理中心</li><li>其他方法 ：综合法、使用指南、类比法、自上而下法、自下而上法、思维导图法</li></ul></li><li>样式：树形图、大纲式、表格式<br><img src="/images/manage/img_9.png" alt="/images/manage/img_9.png"></li><li>词典：WBS词典是WBS的一个附录，包含了每个WBS组件的详细描述</li><li>工具：WBS Chart Pro、VP、思维导图、办公软件（WPS、Visio、Project、Excel）</li><li>建议：一个工作单元仅出现一次、工作内容是下一级工作内容的总和、一个负责人、与实际一致、成员参与一致认同、记录词典精确描述、灵活变通</li><li>WBS是对项目工作的分解或划分，以便更好的界定、沟通和管理项目的工作范围，向干系人展示了即将开展的项目工作全景图</li><li>不是我们必须做什么也不是该怎样或何时交付，而是必须交付什么。不是活动清单、不是进度安排、而是范围工具</li><li>什么是范围？ 范围是指项目的工作内容，包括项目的产品和服务，以及项目的过程</li></ul><h2 id="（三）故事地图"><a href="#（三）故事地图" class="headerlink" title="（三）故事地图"></a>（三）故事地图</h2><h3 id="识别目标"><a href="#识别目标" class="headerlink" title="识别目标"></a>识别目标</h3><ul><li>故事地图目标<ul><li>Scrum Process Canvas入口</li><li>3个层次<ul><li>用例：高级业务目标，了解整个系统的范围，基于所识别的用例发现Epics</li><li>Epics：高级功能或广泛定义的要求，可以分解成更小的部分，称为用户故事</li><li>用户故事：简短陈述，记录了要求和所需的最终用功能。</li></ul></li></ul></li><li>绘制用例图、定义用例<br><em><strong>用例图和故事地图目标的关系？</strong></em></li><li>管理Epics–Scrum Process Canvas入口、在故事地图中添加更新Epics<ul><li>用户故事地图显示用例，Epics和用户故事之间的映射</li></ul></li></ul><h3 id="管理Backlog-Scrum-Process-Canvas入口"><a href="#管理Backlog-Scrum-Process-Canvas入口" class="headerlink" title="管理Backlog -Scrum Process Canvas入口"></a>管理Backlog -Scrum Process Canvas入口</h3><blockquote><p>backlog,在其中按照优先级列出所要实现的场景和具体功能，是一个项目的需求清单<br>每个用户故事地图代表是一个完整的用户故事，地图的核心是一条从左到右的时间线<br>时间线的上部放置最大粒度内容（可以理解为Epic）<br>时间线的下部的第一行放置二级粒度内容（可以理解为backlog item）<br>并在每一个粒度下按照从左到右的优先级进行放置<br>每个二级粒度内容的下面，自上而下放置三级粒度内容（可以理解为task）</p></blockquote><ul><li>定义：Backlog，待办事项，是Scrum团队定义用户故事来管理积压的工作，通过创建和详细说明项目的用户故事，来构建和维护产品待办事项<br>用户故事准备好了，才可以包含在sprint backlog中以供进一步开发<blockquote><p>sprint: 冲刺周期，通俗的地讲就是实现一个小目标的周期，一个sprint可以包含若干user story<br>task:由user story拆分成的具体开发任务</p></blockquote></li><li>定义适用于所有用户故事的验收标准</li><li>添加用户故事</li><li>创造其他用户故事</li><li>将用户故事安排到特定版本中</li><li>描述用户故事</li><li>定义用户故事的验收标准</li><li>定义用户故事的故事点、优先级、风险和截止日期</li><li>批准用户故事</li></ul><h3 id="发布计划-Scrum-Process-Canvas入口"><a href="#发布计划-Scrum-Process-Canvas入口" class="headerlink" title="发布计划 -Scrum Process Canvas入口"></a>发布计划 -Scrum Process Canvas入口</h3><ul><li>定义可交付成果</li><li>定义发布计划</li><li>将用户故事安排到版本中</li><li>形成用户故事地图</li></ul><blockquote><p>用户地图和WBS的区别<br>用户地图主要用于理解和描绘用户的行为、需求和情境，帮助团队更好地设计产品和服务<br>WBS用于将项目的整体目标分解为更小的、可管理的部分，以便于项目的规划、执行和控制<br>用户地图是产品设计的工具，WBS是项目管理的工具</p></blockquote><h2 id="（四）立体建模"><a href="#（四）立体建模" class="headerlink" title="（四）立体建模"></a>（四）立体建模</h2><h3 id="故事旅程地图"><a href="#故事旅程地图" class="headerlink" title="故事旅程地图"></a>故事旅程地图</h3><ul><li>接触点、客户想法和主意间的可追溯性<ul><li>它通过不同的接触点呈现客户的想法和感受，帮助企业加深对客户行为、想法和感受的理解，以做出有价值的决策</li><li>接触点是能够改变客户对产品、品牌、业务或服务的感受的交互点</li><li>客户旅程可以阐明产品策略，这些策略通常由许多相互关联的层面组成：例如行动、想法和感受等</li><li>要为这些项目建立可追溯性。可以将客户想法引用到接触点，或将客户想法引用到解决方法</li><li>数据的连接显示在旅程地图上，使我们能够更有效地识别用户问题</li></ul></li><li>以客户为中心<br><img src="/images/manage/img_10.png" alt="/images/manage/img_10.png"></li><li>创建新旅程</li><li>从旅程地图生成文档</li></ul><h3 id="UML推演"><a href="#UML推演" class="headerlink" title="UML推演"></a>UML推演</h3><ul><li>从传统模型到软件模型</li><li>4+1模型（uml为不同视图提供了标准化的表达方式） 可以视为一种组织和使用uml来全面描述软件系统架构的框架<ul><li>逻辑视图（logical view）：系统分析、设计人员  类与对象</li><li>进程视图（process view）：系统集成人员   线程、进程、并发</li><li>实现视图（implementation view）：程序员   物理代码文件和组件</li><li>部署视图（deployment view）：系统和网络工程师  软件到硬件的映射</li><li>用例视图（use case view）：最终用户   需求分析模型</li></ul></li><li>用例图与用例文档的映射：用例文档详细描述用例的具体情境、前提条件、步骤和结果<br><img src="/images/manage/img_11.png" alt="/images/manage/img_11.png"></li><li>用例文档与活动图的映射：图形化方式展示活动之间的顺序和条件，与用例文档中的详细步骤相对应<br><img src="/images/manage/img_12.png" alt="/images/manage/img_12.png"></li><li>用例文档与类图的映射：开发者识别用例所需的类和属性，确保系统设计的完整性<br><img src="/images/manage/img_13.png" alt="/images/manage/img_13.png"></li><li>基于时序图改进类图：时序图通过具体的消息传递关系，能够揭示类途中未明确的关系或行为<br><img src="/images/manage/img_14.png" alt="/images/manage/img_14.png"></li><li>基于类图改进时序图：类图提供了系统的静态结构信息，时序图则展示动态交互。通过结合类图的信息，时序图额能够更准确地反映对象之间的交互关系和对象的状态<br><img src="/images/manage/img_15.png" alt="/images/manage/img_15.png"></li><li>为何而生？ <ul><li>活动图–为理解而生 帮助开发者理解系统的工作流程</li><li>时序图–为实现而生 实现复杂对象之间的交互关系</li></ul></li><li>统一建模 时序图–可以表达更复杂的对象交互关系</li></ul><h3 id="原型推演"><a href="#原型推演" class="headerlink" title="原型推演"></a>原型推演</h3><ul><li>静态界面设计：创建界面的基本布局和元素，通常不包含交互和动态内容</li><li>Single Wireframe， Mutiple States：<br>单一线框图展示了某个界面的基本结构，多个状态则是指同一个界面的不同状态</li><li>Storyboard 故事板：<br>故事板是一种线性展示界面和交互流程的工具。通过一系列图像或框架展示用户在使用系统时的步骤和情景</li><li>Storyboard Player 故事板播放器：<br>一个工具或软件，能够动态展示故事板中的各个场景和过渡效果</li><li>Wireframe-based flow chart 基于线框的流程图：<br>结合了线框设计和流程图的特点，展示了用户在系统中的交互流程</li><li>Animate Path In action 动画路径：<br>通过动画演示对象的移动、变化和过渡</li></ul><h3 id="故事地图、uml、原型可否打通三界？"><a href="#故事地图、uml、原型可否打通三界？" class="headerlink" title="故事地图、uml、原型可否打通三界？"></a>故事地图、uml、原型可否打通三界？</h3><ul><li>故事地图是一种可视化工具，用于展示用户故事的优先级和关系。它帮助团队识别和组织产品功能，从用户的角度理解需求，并确保每个功能与用户目标的紧密联系。</li><li>UML提供了一系列标准化图形，帮助团队以结构化的方式描述系统的设计和行为。通过使用UML，开发团队可以清晰地表达系统的静态结构（如类图）和动态行为（如时序图、活动图），促进沟通和理解</li><li>原型设计通过视觉和交互的方式呈现产品的外观和功能，帮助利益相关者快速验证想法。原型可以是静态的线框图，也可以是动态的可交互模型。</li></ul><h4 id="复盘Scrum"><a href="#复盘Scrum" class="headerlink" title="复盘Scrum"></a>复盘Scrum</h4><ul><li>画布与五大过程组</li><li>规划：识别业务目标、管理Epics、管理Backlog、发布计划</li><li>细化用户故事之定义验收标准：<br>明确每个用户故事的验收标准，以确保开发的功能满足用户需求</li><li>细化用户故事之定义故事点：<br>为每个用户故事分配故事点，反映其复杂度和工作量。有助于团队在迭代中进行更准确的估算和规划</li><li>细化用户故事之编写故事剧情：<br>编写用户故事的详细描述，包括场景、角色、目标和行动。有助于团队更好地理解用户需求，确保开发的功能符合用户期望</li><li>细化用户故事之绘制时序图：<br>利用时序图展示用户故事中的交互过程，帮助团队明确不同对象之间的关系和消息传递</li><li>细化用户故事之绘制活动图：<br>利用活动图展示用户故事中的工作流程，帮助团队理解系统的操作流程和交互逻辑</li></ul><h2 id="五）功能点法"><a href="#五）功能点法" class="headerlink" title="(五）功能点法"></a>(五）功能点法</h2><h3 id="宏观过程"><a href="#宏观过程" class="headerlink" title="宏观过程"></a>宏观过程</h3><p><img src="/images/manage/img_16.png" alt="/images/manage/img_16.png"></p><h3 id="中观过程"><a href="#中观过程" class="headerlink" title="中观过程"></a>中观过程</h3><p><img src="/images/manage/img_17.png" alt="/images/manage/img_17.png"></p><h3 id="度量标准"><a href="#度量标准" class="headerlink" title="度量标准"></a>度量标准</h3><h3 id="五类方法：IFPUG、MarkII、NESMA、COSMIC、FISMA"><a href="#五类方法：IFPUG、MarkII、NESMA、COSMIC、FISMA" class="headerlink" title="五类方法：IFPUG、MarkII、NESMA、COSMIC、FISMA"></a>五类方法：IFPUG、MarkII、NESMA、COSMIC、FISMA</h3><p><img src="/images/manage/img_18.png" alt="/images/manage/img_18.png"></p><h3 id="规模评估–功能点评估"><a href="#规模评估–功能点评估" class="headerlink" title="规模评估–功能点评估"></a>规模评估–功能点评估</h3><ul><li>IFPUG微观过程</li></ul><h4 id="功能类型"><a href="#功能类型" class="headerlink" title="功能类型"></a>功能类型</h4><ul><li><em><strong>功能类型ILF</strong></em>：内部逻辑文件，是一组可由用户识别确认的、在应用系统边界内维护的、逻辑上相关的数据或控制信息。<br>ILF的主要意图是通过被测应用程序的一个或多个基本处理来保存维护数据。</li><li><em><strong>功能类型EIF</strong></em>：外部接口文件是一组可由用户识别确认的、由被测应用系统引用，但在其它应用系统边界内维护的、逻辑上相关的数据或控制信息。<br>EIF的主要意图是存放被测应用程序中的一个或多个基本处理所引用的数据。也就是说，一个应用程序的EIF必定是另一个应用系统的ILF</li><li><em><strong>功能类型EI</strong></em>：外部输入，是处理来自应用程序边界外的数据或者控制信息的一个基本处理，如用户通过增删改来维护内部逻辑文件。<br>经过处理的控制信息则可能维护一个ILF或不维护它，EI的主要意图是维护一个或多个ILF，以及通过其他处理逻辑来改变应用程序的行为。</li><li><em><strong>功能类型EO</strong></em>：外部输出，是一个向应用程序边界外提供数据或控制信息的基本处理。EO的主要意图是向用户提供经过处理逻辑加工的、除了检索数据或控制信息之外的信息或附加信息。<br>处理逻辑必须包含至少一个数学公式或计算、创建导出数据、维护一个或多个ILF，并且&#x2F;或者改变系统的行为</li><li><em><strong>功能类型EQ</strong></em>：外部查询，是应用程序向边界之外提供数据或控制信息的基本处理。主要意图是向用户展示未经处理、直接查询的一些数据或控制信息。<br>处理逻辑不包含数学公式或计算，也不产生派生的数据。处理过程中外部查询既不维护ILF，也不改变系统的行为。</li><li>EI、EO、EQ 是事务功能，ILF、EIF 是数据功能</li><li>功能类型案例<br><img src="/images/manage/img_19.png" alt="/images/manage/img_19.png"><br><img src="/images/manage/img_20.png" alt="/images/manage/img_20.png"></li><li>功能复杂程度<br><img src="/images/manage/img_21.png" alt="/images/manage/img_21.png"></li><li>未调整功能点<br><img src="/images/manage/img_22.png" alt="/images/manage/img_22.png"><br><img src="/images/manage/img_23.png" alt="/images/manage/img_23.png"></li></ul><h4 id="GSC综合系统特征"><a href="#GSC综合系统特征" class="headerlink" title="GSC综合系统特征"></a>GSC综合系统特征</h4><p><img src="/images/manage/img_24.png" alt="/images/manage/img_24.png"></p><h4 id="VAF调整系数值"><a href="#VAF调整系数值" class="headerlink" title="VAF调整系数值"></a>VAF调整系数值</h4><p><img src="/images/manage/img_25.png" alt="/images/manage/img_25.png"></p><h4 id="已调整功能点计数"><a href="#已调整功能点计数" class="headerlink" title="已调整功能点计数"></a>已调整功能点计数</h4><p><img src="/images/manage/img_26.png" alt="/images/manage/img_26.png"></p><h4 id="规模变更调整因子"><a href="#规模变更调整因子" class="headerlink" title="规模变更调整因子"></a>规模变更调整因子</h4><p><img src="/images/manage/img_27.png" alt="/images/manage/img_27.png"></p><h4 id="已调整功能点计数-1"><a href="#已调整功能点计数-1" class="headerlink" title="已调整功能点计数"></a>已调整功能点计数</h4><p><img src="/images/manage/img_28.png" alt="/images/manage/img_28.png"></p><h4 id="已调整功能点计数比较"><a href="#已调整功能点计数比较" class="headerlink" title="已调整功能点计数比较"></a>已调整功能点计数比较</h4><p><img src="/images/manage/img_29.png" alt="/images/manage/img_29.png"></p><h3 id="工作量评估–方程法"><a href="#工作量评估–方程法" class="headerlink" title="工作量评估–方程法"></a>工作量评估–方程法</h3><p><img src="/images/manage/img_30.png" alt="/images/manage/img_30.png"></p><h3 id="单价评估–行业区域人员成本评估"><a href="#单价评估–行业区域人员成本评估" class="headerlink" title="单价评估–行业区域人员成本评估"></a>单价评估–行业区域人员成本评估</h3><p><img src="/images/manage/img_31.png" alt="/images/manage/img_31.png"></p><h3 id="风险评估-质量评估–风险评估"><a href="#风险评估-质量评估–风险评估" class="headerlink" title="风险评估&#x2F;质量评估–风险评估"></a>风险评估&#x2F;质量评估–风险评估</h3><p><img src="/images/manage/img_32.png" alt="/images/manage/img_32.png"></p><h3 id="综合评估–综合评估法"><a href="#综合评估–综合评估法" class="headerlink" title="综合评估–综合评估法"></a>综合评估–综合评估法</h3><p><img src="/images/manage/img_33.png" alt="/images/manage/img_33.png"></p><h3 id="WBS"><a href="#WBS" class="headerlink" title="WBS"></a>WBS</h3><p><img src="/images/manage/img_34.png" alt="/images/manage/img_34.png"></p><h2 id="（六）过程规划"><a href="#（六）过程规划" class="headerlink" title="（六）过程规划"></a>（六）过程规划</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="若干阶段"><a href="#若干阶段" class="headerlink" title="若干阶段"></a>若干阶段</h4><ul><li>把项目分为若干阶段因为：项目作为系统的一部分运行并且包含不确定性</li><li>项目生命周期是项目阶段的集合</li><li>定义了：<ul><li>每个阶段做什么工作</li><li>什么样的可交付物和什么时候</li><li>谁参与到每个阶段</li><li>经理如何控制和批准工作</li></ul></li></ul><h4 id="三个阶段：早期阶段、中期阶段、后期阶段"><a href="#三个阶段：早期阶段、中期阶段、后期阶段" class="headerlink" title="三个阶段：早期阶段、中期阶段、后期阶段"></a>三个阶段：早期阶段、中期阶段、后期阶段</h4><p><img src="/images/manage/img_35.png" alt="/images/manage/img_35.png"></p><h4 id="四个阶段：Concept、Development、Implementation、Close-out（概念、开发、实施、收尾）"><a href="#四个阶段：Concept、Development、Implementation、Close-out（概念、开发、实施、收尾）" class="headerlink" title="四个阶段：Concept、Development、Implementation、Close-out（概念、开发、实施、收尾）"></a>四个阶段：Concept、Development、Implementation、Close-out（概念、开发、实施、收尾）</h4><p><img src="/images/manage/img_36.png" alt="/images/manage/img_36.png"></p><h4 id="五过程组：Initiating、Planning、Executing、Monitoring-and-Controlling、Closing（启动、规划、执行、监控与控制、收尾）"><a href="#五过程组：Initiating、Planning、Executing、Monitoring-and-Controlling、Closing（启动、规划、执行、监控与控制、收尾）" class="headerlink" title="五过程组：Initiating、Planning、Executing、Monitoring and Controlling、Closing（启动、规划、执行、监控与控制、收尾）"></a>五过程组：Initiating、Planning、Executing、Monitoring and Controlling、Closing（启动、规划、执行、监控与控制、收尾）</h4><ul><li>组间关联<br><img src="/images/manage/img_77.png" alt="/images/manage/img_77.png"></li><li>组外映射<br><img src="/images/manage/img_37.png" alt="/images/manage/img_37.png"></li><li>时间配比<br><img src="/images/manage/img_38.png" alt="/images/manage/img_38.png"></li><li>在规划上花费更多的时间可以减少执行时间</li></ul><h4 id="启动过程组"><a href="#启动过程组" class="headerlink" title="启动过程组"></a>启动过程组</h4><p><img src="/images/manage/img_39.png" alt="/images/manage/img_39.png"><br>包括识别和启动一个新的项目，确保为了正确的原因启动正确的项目</p><p>预启动，在正式启动项目之前，为项目奠定良好的基础</p><ul><li>确定制约因素</li><li>识别发起人</li><li>识别项目经理</li><li>开发商业论证（Business case）<br>   <img src="/images/manage/img_40.png" alt="/images/manage/img_40.png"></li><li>讨论过程结果</li><li>细分子项</li></ul><p>启动项目，让项目顺利进入正轨</p><ul><li>识别干系人（Stakeholder）<br>  <img src="/images/manage/img_41.png" alt="/images/manage/img_41.png"></li><li>起草项目章程（Project Charter）<br>  项目经理起草 -&gt; 团队成员内审 -&gt; 发起人&#x2F;高级经理审核 -&gt; 内签<br>  <img src="/images/manage/img_42.png" alt="/images/manage/img_42.png"></li><li>召开启动会议<br>  <img src="/images/manage/img_43.png" alt="/images/manage/img_43.png"></li></ul><h4 id="规划过程组"><a href="#规划过程组" class="headerlink" title="规划过程组"></a>规划过程组</h4><p>规划项目，指导项目的执行</p><ul><li>团队协议<br>  <img src="/images/manage/img_44.png" alt="/images/manage/img_44.png"><br>  <img src="/images/manage/img_45.png" alt="/images/manage/img_45.png"></li><li>工作范围说明书<br>  <img src="/images/manage/img_46.png" alt="/images/manage/img_46.png"></li><li>工作分解结构<br>  <img src="/images/manage/img_47.png" alt="/images/manage/img_47.png"></li><li>项目时间表<br>  <img src="/images/manage/img_48.png" alt="/images/manage/img_48.png"></li><li>风险排序清单<br>  <img src="/images/manage/img_49.png" alt="/images/manage/img_49.png"></li><li>…</li></ul><h4 id="执行过程组"><a href="#执行过程组" class="headerlink" title="执行过程组"></a>执行过程组</h4><p>项目执行，采取必要的行动以确保完成项目计划中的活动</p><ul><li>指导&#x2F;管理项目<br>  <img src="/images/manage/img_50.png" alt="/images/manage/img_50.png"></li><li>执行质量保证</li><li>获取项目团队</li><li>建设项目团队</li><li>管理项目团队</li><li>管理沟通</li><li>实施采购</li><li>管理干系人参与</li></ul><h4 id="监控过程组"><a href="#监控过程组" class="headerlink" title="监控过程组"></a>监控过程组</h4><p>项目监控，针对项目目标来衡量进展情况、监测计划的偏离状况、采取正确的行动符合计划的进展</p><ul><li>监控项目工作<br>  <img src="/images/manage/img_51.png" alt="/images/manage/img_51.png"></li><li>整体变更控制</li><li>范围核实</li><li>进度控制</li><li>成本控制</li><li>质量控制</li><li>沟通控制</li><li>风险控制</li><li>采购控制</li><li>干系人控制</li></ul><h4 id="收尾过程组"><a href="#收尾过程组" class="headerlink" title="收尾过程组"></a>收尾过程组</h4><p>收尾过程，包括获得干系人和客户对于最终产品和服务的<em><strong>验收</strong></em>，同时使得项目或者项目阶段实现<em><strong>有序的结束</strong></em></p><p>核实成果+交付成果+最终陈述+经验教训</p><ul><li>项目&#x2F;阶段收尾<br>  <img src="/images/manage/img_52.png" alt="/images/manage/img_52.png"><br>  <img src="/images/manage/img_53.png" alt="/images/manage/img_53.png"></li><li>采购终止<br>小结：<br><img src="/images/manage/img_54.png" alt="/images/manage/img_54.png"></li></ul><h3 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h3><h4 id="若干模型"><a href="#若干模型" class="headerlink" title="若干模型"></a>若干模型</h4><p><img src="/images/manage/img_55.png" alt="/images/manage/img_55.png"></p><h4 id="三层五类"><a href="#三层五类" class="headerlink" title="三层五类"></a>三层五类</h4><p><img src="/images/manage/img_56.png" alt="/images/manage/img_56.png"></p><h5 id="传统模型"><a href="#传统模型" class="headerlink" title="传统模型"></a>传统模型</h5><p>特征：</p><ul><li>低复杂性</li><li>范围变更请求很少</li><li>很好理解的技术架构</li><li>低风险</li><li>有经验、有能力的开发团队</li><li>计划驱动的TPM项目</li></ul><h5 id="线性-Linear"><a href="#线性-Linear" class="headerlink" title="线性 Linear"></a>线性 Linear</h5><p><img src="/images/manage/img_57.png" alt="/images/manage/img_57.png"><br><img src="/images/manage/img_58.png" alt="/images/manage/img_58.png"><br><img src="/images/manage/img_59.png" alt="/images/manage/img_59.png"></p><ul><li>优点：<ul><li>开始时就进行了进度安排</li><li>开始时资源已知</li><li>不需要最熟练的项目团队</li><li>不需要同地协作</li></ul></li><li>缺点：<ul><li>不适应变更</li><li>成本过高</li><li>耗时过长</li><li>要求有完整和细致的计划</li><li>严格的过程组线性顺序</li><li>不关注客户价值</li></ul></li></ul><h5 id="增量-Incremental"><a href="#增量-Incremental" class="headerlink" title="增量 Incremental"></a>增量 Incremental</h5><p><img src="/images/manage/img_60.png" alt="/images/manage/img_60.png"><br><img src="/images/manage/img_61.png" alt="/images/manage/img_61.png"></p><ul><li>优点：<ul><li>更早地产生商业价值</li><li>更好地安排稀缺资源</li><li>适应小变更</li><li>有产品改良机会</li><li>比线性更关注客户价值</li></ul></li><li>缺点：<ul><li>团队人员不稳定</li><li>增量之间的交接文档</li><li>增量优先级必须考虑依赖性</li><li>更需要客户参与</li><li>比线性模型更长的时间</li><li>功能分隔可能成为问题</li></ul></li></ul><h4 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h4><p>特征：</p><ul><li>没有已知的解决方案</li><li>预计会有新的商业机会</li><li>变化驱动的APM项目</li><li>对组织化解风险非常关键</li><li>客户的有效参与是绝对必要</li><li>使用小型同地协作团队</li></ul><h5 id="重型RUP"><a href="#重型RUP" class="headerlink" title="重型RUP"></a>重型RUP</h5><p><img src="/images/manage/img_62.png" alt="/images/manage/img_62.png"></p><h5 id="轻型SCRUM"><a href="#轻型SCRUM" class="headerlink" title="轻型SCRUM"></a>轻型SCRUM</h5><p><img src="/images/manage/img_63.png" alt="/images/manage/img_63.png"></p><ul><li>优点：<ul><li>可变更范围</li><li>适应变化随变而调即时规划</li><li>关注形成商业价值</li><li>客户可评审部分解决方案</li></ul></li><li>缺点：<ul><li>团队人员不稳定</li><li>同地协作的团队</li><li>资源需求不清晰</li><li>更高的客户参与度</li><li>不确定的最终解决方案</li></ul></li></ul><h4 id="极限模型"><a href="#极限模型" class="headerlink" title="极限模型"></a>极限模型</h4><p>特征：</p><ul><li>xPM是一种研发项目</li><li>xPM项目的风险很高</li><li>优点：<ul><li>备选方案保持时间长</li><li>能提供大量部分解决方案供早期参考</li></ul></li><li>缺点<ul><li>可能在所有错误的地方寻找解决方案</li><li>不能保证项目交付结果具有商业价值</li></ul></li></ul><h4 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h4><p>相同点：</p><ul><li>都有5个过程组</li><li>都开始于范围&#x2F;启动过程组</li><li>都结束于收尾过程组<br>不同点：</li><li>越来越高的不确定性</li><li>越来越重要的风险管理</li><li>越来越需要客户有效参与</li><li>趋向生命周期的开端</li><li>完整的项目计划被即时项目计划取代<br>  <img src="/images/manage/img_64.png" alt="/images/manage/img_64.png"></li></ul><h3 id="最适之选"><a href="#最适之选" class="headerlink" title="最适之选"></a>最适之选</h3><p><img src="/images/manage/img_65.png" alt="/images/manage/img_65.png"></p><h2 id="（七）敏捷方法"><a href="#（七）敏捷方法" class="headerlink" title="（七）敏捷方法"></a>（七）敏捷方法</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p><img src="/images/manage/img_66.png" alt="/images/manage/img_66.png"></p><h3 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h3><p><img src="/images/manage/img_67.png" alt="/images/manage/img_67.png"></p><ul><li>个体和互动高于流程和工具</li><li>工作的软件高于详尽的文档</li><li>客户合作高于合同谈判</li><li>响应变化高于遵循计划</li></ul><h3 id="敏捷原则"><a href="#敏捷原则" class="headerlink" title="敏捷原则"></a>敏捷原则</h3><p><img src="/images/manage/img_68.png" alt="/images/manage/img_68.png"><br><img src="/images/manage/img_69.png" alt="/images/manage/img_69.png"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>三用<ul><li>需求不确定</li><li>设计不确定</li><li>计划不确定</li></ul></li><li>三不用<ul><li>产品高要求</li><li>团队有问题</li><li>需求负反馈</li></ul></li></ul><h3 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h3><p><img src="/images/manage/img_70.png" alt="/images/manage/img_70.png"></p><h3 id="RUP"><a href="#RUP" class="headerlink" title="RUP"></a>RUP</h3><p><img src="/images/manage/img_71.png" alt="/images/manage/img_71.png"></p><h3 id="RUP迭代"><a href="#RUP迭代" class="headerlink" title="RUP迭代"></a>RUP迭代</h3><p><img src="/images/manage/img_72.png" alt="/images/manage/img_72.png"></p><h3 id="RUP阶段工作量和进度"><a href="#RUP阶段工作量和进度" class="headerlink" title="RUP阶段工作量和进度"></a>RUP阶段工作量和进度</h3><p><img src="/images/manage/img_73.png" alt="/images/manage/img_73.png"></p><h3 id="OpenUP"><a href="#OpenUP" class="headerlink" title="OpenUP"></a>OpenUP</h3><p><img src="/images/manage/img_74.png" alt="/images/manage/img_74.png"></p><h3 id="Kanban"><a href="#Kanban" class="headerlink" title="Kanban"></a>Kanban</h3><p><img src="/images/manage/img_75.png" alt="/images/manage/img_75.png"><br><img src="/images/manage/img_76.png" alt="/images/manage/img_76.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软件项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Avalonia 全栈开发课程</title>
      <link href="/2024/10/09/avalonia/"/>
      <url>/2024/10/09/avalonia/</url>
      
        <content type="html"><![CDATA[<h1 id="读写数据库"><a href="#读写数据库" class="headerlink" title="读写数据库"></a>读写数据库</h1><p>如何在Avalonia中建立数据库连接，如何在数据库中插入数据</p><ul><li>Mvvm设计模式：Model、ViewModel、View 客户端开发的一种设计模式（MVC是服务端开发的设计模式）</li></ul><h2 id="从Model开始，添加新类作为模型类"><a href="#从Model开始，添加新类作为模型类" class="headerlink" title="从Model开始，添加新类作为模型类"></a>从Model开始，添加新类作为模型类</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Poetry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="built_in">string</span>.Empty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="service层，添加新类作为服务类-接口IPoetryStorage，实现类PoetryStorage"><a href="#service层，添加新类作为服务类-接口IPoetryStorage，实现类PoetryStorage" class="headerlink" title="service层，添加新类作为服务类 接口IPoetryStorage，实现类PoetryStorage"></a>service层，添加新类作为服务类 接口IPoetryStorage，实现类PoetryStorage</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPoetryStorage</span> &#123;</span><br><span class="line">    <span class="function">Task <span class="title">InsertAsync</span>(<span class="params">Poetry poetry</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个异步操作，函数名以Async结尾，返回值是Task，参数是Poetry类型的对象<br><strong>异步操作：不会阻塞当前线程，而是在另一个线程上执行，执行完毕后会通知当前线程</strong></p><p>什么时候用异步操作？ 当操作比较耗时的时候，比如读写文件、读写数据库、网络请求</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PoetryStorage</span> : <span class="title">IPoetryStorage</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InsertAsync</span>(<span class="params">Poetry poetry</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>.NET代码优先，code first，怎么把数据库表建起来？ 根据模型类建立数据库表</li><li>运行在服务器，数据库在服务器上，但是我们的代码运行在用户的本机上，怎么让我们的代码和数据库建立连接？</li></ul><h2 id="嵌入式数据库，SQLite-行业标准-程序的一部分，不需要安装，不需要配置，不需要启动"><a href="#嵌入式数据库，SQLite-行业标准-程序的一部分，不需要安装，不需要配置，不需要启动" class="headerlink" title="嵌入式数据库，SQLite 行业标准 程序的一部分，不需要安装，不需要配置，不需要启动"></a>嵌入式数据库，SQLite 行业标准 程序的一部分，不需要安装，不需要配置，不需要启动</h2><ul><li>通过NuGet安装<em><strong>sqlite-net-pcl</strong></em></li><li>确定数据库怎么找，先确定数据库的文件名，在PoetryStorage类中添加一个常量<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> DbName = <span class="string">&quot;poetrydb.sqlite3&quot;</span>;</span><br></pre></td></tr></table></figure></li><li>重点问题：放在哪？放在哪个目录下？ 放用户总目录下，有一个位置专门存放应用程序</li></ul><h2 id="新建Helpers文件夹，添加一个新类PathHelper"><a href="#新建Helpers文件夹，添加一个新类PathHelper" class="headerlink" title="新建Helpers文件夹，添加一个新类PathHelper"></a>新建Helpers文件夹，添加一个新类PathHelper</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PathHelper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> _localFolder = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒初始化，只有在需要的时候才初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> LocalFolder &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(_localFolder)) &#123;</span><br><span class="line">                <span class="keyword">return</span> _localFolder;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 专门存放应用程序的位置</span></span><br><span class="line">            _localFolder =</span><br><span class="line">                Path.Combine(</span><br><span class="line">                    Environment.GetFolderPath(Environment.SpecialFolder</span><br><span class="line">                        .LocalApplicationData), <span class="keyword">nameof</span>(Mvvm)); <span class="comment">// 获取物理路径</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// nameof(Mvvm)获取Mvvm的字符串名称</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(_localFolder)) &#123;</span><br><span class="line">                Directory.CreateDirectory(_localFolder);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _localFolder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定一个文件名，返回文件的完整路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetLocalFilePath</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Path.Combine(LocalFolder, fileName);  <span class="comment">// 拼接路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回到PoetryStorage类，可以获取数据库文件的完整路径"><a href="#回到PoetryStorage类，可以获取数据库文件的完整路径" class="headerlink" title="回到PoetryStorage类，可以获取数据库文件的完整路径"></a>回到PoetryStorage类，可以获取数据库文件的完整路径</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> PoetryDbPath =</span><br><span class="line">    PathHelper.GetLocalFilePath(DbName);</span><br></pre></td></tr></table></figure><ul><li>public const string 和 public static readonly string 的区别？ <ul><li>public const string 是常量，编译时就确定了值，不能修改</li><li>public static readonly string 是只读的，运行时确定值，可以修改</li></ul></li></ul><h2 id="建立数据库连接"><a href="#建立数据库连接" class="headerlink" title="建立数据库连接"></a>建立数据库连接</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SQLiteAsyncConnection _connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SQLiteAsyncConnection Connection =&gt;</span><br><span class="line">    _connection ??= <span class="keyword">new</span> SQLiteAsyncConnection(PoetryDbPath);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>??&#x3D; 是什么意思？ 空合并运算符，左边的值为空时，才会计算右边的值</li></ul><h2 id="建立数据库表"><a href="#建立数据库表" class="headerlink" title="建立数据库表"></a>建立数据库表</h2><ul><li>现在IPoetryStorage接口中添加一个新方法<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">InitializeAsync</span>()</span>;</span><br></pre></td></tr></table></figure></li><li>在PoetryStorage类中实现这个方法,根据模型类建立数据库表，不用写SQL语句<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InitializeAsync</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> Connection.CreateTableAsync&lt;Poetry&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="初探MVVM"><a href="#初探MVVM" class="headerlink" title="初探MVVM"></a>初探MVVM</h1><p>通过像数据库中插入数据，来学习MVVM设计模式，Avolonia是如何把UI连起来的</p><h2 id="实现插入诗词的功能，在PoetryStorage类中实现InsertAsync方法-（Service层）"><a href="#实现插入诗词的功能，在PoetryStorage类中实现InsertAsync方法-（Service层）" class="headerlink" title="实现插入诗词的功能，在PoetryStorage类中实现InsertAsync方法 （Service层）"></a>实现插入诗词的功能，在PoetryStorage类中实现InsertAsync方法 （Service层）</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InsertAsync</span>(<span class="params">Poetry poetry</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> Connection.InsertAsync(poetry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>软件是分层的，每一层都有自己的职责，UI层（View）只负责显示，业务逻辑层（ViewModel）负责业务逻辑，Service层负责数据存取，Model层负责数据结构</li></ul><h2 id="向上一层，添加一个新类PoetryViewModel"><a href="#向上一层，添加一个新类PoetryViewModel" class="headerlink" title="向上一层，添加一个新类PoetryViewModel"></a>向上一层，添加一个新类PoetryViewModel</h2><p>ViewModel中的属性，是UI中的数据源，UI中的控件绑定到ViewModel中的属性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindowViewModel</span> : <span class="title">ViewModelBase</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IPoetryStorage _poetryStorage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为什么一定用接口？ </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用构造方法的方式注入依赖</span></span><br><span class="line">    <span class="comment">// new一个MainWindowViewModel对象时，必须传入一个IPoetryStorage类型的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindowViewModel</span>(<span class="params">IPoetryStorage poetryStorage</span>)</span> &#123;</span><br><span class="line">        _poetryStorage = poetryStorage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Message &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _message;</span><br><span class="line">        <span class="keyword">set</span> =&gt; SetProperty(<span class="keyword">ref</span> _message, <span class="keyword">value</span>);</span><br><span class="line">        <span class="comment">// ref 引用传递，传递的是变量的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span> &#123;</span><br><span class="line">       Message = <span class="string">&quot;Hello, Avalonia!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 谁来调用SayHello方法？ 由UI层调用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本CURD"><a href="#基本CURD" class="headerlink" title="基本CURD"></a>基本CURD</h1><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><h1 id="Mock2"><a href="#Mock2" class="headerlink" title="Mock2"></a>Mock2</h1><h1 id="Behaviors"><a href="#Behaviors" class="headerlink" title="Behaviors"></a>Behaviors</h1><h1 id="无限滚动及其原理"><a href="#无限滚动及其原理" class="headerlink" title="无限滚动及其原理"></a>无限滚动及其原理</h1><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><h1 id="访问Json-Web服务"><a href="#访问Json-Web服务" class="headerlink" title="访问Json Web服务"></a>访问Json Web服务</h1><h1 id="MVVM-IService架构"><a href="#MVVM-IService架构" class="headerlink" title="MVVM + IService架构"></a>MVVM + IService架构</h1><h1 id="导航的原理"><a href="#导航的原理" class="headerlink" title="导航的原理"></a>导航的原理</h1><p>Avalonia.Samples-main\src\Avalonia.Samples\Routing\BasicViewLocatorSample</p><h2 id="从导航的按钮出发-MainWindow-axaml"><a href="#从导航的按钮出发-MainWindow-axaml" class="headerlink" title="从导航的按钮出发  MainWindow.axaml"></a>从导航的按钮出发  MainWindow.axaml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Command=&quot;&#123;Binding NavigateNextCommand&#125;&quot; Content=&quot;Next&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="NavigateNextCommand是什么？"><a href="#NavigateNextCommand是什么？" class="headerlink" title="NavigateNextCommand是什么？"></a>NavigateNextCommand是什么？</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NavigateNextCommand = ReactiveCommand.Create(NavigateNext, canNavNext);</span><br></pre></td></tr></table></figure><h2 id="NavigateNext是什么？"><a href="#NavigateNext是什么？" class="headerlink" title="NavigateNext是什么？"></a>NavigateNext是什么？</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NavigateNext</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// get the current index and add 1</span></span><br><span class="line">  <span class="keyword">var</span> index = Pages.IndexOf(CurrentPage) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  /!\ Be aware that we have no check if the index is valid. You may want to add it on your own. /!\</span></span><br><span class="line">  CurrentPage = Pages[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pages和CurrentPage是什么？"><a href="#Pages和CurrentPage是什么？" class="headerlink" title="Pages和CurrentPage是什么？"></a>Pages和CurrentPage是什么？</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PageViewModelBase CurrentPage</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; <span class="keyword">return</span> _CurrentPage; &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">set</span> &#123; <span class="keyword">this</span>.RaiseAndSetIfChanged(<span class="keyword">ref</span> _CurrentPage, <span class="keyword">value</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CurrentPage是PageViewModelBase类型的对象，继承于ViewModelBase，也就是说CurrentPage是一个ViewModel<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A read.only array of possible pages</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> PageViewModelBase[] Pages = </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">new</span> FirstPageViewModel(),</span><br><span class="line">            <span class="keyword">new</span> SecondPageViewModel(),</span><br><span class="line">            <span class="keyword">new</span> ThirdPageViewModel()</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></li><li>Pages是一个数组，数组中的元素是PageViewModelBase类型的对象，也就是说Pages是一个ViewModel数组</li><li><em><strong>怎么做到把ViewModel一改变，View就跟着改变？</strong></em></li></ul><h2 id="在MainWindow-axaml中，有一个TransitioningContentControl控件，但只是用来呈现内容的，不是用来导航的"><a href="#在MainWindow-axaml中，有一个TransitioningContentControl控件，但只是用来呈现内容的，不是用来导航的" class="headerlink" title="在MainWindow.axaml中，有一个TransitioningContentControl控件，但只是用来呈现内容的，不是用来导航的"></a>在MainWindow.axaml中，有一个TransitioningContentControl控件，但只是用来呈现内容的，不是用来导航的</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TransitioningContentControl Content=&quot;&#123;Binding CurrentPage&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="有一个抽象的机制ViewLocater"><a href="#有一个抽象的机制ViewLocater" class="headerlink" title="有一个抽象的机制ViewLocater"></a>有一个抽象的机制ViewLocater</h2><p>这里有一个函数Match，每次对按钮赋值Content的时候，都会调用这个函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Match</span>(<span class="params"><span class="built_in">object</span>? data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> data <span class="keyword">is</span> ViewModelBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>打了三次断点：Back、Next、FirstPageViewModel</li><li>这个函数用来判断当前的ViewModel是否匹配，如果匹配就返回true，否则返回false</li><li>返回true之后跳到了上面的方法Build</li><li>也就是说只有content的赋值为ViewModelBase子类的时候，才会调用Build方法<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = data.GetType().FullName!.Replace(<span class="string">&quot;ViewModel&quot;</span>, <span class="string">&quot;View&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>通过ViewModel的类型，找到对应的View的类型</li><li>通过反射，找到View的类型，然后实例化View<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = Type.GetType(name);</span><br><span class="line"><span class="keyword">if</span> (type != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Control)Activator.CreateInstance(type)!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>返回一个View的实例给了MainWindow.axaml中的TransitioningContentControl控件的Content</li></ul>]]></content>
      
      
      <categories>
          
          <category> Avolonia </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Avolonia </tag>
            
            <tag> 全栈开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot注册</title>
      <link href="/2024/09/28/springboot-register/"/>
      <url>/2024/09/28/springboot-register/</url>
      
        <content type="html"><![CDATA[<h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><ul><li>请求参数有两个：username和password，分别表示用户名和密码。请求参数是通过URL传递的，如&#96;&#x2F;login?username&#x3D;admin&amp;password&#x3D;123456</li><li>响应数据： code（相应码，0表示成功，1表示失败）、message（响应消息）、data（响应数据）。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;登录成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>定义一个有如上三个成员变量的result类，用于封装响应数据，spring自动将其转换为json格式返回给前端。</li></ul><h2 id="Result-java"><a href="#Result-java" class="headerlink" title="Result.java"></a>Result.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; Result&lt;E&gt; <span class="title function_">success</span><span class="params">(E data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">0</span>, <span class="string">&quot;success&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; Result&lt;E&gt; <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">0</span>, <span class="string">&quot;操作成功&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; Result&lt;E&gt; <span class="title function_">fail</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">1</span>, message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="User-java"><a href="#User-java" class="headerlink" title="User.java"></a>User.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line">    <span class="keyword">public</span> Timestamp createTime;</span><br><span class="line">    <span class="keyword">public</span> Timestamp updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UserMapper-java"><a href="#UserMapper-java" class="headerlink" title="UserMapper.java"></a>UserMapper.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username = #&#123;username&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user (username, password) values (#&#123;username&#125;, #&#123;password&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String username, String encode)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UserService-java"><a href="#UserService-java" class="headerlink" title="UserService.java"></a>UserService.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserMapper userMapper, PasswordEncoder passwordEncoder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">        <span class="built_in">this</span>.passwordEncoder = passwordEncoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//要进行加密处理，不能明文存储</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> passwordEncoder.encode(password);</span><br><span class="line">        userMapper.add(username, encode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UserController-java"><a href="#UserController-java" class="headerlink" title="UserController.java"></a>UserController.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//查询用户是否被占用</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> userService.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span>(u != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="number">1</span>, <span class="string">&quot;用户名已被占用&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            userService.register(username, password);</span><br><span class="line">            <span class="keyword">return</span> Result.success();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由于密码不能明文存储，所以要进行加密处理，这里使用Spring-Security提供的PasswordEncoder接口来进行加密处理。"><a href="#由于密码不能明文存储，所以要进行加密处理，这里使用Spring-Security提供的PasswordEncoder接口来进行加密处理。" class="headerlink" title="由于密码不能明文存储，所以要进行加密处理，这里使用Spring Security提供的PasswordEncoder接口来进行加密处理。"></a>由于密码不能明文存储，所以要进行加密处理，这里使用Spring Security提供的PasswordEncoder接口来进行加密处理。</h2><p>在config包下创建一个SecurityConfig类，用于配置Spring Security。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> register </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis</title>
      <link href="/2024/09/28/mybatis/"/>
      <url>/2024/09/28/mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot整合mybatis"><a href="#springboot整合mybatis" class="headerlink" title="springboot整合mybatis"></a>springboot整合mybatis</h1><h2 id="model类-Liujinhe-java"><a href="#model类-Liujinhe-java" class="headerlink" title="model类 Liujinhe.java"></a>model类 Liujinhe.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetos.neu.demooo.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiuJinHe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String usage;</span><br><span class="line">    <span class="keyword">private</span> Timestamp createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建表-Liujinhe"><a href="#建表-Liujinhe" class="headerlink" title="建表 Liujinhe"></a>建表 Liujinhe</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS mydb DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br><span class="line">USE mydb;</span><br><span class="line">CREATE TABLE LiuJinHe (</span><br><span class="line">                          id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">                          name VARCHAR(255) NOT NULL,</span><br><span class="line">                          age INT NOT NULL,</span><br><span class="line">                          `usage` VARCHAR(255) NOT NULL,</span><br><span class="line">                          create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO LiuJinHe (name, age, `usage`, category_id) VALUES</span><br><span class="line">                                                         (&#x27;光速小飞侠&#x27;, 25, &#x27;能够瞬间解读任意文学作品的潜台词，适合文学研讨会使用&#x27;, 1),</span><br><span class="line">                                                         (&#x27;乐器魔术师&#x27;, 30, &#x27;擅长通过各种乐器演奏曲子，可以演奏从古典到流行的任何风格&#x27;, 2),</span><br><span class="line">                                                         (&#x27;天空涂鸦家&#x27;, 22, &#x27;能够在高空中创作巨型壁画，适合公共艺术项目&#x27;, 3),</span><br><span class="line">                                                         (&#x27;音符猎人&#x27;, 27, &#x27;专门用于捕捉自然界中的声音，适合音乐创作和音效设计&#x27;, 4),</span><br><span class="line">                                                         (&#x27;全能修理工&#x27;, 35, &#x27;能够修复从古董手表到飞行器的任何设备，适合工匠和收藏家使用&#x27;, 1),</span><br><span class="line">                                                         (&#x27;代码舞者&#x27;, 28, &#x27;可以编写自动生成艺术作品的代码，适合数字艺术创作&#x27;, 2),</span><br><span class="line">                                                         (&#x27;故事编织者&#x27;, 24, &#x27;可以编写复杂的多线叙事小说，适合文学创作者&#x27;, 3),</span><br><span class="line">                                                         (&#x27;光影雕塑家&#x27;, 29, &#x27;通过操控光线与阴影来创造动态雕塑，适合现代艺术展览&#x27;, 4),</span><br><span class="line">                                                         (&#x27;时间旅行者&#x27;, 26, &#x27;能够为历史研究者再现真实历史场景，适合考古学和历史学领域&#x27;, 5),</span><br><span class="line">                                                         (&#x27;梦境探险家&#x27;, 31, &#x27;能够进入并探索他人的梦境，适合心理学研究和艺术创作&#x27;, 5),</span><br><span class="line">                                                         (&#x27;百科全书人&#x27;, 40, &#x27;能够瞬间回答任何学术问题，适合大学和科研机构&#x27;, 1),</span><br><span class="line">                                                         (&#x27;色彩音符&#x27;, 23, &#x27;可以根据音符自动生成相应的色彩搭配，适合设计师使用&#x27;, 4),</span><br><span class="line">                                                         (&#x27;言语雕刻家&#x27;, 34, &#x27;通过文字精确雕刻情感，适合诗人和作家使用&#x27;, 3),</span><br><span class="line">                                                         (&#x27;旋律造梦者&#x27;, 28, &#x27;可以在睡眠中创作出梦幻般的旋律，适合音乐制作人&#x27;, 2),</span><br><span class="line">                                                         (&#x27;机械灵魂&#x27;, 35, &#x27;能将机械赋予灵魂，适合机械装置艺术和工业设计&#x27;, 1),</span><br></pre></td></tr></table></figure><h2 id="LiujinheMapper"><a href="#LiujinheMapper" class="headerlink" title="LiujinheMapper"></a>LiujinheMapper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetos.neu.demooo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.model.LiuJinHe;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LiuJinHeMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from mydb.LiuJinHe where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LiuJinHe <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="liujinheService"><a href="#liujinheService" class="headerlink" title="liujinheService"></a>liujinheService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetos.neu.demooo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.model.LiuJinHe;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LiuJinHeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LiuJinHe <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="liujinheServiceImpl"><a href="#liujinheServiceImpl" class="headerlink" title="liujinheServiceImpl"></a>liujinheServiceImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetos.neu.demooo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.mapper.LiuJinHeMapper;</span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.model.LiuJinHe;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiuJinHeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LiuJinHeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LiuJinHeMapper liuJinHeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiuJinHeServiceImpl</span><span class="params">(LiuJinHeMapper liuJinHeMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liuJinHeMapper = liuJinHeMapper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> LiuJinHe <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> liuJinHeMapper.findById(id);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="liujinheController"><a href="#liujinheController" class="headerlink" title="liujinheController"></a>liujinheController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetos.neu.demooo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.model.LiuJinHe;</span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.service.LiuJinHeService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiuJinHeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LiuJinHeService liuJinHeService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiuJinHeController</span><span class="params">(LiuJinHeService liuJinHeService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liuJinHeService = liuJinHeService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findById&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LiuJinHe <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> liuJinHeService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遇到问题：SELECT-command-denied-to-user-‘myuser‘-’172-22-0-1’-for-table-‘LiuJinHe’"><a href="#遇到问题：SELECT-command-denied-to-user-‘myuser‘-’172-22-0-1’-for-table-‘LiuJinHe’" class="headerlink" title="遇到问题：SELECT command denied to user ‘myuser‘@’172.22.0.1’ for table ‘LiuJinHe’"></a>遇到问题：SELECT command denied to user ‘myuser‘@’172.22.0.1’ for table ‘LiuJinHe’</h2><ul><li>用户没有权限，删除compose.yml中mysql的envi的用户名和密码，只保留根用户密码</li></ul><h2 id="Bean扫描及注册"><a href="#Bean扫描及注册" class="headerlink" title="Bean扫描及注册"></a>Bean扫描及注册</h2><p>启动类所在的包是根包，Spring Boot会自动扫描根包下及其子包下的所有类，查找带有<code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>等注解的类，并将它们注册为Bean。<br>如果要注册的Bean对象来自于第三方库，是不能添加注解的，这时可以使用<code>@Bean</code>、<code>@Import</code>等注解来注册Bean。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot的一些项目依赖</title>
      <link href="/2024/09/26/docker-compose/"/>
      <url>/2024/09/26/docker-compose/</url>
      
        <content type="html"><![CDATA[<h1 id="创建项目依赖（单体服务器）："><a href="#创建项目依赖（单体服务器）：" class="headerlink" title="创建项目依赖（单体服务器）："></a>创建项目依赖（单体服务器）：</h1><h2 id="Docker-Compose-Support"><a href="#Docker-Compose-Support" class="headerlink" title="Docker Compose Support"></a>Docker Compose Support</h2><p>项目会自动创建一个名为<code>compose.yaml</code>的Docker Compose文件。在这个文件中，已经定义了以下服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;mysql:latest&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;MYSQL_DATABASE=mydatabase&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;MYSQL_PASSWORD=secret&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;MYSQL_ROOT_PASSWORD=verysecret&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;MYSQL_USER=myuser&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;3306:3306&#x27;</span>  <span class="comment"># x:y x是宿主机端口，y是容器端口</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;rabbitmq:latest&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;RABBITMQ_DEFAULT_PASS=secret&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;RABBITMQ_DEFAULT_USER=myuser&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;5672:5672&#x27;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;redis:latest&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;6379:6379&#x27;</span></span><br></pre></td></tr></table></figure><p>services是一个列表，包含了所有的服务。每个服务都有一个名称，如mysql、rabbitmq、redis等。每个服务都有一个image属性，指定了服务的镜像。每个服务都有一个environment属性，指定了服务的环境变量。每个服务都有一个ports属性，指定了服务的端口。</p><ul><li>mysql: <a href="https://hub.docker.com/_/mysql"><code>mysql:latest</code></a> 这是一个MySQL数据库的镜像</li><li>rabbitmq: <a href="https://hub.docker.com/_/rabbitmq"><code>rabbitmq:latest</code></a> 这是一个RabbitMQ消息队列的镜像，用于异步消息处理</li><li>redis: <a href="https://hub.docker.com/_/redis"><code>redis:latest</code></a> 这是一个Redis缓存的镜像，用于缓存数据</li></ul><p>以这个映像为载体（核心）创建一个环境，然后在这个环境中运行应用程序。这样就可以在开发环境中运行应用程序，而不用担心环境的问题。</p><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p>Lombok是一个Java库，可以通过注解的方式来简化Java代码。在SpringBoot项目中，可以通过Lombok来简化实体类的编写。<br>详情链接：<a href="https://projectlombok.org/features">Lombok</a></p><h2 id="Spring-Boot-DevTools"><a href="#Spring-Boot-DevTools" class="headerlink" title="Spring Boot DevTools"></a>Spring Boot DevTools</h2><p>Spring Boot DevTools是一个开发工具，它可以提高开发人员的开发效率。它提供了一些开发工具，如自动重启、热部署等。<br>我暂时用不上</p><h2 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h2><p>Spring Web是Spring框架的一个模块，它提供了一些Web开发的功能，如控制器、视图解析器等。<br>有了它，就可以在SpringBoot项目中开发Web应用程序。</p><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p>Java Database Connectivity (JDBC) API是Java数据库连接的API，它提供了一些接口和类，用于连接数据库、执行SQL语句等。</p><h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h2><p>JPQL（Java Persistence Query Language）,是一种面向对象的查询语言，它类似于SQL，但是更加面向对象。</p><p>Java Persistence API &#x2F; Jakarta Persistence API<br>Spring Data JPA是Spring框架的一个模块，它提供了一些JPA的功能，如实体管理、事务管理等。</p><h2 id="Rest-Repositories"><a href="#Rest-Repositories" class="headerlink" title="Rest Repositories"></a>Rest Repositories</h2><p>Rest Repositories是Spring框架的一个模块，它提供了一些RESTful风格的资源库，用于访问数据。</p><p>什么是REST风格？ REST是一种软件架构风格，它是一种设计原则，用于构建分布式系统。RESTful是一种设计风格，用于构建RESTful风格的Web服务。RESTful风格的Web服务是一种基于HTTP协议的Web服务，它使用HTTP协议的方法来操作资源，如GET（查）、POST（增）、PUT（改）、DELETE（删）等。</p><h2 id="Rest-Repositories-HAL-Browser"><a href="#Rest-Repositories-HAL-Browser" class="headerlink" title="Rest Repositories HAL Browser"></a>Rest Repositories HAL Browser</h2><p>Rest Repositories HAL Browser是一个RESTful风格的资源库，用于访问数据。</p><h2 id="Spring-Data-Redis-Access-Driver"><a href="#Spring-Data-Redis-Access-Driver" class="headerlink" title="Spring Data Redis (Access+Driver)"></a>Spring Data Redis (Access+Driver)</h2><p>Spring Data Redis是Spring框架的一个模块，它提供了一些Redis的功能，如连接Redis、操作Redis等。</p><h2 id="MySQL-Driver"><a href="#MySQL-Driver" class="headerlink" title="MySQL Driver"></a>MySQL Driver</h2><h2 id="MyBatis-Framework"><a href="#MyBatis-Framework" class="headerlink" title="MyBatis Framework"></a>MyBatis Framework</h2><p>MyBatis Framework是一个持久层框架，它可以简化数据库操作，提高开发效率。</p><h2 id="Quartz-Scheduler"><a href="#Quartz-Scheduler" class="headerlink" title="Quartz Scheduler"></a>Quartz Scheduler</h2><p>Quartz Scheduler是一个调度框架，它可以用于定时任务、异步任务等。</p><p>什么是cron表达式？<br>cron表达式是一种时间表达式，用于指定任务的执行时间。它由6个字段组成，分别表示秒、分、时、日、月、周。每个字段都有一个取值范围，如秒的取值范围是0-59，分的取值范围是0-59，时的取值范围是0-23，日的取值范围是1-31，月的取值范围是1-12，周的取值范围是0-6。cron表达式可以指定任务的执行时间，</p><p>例如：每天凌晨1点执行一次任务，可以使用<code>0 0 1 * * ?</code>；</p><p>每天凌晨1点到2点之间每分钟执行一次任务，可以使用<code>0 0-59 1 * * ?</code>；</p><p>每天凌晨1点到2点之间每5分钟执行一次任务，可以使用<code>0 0/5 1 * * ?</code>；</p><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>Spring Security是Spring框架的一个模块，它提供了一些安全功能，如认证、授权等。</p><h2 id="Java-Mail-Sender"><a href="#Java-Mail-Sender" class="headerlink" title="Java Mail Sender"></a>Java Mail Sender</h2><p>Java Mail Sender是一个邮件发送工具，它可以用于发送邮件。</p><p>Thymeleaf是一个模板引擎，它可以用于生成HTML页面。结合Java Mail Sender，可以用于发送HTML邮件。</p><h2 id="Spring-for-RabbitMQ"><a href="#Spring-for-RabbitMQ" class="headerlink" title="Spring for RabbitMQ"></a>Spring for RabbitMQ</h2><p>Spring for RabbitMQ是Spring框架的一个模块，它提供了一些RabbitMQ的功能，如连接RabbitMQ、操作RabbitMQ等。<br>RabbitMQ是一个消息队列，它可以用于异步消息处理。<br>实际案例：用户注册时，发送一封邮件给用户，告知用户注册成功，可以使用RabbitMQ来实现异步消息处理，队列里面存放用户注册的消息，消费者监听队列，当有消息时，发送邮件给用户。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker Compose </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to Skye&#39;s Cottage!</title>
      <link href="/2024/09/23/hello-world/"/>
      <url>/2024/09/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>🌲 Deep in a secluded valley, far from the hustle and bustle of the world, there stands a tiny wooden cottage, surrounded by lush green forests and twinkling stars. This is Skye’s Cottage, the cozy home of a programmer who—let’s be honest—isn’t exactly great at magic. 🧙‍♀️💻</p><p>Skye is a little wizard who loves tinkering with computers, but whether it’s casting spells or writing code, she always seems to mess things up. Her magic doesn’t make broomsticks fly—it gets them stuck in tree branches, wobbling helplessly. And her code? Well, let’s just say her screen is often flooded with red error messages, as if mocking her “noob” status. 🚨❌</p><p>But Skye never gives up. 💪 Every morning, she powers up her ancient laptop, determined to fix yesterday’s catastrophic bug. Outside, birds chirp and the wind whispers through the trees, as if cheering her on. 🎶🍃 Even when she sits on the cottage steps, staring into the distance and sighing, “Where did I go wrong this time?”, the fire in her heart never fades. 🔥❤️</p><p>She knows that whether it’s magic or programming, failure is just another step toward success. Every time she squashes a tiny bug, she celebrates like she’s just defeated a mighty magical beast. 🎉🐉 And even though she’s got a long way to go before becoming a legendary coder, she understands that the real magic lies in the journey itself. ✨🚀</p><p>Welcome to Skye’s Cottage—a world where magic and code coexist. 💻🔮 Whether you’re looking for an escape from reality or a spark of programming inspiration, step inside this cozy little home. Who knows? You might just realize that there’s no problem in the world that a simple restart can’t fix. And if there is… well, just restart a few more times. 😉🔄</p><img src="\images\tale.png" width=70%>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
