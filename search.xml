<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式</title>
      <link href="/2025/03/18/reg/"/>
      <url>/2025/03/18/reg/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是正则表达式"><a href="#1-什么是正则表达式" class="headerlink" title="1. 什么是正则表达式"></a>1. 什么是正则表达式</h2><p>正则表达式是一种用来匹配字符串的强有力的工具，它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，就认为是匹配的。</p><p>在JavaScript中，正则表达式是对象，通常用来检索、替换那些符合某个模式的文本。匹配（验证表单）、替换（过滤敏感词）、提取（爬虫）等。</p><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h2><h3 id="定义正则表达式"><a href="#定义正则表达式" class="headerlink" title="定义正则表达式"></a>定义正则表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment">// 1. 字面量定义：`/正则表达式/修饰符`</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/hello/</span></span><br><span class="line"><span class="comment">// 2. 构造函数定义：`new RegExp(&#x27;正则表达式&#x27;, &#x27;修饰符&#x27;)`</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="判断字符串是否符合规则"><a href="#判断字符串是否符合规则" class="headerlink" title="判断字符串是否符合规则"></a>判断字符串是否符合规则</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="检索（查找）符合规则的字符串"><a href="#检索（查找）符合规则的字符串" class="headerlink" title="检索（查找）符合规则的字符串"></a>检索（查找）符合规则的字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regObj.<span class="title function_">exec</span>(str) <span class="comment">// 返回一个数组，包含匹配的字符串，index，input</span></span><br></pre></td></tr></table></figure><h2 id="3-元字符"><a href="#3-元字符" class="headerlink" title="3.元字符"></a>3.元字符</h2><ul><li>普通字符：字母、数字，仅仅描述字符本身。</li><li>元字符：具有特殊含义的字符，用来描述字符的组合规则，比如26字母可以写成<code>[a-z]</code>。</li></ul><h3 id="🦮边界符"><a href="#🦮边界符" class="headerlink" title="🦮边界符"></a>🦮边界符</h3><p><strong>表示位置，开头和结尾，必须用什么开头，用什么结尾。</strong></p><ul><li><code>^</code>：匹配字符串的开始。</li><li><code>$</code>：匹配字符串的结束。</li><li>比如：<code>/^hello$/</code>表示字符串必须是<code>hello</code>，或者<code>/^hello/</code>表示字符串必须以<code>hello</code>开头，<code>/hello$/</code>表示字符串必须以<code>hello</code>结尾。</li></ul><h3 id="🦮量词"><a href="#🦮量词" class="headerlink" title="🦮量词"></a>🦮量词</h3><p><strong>描述字符出现的次数。</strong></p><ul><li><code>*</code>：匹配前一个字符0次或多次，比如<code>/a*/</code>可以匹配<code>&#39;&#39;</code>、<code>&#39;a&#39;</code>、<code>&#39;aa&#39;</code>等。</li><li><code>+</code>：匹配前一个字符1次或多次，比如<code>/a+/</code>可以匹配<code>&#39;a&#39;</code>、<code>&#39;aa&#39;</code>、<code>&#39;aaa&#39;</code>等。</li><li><code>?</code>：匹配前一个字符0次或1次，比如<code>/a?/</code>可以匹配<code>&#39;&#39;</code>、<code>&#39;a&#39;</code>。</li><li><code>&#123;n&#125;</code>：匹配前一个字符n次，比如<code>/a&#123;3&#125;/</code>可以匹配<code>&#39;aaa&#39;</code>。</li><li><code>&#123;n,&#125;</code>：匹配前一个字符至少n次，比如<code>/a&#123;3,&#125;/</code>可以匹配<code>&#39;aaa&#39;</code>、<code>&#39;aaaa&#39;</code>。</li><li><code>&#123;n,m&#125;</code>：匹配前一个字符n到m次，比如<code>/a&#123;3,5&#125;/</code>可以匹配<code>&#39;aaa&#39;</code>、<code>&#39;aaaa&#39;</code>、<code>&#39;aaaaa&#39;</code>。</li></ul><h3 id="🦮字符类"><a href="#🦮字符类" class="headerlink" title="🦮字符类"></a>🦮字符类</h3><ul><li><code>[]</code>：匹配方括号中的任意一个字符。</li><li><code>[^]</code>：匹配除了方括号中的任意一个字符。</li><li><code>-</code>：连字符，表示范围，比如<code>[a-z]</code>表示26个小写字母。</li><li><code>\d</code>：匹配任意一个数字，等价于<code>[0-9]</code>。</li><li><code>\D</code>：匹配任意一个非数字，等价于<code>[^0-9]</code>。</li><li><code>\w</code>：匹配任意一个字母、数字、下划线，等价于<code>[a-zA-Z0-9_]</code>。</li><li><code>\W</code>：匹配任意一个非字母、数字、下划线，等价于<code>[^a-zA-Z0-9_]</code>。</li><li><code>\s</code>：匹配任意一个空白字符，包括空格、制表符、换行符等。</li><li><code>\S</code>：匹配任意一个非空白字符。</li><li><code>.</code>：匹配除了换行符之外的任意一个字符。</li></ul><h2 id="4-修饰符"><a href="#4-修饰符" class="headerlink" title="4.修饰符"></a>4.修饰符</h2><p>修饰符约束正则执行的某些细节行为，如是否区分大小写、是否多行匹配等。</p><ul><li><code>i</code>：忽略大小写。</li><li><code>g</code>：全局匹配，匹配所有符合规则的字符串。</li><li><code>m</code>：多行匹配，匹配每一行的开头和结尾。</li><li><code>s</code>：单行匹配，<code>.</code>可以匹配换行符。</li><li><code>u</code>：Unicode模式，处理大于<code>\uFFFF</code>的Unicode字符。</li><li><code>y</code>：粘连模式，匹配从上次匹配的位置开始。<br>例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/hello/gi</span>  <span class="comment">// 忽略大小写，全局匹配</span></span><br></pre></td></tr></table></figure></li><li>.replace()方法,替换字符串,第一个参数是正则表达式,第二个参数是要替换的字符串<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">replace</span>(<span class="regexp">/hello/</span>, <span class="string">&#x27;hi&#x27;</span>) <span class="comment">// 又发返回值,不会改变原字符串，并且只会替换第一个匹配到的字符串</span></span><br><span class="line"><span class="keyword">const</span> result2 = str.<span class="title function_">replace</span>(<span class="regexp">/hello/g</span>, <span class="string">&#x27;hi&#x27;</span>) <span class="comment">// 全局匹配,会替换所有匹配到的字符串</span></span><br></pre></td></tr></table></figure><blockquote><p><code>|</code>：或者，匹配多个规则中的一个。’</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web APIs学习 --BOM（三）</title>
      <link href="/2025/03/18/bomStudy/"/>
      <url>/2025/03/18/bomStudy/</url>
      
        <content type="html"><![CDATA[<h2 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h2><h3 id="1-BOM对象"><a href="#1-BOM对象" class="headerlink" title="1.BOM对象"></a>1.BOM对象</h3><ul><li><p><code>BOM</code>是浏览器对象模型，是浏览器提供的对象模型，用于操作浏览器窗口。</p></li><li><p>全局对象，document、location、navigator、history都是window的属性。</p></li></ul><h3 id="2-定时器-延时函数"><a href="#2-定时器-延时函数" class="headerlink" title="2.定时器-延时函数"></a>2.定时器-延时函数</h3><ul><li><code>setTimeout</code>：延时执行一次，返回值是一个定时器ID。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;延时执行&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li><li>清除延时函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clearTimeout</span>(timer)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-JS执行机制"><a href="#3-JS执行机制" class="headerlink" title="3.JS执行机制"></a>3.JS执行机制</h3><ul><li>浏览器有两个引擎：JS引擎和渲染引擎。</li><li>单线程执行，同一时间只能执行一个任务。</li><li>同步和异步任务：同步任务会阻塞后续任务，异步任务不会阻塞后续任务。</li><li>同步任务在主线程执行，形成一个执行栈。</li><li>异步任务相关会放到任务队列中，等待主线程空闲时执行。</li><li>异步任务有三种类型：普通事件、资源加载、定时器。</li><li>一旦执行栈中所有的同步任务执行完毕，就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</li><li><strong>事件循环</strong>：主线程从任务队列中读取事件，这个过程是循环不断的，所以叫事件循环。</li></ul><h3 id="4-location对象"><a href="#4-location对象" class="headerlink" title="4.location对象"></a>4.location对象</h3><ul><li>location的数据类型是对象，拆分并保存了URL地址的各个组成部分</li><li>location对象的属性：<ul><li><code>href</code>：获取或设置整个URL地址。</li><li><code>protocol</code>：获取或设置协议部分。</li><li><code>host</code>：获取或设置主机部分。</li><li><code>hostname</code>：获取或设置主机名。</li><li><code>port</code>：获取或设置端口号。</li><li><code>pathname</code>：获取或设置路径部分。</li><li><code>search</code>：获取或设置查询部分，以<code>?</code>开头。</li><li><code>hash</code>：获取或设置哈希部分，以<code>#</code>开头。</li><li><code>.reload()</code>：重新加载页面,true强制从服务器加载，false从缓存加载。</li></ul></li></ul><h3 id="5-navigator对象"><a href="#5-navigator对象" class="headerlink" title="5.navigator对象"></a>5.navigator对象</h3><ul><li>navigator对象包含了浏览器的信息，比如浏览器的名称、版本、操作系统等。</li><li>userAgent属性：检测浏览器的版本及平台。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> userAgent = navigator.<span class="property">userAgent</span></span><br><span class="line">    <span class="keyword">const</span> android = userAgent.<span class="title function_">match</span>(<span class="regexp">/(Android);?[\s\/]+([\d.]+)?/</span>)</span><br><span class="line">    <span class="keyword">const</span> iphone = userAgent.<span class="title function_">match</span>(<span class="regexp">/(iPhone\sOS)\s([\d_]+)/</span>)</span><br><span class="line">    <span class="keyword">if</span>(android||iphone) &#123;</span><br><span class="line">        location.<span class="property">href</span> = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-history对象"><a href="#6-history对象" class="headerlink" title="6.history对象"></a>6.history对象</h3><ul><li>history对象管理历史记录，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等。</li><li>back()：后退</li><li>forward()：前进</li><li>go()：前进或后退，1为前进，-1为后退。</li></ul><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><ul><li>起因：存在需要存储在本地的数据。</li><li>HTML5提供了两种本地存储方式：<code>localStorage</code>和<code>sessionStorage</code>，约5MB左右。</li><li>数据存储在用户浏览器中，设置、读取方便、页面刷新不会丢失。</li></ul><h3 id="本地存储分类"><a href="#本地存储分类" class="headerlink" title="本地存储分类"></a>本地存储分类</h3><ul><li><code>localStorage</code>：永久存储，除非手动删除。可以跨窗口，以键值对的形式存储，只能存储字符串。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(key, value)</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key)</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(key)</span><br></pre></td></tr></table></figure></li><li><code>sessionStorage</code>：会话存储，关闭浏览器窗口后自动删除。在同一个窗口下可以共享数据。</li></ul><h3 id="存储复杂数据类型"><a href="#存储复杂数据类型" class="headerlink" title="存储复杂数据类型"></a>存储复杂数据类型</h3><ul><li>想要存储对象，需要先将对象转换为字符串，再存储。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;obj&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line"><span class="keyword">const</span> objStr = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;obj&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(objStr)</span><br></pre></td></tr></table></figure>其中，<code>JSON.stringify()</code>将对象转换为字符串，<code>JSON.parse()</code>将字符串转换为对象。</li></ul><blockquote><p>利用map方法和join方法实现字符串的拼接</p><p>map方法：遍历数组，返回<strong>一个新数组</strong>,map也称为映射，指两个元素的集之间元素相互对应的关系，map重点有返回值，forEach没有返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>) <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line"><span class="keyword">const</span> newArr2 = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>item+index)</span><br></pre></td></tr></table></figure><p>join方法：将数组中的所有元素连接成一个字符串，返回<strong>一个字符串</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> str = arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>) <span class="comment">// 1-2-3-4-5，默认是逗号</span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web APIs学习 --DOM（二）</title>
      <link href="/2025/03/18/domStudy2/"/>
      <url>/2025/03/18/domStudy2/</url>
      
        <content type="html"><![CDATA[<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><p>用来表示时间的对象，可以得到当前系统时间。</p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="keyword">const</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2021-01-01&#x27;</span>) <span class="comment">// 获取指定时间</span></span><br></pre></td></tr></table></figure><h3 id="时间对象方法"><a href="#时间对象方法" class="headerlink" title="时间对象方法"></a>时间对象方法</h3><p>返回的数据不适用于直接使用，该怎么转换为实际开发中常用的格式呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date) <span class="comment">// 2021-01-01T00:00:00.000Z</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getFullYear</span>()) <span class="comment">// 2021 年份</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getMonth</span>()) <span class="comment">// 0 月份 0-11 注意是从0开始！</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getDate</span>()) <span class="comment">// 1 日期</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getDay</span>()) <span class="comment">// 5 星期 0-6 0是星期天</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getHours</span>()) <span class="comment">// 8 小时</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getMinutes</span>()) <span class="comment">// 0 分钟</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getSeconds</span>()) <span class="comment">// 0 秒</span></span><br></pre></td></tr></table></figure><p>常见的拼接方式，写成函数的格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatDate</span>(<span class="params">date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;date.getFullYear()&#125;</span>-<span class="subst">$&#123;date.getMonth() + <span class="number">1</span>&#125;</span>-<span class="subst">$&#123;date.getDate()&#125;</span> <span class="subst">$&#123;date.getHours()&#125;</span>:<span class="subst">$&#123;date.getMinutes()&#125;</span>:<span class="subst">$&#123;date.getSeconds()&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想让月份和日期显示两位数，可以使用<strong>padStart</strong>方法，这个方法是ES6新增的方法，用于字符串补全长度。第一个参数是字符串的最小长度，第二个参数是用来补全的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatDate</span>(<span class="params">date</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> year = date.<span class="title function_">getFullYear</span>()</span><br><span class="line">    <span class="keyword">const</span> month = (date.<span class="title function_">getMonth</span>() + <span class="number">1</span>).<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> day = date.<span class="title function_">getDate</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> hour = date.<span class="title function_">getHours</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> minute = date.<span class="title function_">getMinutes</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> second = date.<span class="title function_">getSeconds</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;month&#125;</span>-<span class="subst">$&#123;day&#125;</span> <span class="subst">$&#123;hour&#125;</span>:<span class="subst">$&#123;minute&#125;</span>:<span class="subst">$&#123;second&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么才能让时间实时更新呢？可以使用定时器，每隔一秒更新一次时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatDate</span>(date))</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>还有一些内置的格式化方法，比如<strong>toLocaleString</strong>方法，可以根据本地时间格式化日期。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleString</span>()) <span class="comment">// 2021/1/1 04:00:00</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleDateString</span>()) <span class="comment">// 2021/1/1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleTimeString</span>()) <span class="comment">// 04:00:00</span></span><br></pre></td></tr></table></figure><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><blockquote><p>时间戳是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数，可以用来表示一个时间点。</p></blockquote><p>使用场景比如说要计算倒计时效果，可以使用时间戳来计算。算法是：目标时间戳减去当前时间戳，得到的是毫秒数，再除以1000得到秒数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetTime = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2021-01-01&#x27;</span>).<span class="title function_">getTime</span>()</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">const</span> second = (targetTime - nowTime) / <span class="number">1000</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(second)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>还有更简洁的办法！下面是三个获取时间戳的方法，都是获取当前时间戳。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time1 = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="keyword">const</span> time2 = +<span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">//推荐</span></span><br><span class="line"><span class="keyword">const</span> time3 = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 只能获取当前时间戳</span></span><br></pre></td></tr></table></figure><p>拿到相差的毫秒数后，可以转换为天、时、分、秒的格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetTime = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2021-01-01&#x27;</span>).<span class="title function_">getTime</span>()</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">const</span> second = (targetTime - nowTime) / <span class="number">1000</span></span><br><span class="line">    <span class="keyword">const</span> day = <span class="title class_">Math</span>.<span class="title function_">floor</span>(second / <span class="number">3600</span> / <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">const</span> hour = <span class="title class_">Math</span>.<span class="title function_">floor</span>(second / <span class="number">3600</span> % <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">const</span> minute = <span class="title class_">Math</span>.<span class="title function_">floor</span>(second / <span class="number">60</span> % <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">const</span> sec = <span class="title class_">Math</span>.<span class="title function_">floor</span>(second % <span class="number">60</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;day&#125;</span>天<span class="subst">$&#123;hour&#125;</span>时<span class="subst">$&#123;minute&#125;</span>分<span class="subst">$&#123;sec&#125;</span>秒`</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><p>DOM节点是HTML文档中的元素，可以通过JS来操作DOM节点，比如增删改查。节点类型有：</p><ul><li><strong>元素节点</strong>：HTML标签</li><li>文本节点</li><li>属性节点</li><li>其他</li></ul><h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><p>利用<strong>parentNode</strong>属性可以找到父节点，返回最近一级的父节点，找不到返回null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = son.<span class="property">parentNode</span></span><br></pre></td></tr></table></figure><h4 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h4><ul><li>利用<strong>childNodes</strong>属性可以找到子节点，返回一个伪数组，包含所有子节点，包括文本节点和注释节点等。</li><li><strong>children属性只包含元素节点，不包含文本节点，返回的依旧是伪数组。</strong></li></ul><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><ul><li><strong>previousElementSibling</strong>属性可以找到前一个兄弟节点。</li><li><strong>nextElementSibling</strong>属性可以找到后一个兄弟节点。</li></ul><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><p>很多情况需要在页面中新增节点，比如点击发布按钮后新增一条信息。</p><p><strong>两个步骤：创建节点、追加节点。</strong></p><ul><li><strong>createElement</strong>方法可以创建元素节点。</li><li><strong>appendChild</strong>方法可以追加节点，插入到某个父元素的最后。</li><li><strong>insertBefore</strong>方法可以插入到某个父元素的某个子元素前。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建节点</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. 追加节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line"><span class="comment">// 父元素.insertBefore(新元素, 参考元素)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><p><strong>cloneNode</strong>方法可以克隆节点，参数是一个布尔值，true表示深拷贝，克隆节点及其子节点，false表示浅拷贝，只克隆节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> div2 = div.<span class="title function_">cloneNode</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 追加</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div2)</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p><strong>removeChild</strong>方法可以删除节点，参数是要删除的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父元素.removeChild(子元素)</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(div)</span><br></pre></td></tr></table></figure><blockquote><p>M端事件，移动端又一些独特的地方，比如触屏事件touch，可以响应用户手指或触控笔对屏幕或触控版的操作。</p><p>常见的touch事件有：touchstart、touchmove、touchend。</p></blockquote><h2 id="JS插件"><a href="#JS插件" class="headerlink" title="JS插件"></a>JS插件</h2><p>插件就是别人写好的一些代码，我们只需要复制对应的代码，就可以直接实现对应的效果，比如轮播图、日历等。</p><p>swiper是一个轮播图插件，可以实现轮播图效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span> = <span class="string">./css/swiper.min.css</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/swiper.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web APIs学习 --DOM（一）</title>
      <link href="/2025/03/17/domstudy1/"/>
      <url>/2025/03/17/domstudy1/</url>
      
        <content type="html"><![CDATA[<h3 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h3><ul><li>尽量用const，少用let，不用var。</li><li>数组和对象用const，数组和对象的元素和属性可以改变。因为const只是保证变量指向的内存地址不变，不保证内存地址的值不变。</li></ul><h3 id="基本认知"><a href="#基本认知" class="headerlink" title="基本认知"></a>基本认知</h3><ul><li>Web API就是使用js去操作html和浏览器</li><li>分类：DOM（文档对象模型）、BOM（浏览器对象模型）</li><li>DOM是用来呈现以及与任意HTML或XML文档交互的API，主要<strong>操作网页内容</strong>，比如对页面元素进行移动、大小、添加删除等操作。开发网页内容特效和实现用户交互</li></ul><h4 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h4><p>将HTML文档以树状结构直观的表现出来，文档树直观的体现了标签与标签之间的关系。<br><img src="/images/js/domtree.png" alt="DOM树"></p><ul><li>DOM树的节点类型<ul><li>元素节点：HTML标签</li><li>文本节点：HTML文本</li><li>属性节点：HTML属性</li><li>注释节点：HTML注释</li></ul></li></ul><h4 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h4><p>浏览器根据html标签生成的js对象，所有的标签属性都可以在这个对象上面找到，修改这个对象的属性会自动映射到标签身上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元素对象,在html中是标签，在js中获取到的是对象。</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure><p>DOM的核心思想：<strong>把网页内容当作对象来处理，通过js操作DOM对象，从而改变页面内容</strong></p><ul><li>document对象：代表整个文档，是DOM树的根节点，所以它所提供的属性和方法都是用来访问和操作网页内容的，网页所有内容都在document中。</li></ul><h4 id="获取DOM对象"><a href="#获取DOM对象" class="headerlink" title="获取DOM对象"></a>获取DOM对象</h4><ul><li>根据CSS选择器获取元素对象<ul><li><code>document.querySelector(&#39;css选择器&#39;)</code>：获取第一个符合条件的元素对象，返回值是一个HTMLElement对象</li><li><code>document.querySelectorAll(&#39;css选择器&#39;)</code><br>：获取所有符合条件的元素对象，返回值是一个NodeList对象集合,获取到的是伪数组，有长度有索引，但是不能使用pop、push等数组方法。想要得到里面的每一个对象，可以使用forEach遍历。</li><li><code>document.getElementById(&#39;id&#39;)</code>：根据id获取元素对象，返回值是一个HTMLElement对象</li><li><code>document.getElementsByClassName(&#39;class&#39;)</code>：根据class获取元素对象，返回值是一个HTMLCollection对象集合</li><li><code>document.getElementsByTagName(&#39;tag&#39;)</code>：根据标签名获取元素对象，返回值是一个HTMLCollection对象集合</li></ul></li></ul><blockquote><p>CSS选择器</p><ul><li>标签选择器：<code>div</code>，<code>p</code>，<code>span</code></li><li>类选择器：<code>.class</code>，<code>.active</code>，<code>.container</code></li><li>id选择器：<code>#id</code></li><li>属性选择器：<code>div[class=&quot;container&quot;]</code></li><li>伪类选择器：<code>:hover</code>，<code>:active</code>，<code>:first-child</code></li><li>伪元素选择器：<code>::before</code>，<code>::after</code></li><li>后代选择器：<code>div p</code> 指的是div下的所有p</li><li>子元素选择器：<code>div &gt; p</code> 指的是div下的直接子元素p</li><li>相邻兄弟选择器：<code>div + p</code> 指的是div后面的第一个p</li><li>通用选择器：<code>*</code></li><li>分组选择器：<code>div, p</code> 指的是div和p</li></ul></blockquote><h4 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h4><ul><li><p>操作元素内容</p><ul><li><code>element.innerHTML</code>：获取元素内部的html内容，比如<code>&lt;div&gt;hello&lt;/div&gt;</code>，获取到的是<code>hello</code>，将html内容添加到元素中，会解析html标签。</li><li><code>element.innerText</code>：获取元素内部的文本内容，比如<code>&lt;div&gt;hello&lt;/div&gt;</code>，获取到的是<code>hello</code>，将文本内容添加到元素中，会自动转义，不会解析html标签。</li></ul></li><li><p>操作元素属性</p><ul><li><code>element.style</code>：获取元素的样式，返回一个对象，可以通过这个对象修改元素的样式。如果是background-color这种属性，需要改成<br><strong>小驼峰命名法</strong>，比如<code>backgroundColor</code>。</li><li><code>element.className</code>：获取元素的class属性，返回一个字符串，可以通过这个字符串修改元素的class属性。具体来说，事先在css中定义好样式，然后通过js修改元素的class属性，从而改变元素的样式。<br>如果原先有类名，要注意保留原来的类名。</li><li><code>element.classList</code>：<strong>终极解决方案</strong>，为了解决className容易覆盖以前的类型，我们可以通过classList的方式追加和删除类名。  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">element.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">element.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;active&#x27;</span>) <span class="comment">// 如果有就删除，没有就添加 切换</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>操作表单元素属性</p><ul><li><code>element.value</code>：获取表单元素的值，比如input、textarea、select等。</li><li>复选框、单选框、下拉框等表单元素，需要通过<code>element.checked</code>、<code>element.selected</code>、<code>element.disabled</code>等属性来操作。</li><li>checked：复选框是否选中，selected：下拉框是否选中，disabled：表单元素是否禁用。</li></ul></li><li><p>自定义属性<br>这是HTML5新增的属性，可以在标签上自定义属性，比如<code>&lt;div data-id=&quot;1&quot;&gt;&lt;/div&gt;</code>，可以通过<code>element.dataset.id</code><br>获取到这个属性的值。意义是可以在标签上存储一些数据，方便js操作。<br>例子：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-id</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">dataset</span>.<span class="property">id</span>) <span class="comment">// 1</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="定时器-间歇函数"><a href="#定时器-间歇函数" class="headerlink" title="定时器-间歇函数"></a>定时器-间歇函数</h4><p>情景：比如每隔一段时间就弹出一个警告框，或者每隔一段时间就改变一下页面的颜色等，倒计时。</p><ul><li>开启定时器<ul><li><code>setInterval(callback, time)</code>：每隔一段时间执行一次回调函数</li><li><code>setTimeout(callback, time)</code>：延迟一段时间执行一次回调函数</li></ul></li><li>关闭定时器<ul><li><code>clearInterval(timer)</code>：关闭间歇函数</li><li><code>clearTimeout(timer)</code>：关闭延时函数</li></ul></li><li>例子：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>什么是事件？ 事件是浏览器或用户自身执行的某种动作，比如点击、滚动、输入等。</p><ul><li>click：点击事件</li><li>mouseover：鼠标移入事件</li><li>mouseout：鼠标移出事件</li><li>keydown：键盘按下事件</li><li>keyup：键盘抬起事件</li><li>scroll：滚动事件</li><li>change：表单元素值改变事件</li><li>focus：表单元素获取焦点事件</li><li>blur：表单元素失去焦点事件</li><li>input：表单元素输入事件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">  element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>事件监听三要素：事件源、事件类型、事件处理函数</p><h4 id="事件监听版本"><a href="#事件监听版本" class="headerlink" title="事件监听版本"></a>事件监听版本</h4><ul><li>DOM L0级事件监听：<code>element.onclick = function() &#123;&#125;</code></li><li>DOM L2级事件监听：<code>element.addEventListener(&#39;click&#39;, function() &#123;&#125;)</code></li><li>区别：DOM L0级事件监听只能绑定一个事件，DOM L2级事件监听可以绑定多个事件。</li></ul><h4 id="利用js可以调用点击事件"><a href="#利用js可以调用点击事件" class="headerlink" title="利用js可以调用点击事件"></a>利用js可以调用点击事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发点击事件</span></span><br><span class="line">  element.<span class="title function_">click</span>()</span><br></pre></td></tr></table></figure><h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><ul><li>例子：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;focus&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;focus&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;blur&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;blur&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><ul><li>例子：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;keydown&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;keyup&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="用户输入文本事件"><a href="#用户输入文本事件" class="headerlink" title="用户输入文本事件"></a>用户输入文本事件</h4><ul><li>例子：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>什么事事件对象？事件对象是浏览器自动传递给事件处理函数的一个对象，包含了事件的相关信息，比如事件源、事件类型、事件坐标等。比如点击事件，事件对象中包含了点击的坐标。</p><p>使用场景比如：可以判断用户按下的是哪个键，可以获取鼠标点击的坐标等，从而做出相应的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件对象</span></span><br><span class="line">  element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>常见的事件对象属性：</p><ul><li><code>event.target</code>：事件源，触发事件的元素</li><li><code>event.type</code>：事件类型，比如click、mouseover等</li><li><code>event.clientX</code>：鼠标点击的x坐标（<strong>相对于窗口左上角</strong>）</li><li><code>event.clientY</code>：鼠标点击的y坐标</li><li><code>event.keyCode</code>：键盘按下的键的键码（不提倡）</li><li><code>event.key</code>：键盘按下的键的键名（推荐），比如<code>a</code>、<code>b</code>、<code>Enter</code>等</li><li><code>event.offsetX</code>：鼠标点击的x坐标相对于事件源的x坐标（<strong>相对于DOM元素左上角</strong>）</li><li><code>event.offsetY</code>：鼠标点击的y坐标相对于事件源的y坐标</li></ul><h4 id="环境对象"><a href="#环境对象" class="headerlink" title="环境对象"></a>环境对象</h4><p>能够分析判断函数运行在不同环境中this的指向，比如在浏览器中，this指向window对象。代表当前运行环境。</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><ul><li>什么是回调函数？回调函数是作为参数传递给另一个函数的函数，当满足某种条件时，另一个函数会调用这个函数。</li></ul><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><h4 id="事件流与两个阶段说明"><a href="#事件流与两个阶段说明" class="headerlink" title="事件流与两个阶段说明"></a>事件流与两个阶段说明</h4><ul><li>事件流指的是事件完整执行过程中的流动路径</li><li>两个阶段：捕获 &#x2F; 冒泡</li><li>捕获阶段是从Document-&gt;ELement html-&gt;Element body-&gt;Element div，冒泡阶段是倒过来</li><li>实际工作都是使用<strong>事件冒泡</strong>为主</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DOM</span>.<span class="title function_">addEventListener</span>(事件类型,事件处理函数,是否使用捕获机制)</span><br><span class="line"><span class="comment">// true是捕获，false是冒泡，默认是false</span></span><br></pre></td></tr></table></figure><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>从DOM根元素开始去执行对应的事件</p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p><strong>当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发，这一过程被称为事件冒泡</strong></p><p>事件冒泡是默认存在的。</p><h4 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h4><p>因为默认有冒泡模式的存在，容易导致事件影响到父级元素，若想把事件限制在当前的元素内，就需要阻止事件冒泡。</p><p>组建事件冒泡需要拿到事件对象，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事件对象.<span class="title function_">stopPropagation</span>()</span><br><span class="line"><span class="comment">// 阻断事件流动传播，包括冒泡阶段和捕获阶段</span></span><br></pre></td></tr></table></figure><h4 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h4><p>传统的on事件方法，如onclick可以直接使用null覆盖就可以实现。</p><p>removeEventListener(事件类型，事件处理函数，[获取捕获或者冒泡阶段])</p><p><strong>匿名函数无法解绑</strong></p><h4 id="鼠标经过事件的区别"><a href="#鼠标经过事件的区别" class="headerlink" title="鼠标经过事件的区别"></a>鼠标经过事件的区别</h4><ol><li>mouseover和mouseout 会有冒泡效果的</li><li>mouseenter和mouseleave 没有冒泡效果 <strong>推荐</strong></li></ol><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>以前要用for循环来给多个元素注册事件，利用事件冒泡减少注册次数，提高程序性能。</p><p>给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件。</p><p>通过事件对象中的<strong>target</strong>可以找到子元素，<strong>target.tagName</strong>（大写）可以获得真正触发事件的元素</p><h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>比如，阻止链接的跳转，表单域跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件对象.<span class="title function_">preventDefault</span>()</span><br></pre></td></tr></table></figure><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><h4 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h4><ol><li><p>加载外部资源，比如图片、音频、视频等完毕后触发的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;load&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 也可以任意一个dom元素增加load事件，意思是这个元素加载完毕后触发</span></span><br></pre></td></tr></table></figure></li><li><p>当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，无需等待样式表、图像和子框架的加载完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="元素滚动事件"><a href="#元素滚动事件" class="headerlink" title="元素滚动事件"></a>元素滚动事件</h4><p>滚动条在滚动的时候持续触发的事件，应该将事件添加给window对象，因为滚动条是window对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll&#x27;</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> <span class="comment">// 滚动条距离顶部的距离</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>scrollTop：元素滚动条距离顶部的距离</li><li>scrollLeft：元素滚动条距离左边的距禿</li><li>scrollHeight：元素内容的总高度</li><li>scrollWidth：元素内容的总宽度</li></ul><blockquote><p>document.documentElement是html元素，document.body是body元素</p><p>scrollTo(x,y)：滚动到指定坐标</p><p>scroll_behavior: smooth; 平滑滚动</p></blockquote><h4 id="页面尺寸事件"><a href="#页面尺寸事件" class="headerlink" title="页面尺寸事件"></a>页面尺寸事件</h4><p>窗口尺寸改变触发事件resize</p><blockquote><p>clientWidth和clientHeight：元素可视区域的宽度，不包括滚动条、margin、border，包括padding</p><p>offsetWidth和offsetHeight：获取元素自身的设置的宽高、padding、border。可视宽高，如果隐藏，获取的是0 <strong>只读</strong></p><p>offsetLeft和offsetTop: <strong>只读</strong> 获取元素距离自己定位父级的距离</p><p>元素尺寸位置 element.getBoundingClientRect() 返回一个对象，元素的大小及其相对于<strong>视口</strong>的位置</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础语法学习</title>
      <link href="/2025/03/10/jsStudy/"/>
      <url>/2025/03/10/jsStudy/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript是什么？做什么？"><a href="#JavaScript是什么？做什么？" class="headerlink" title="JavaScript是什么？做什么？"></a>JavaScript是什么？做什么？</h2><ul><li>是一种运行在客户端（浏览器）的编程语言，实现人机交互效果。</li><li>网页特效、表单验证、数据交互。</li><li>服务端编程（Node.js）。</li><li>组成：ECMAScript（语言基础）、Web API（浏览器提供的API）（包括页面文档对象模型DOM、浏览器对象模型BOM）</li><li>DOM：操作文档，比如对页面元素进行移动、大小、添加删除等操作。</li><li>BOM：操作浏览器，比如页面弹窗，检测窗口宽度，存储数据到浏览器等。</li></ul><h2 id="JavaScript书写位置"><a href="#JavaScript书写位置" class="headerlink" title="JavaScript书写位置"></a>JavaScript书写位置</h2><ul><li>内部嵌入：在HTML文件中使用<code>&lt;script&gt;</code>标签嵌入JavaScript代码。（</body>上方）<br>原因：浏览器会按照代码在文件中的顺序加载HTML，如果先加载的JavaScript想修改下方的HTML，可能由于HTML尚未加载而失效。</li><li>外部引入：在HTML文件中使用<code>&lt;script&gt;</code>标签引入外部JavaScript文件。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--中间写内容也会被忽略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>内联：在HTML标签中使用<code>onclick</code>等事件属性。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="JavaScript结束符"><a href="#JavaScript结束符" class="headerlink" title="JavaScript结束符"></a>JavaScript结束符</h2><ul><li>JavaScript语句以分号<code>;</code>结尾，但是可以省略。风格统一，要么都加要么都不加。</li></ul><h2 id="输入、输出语法"><a href="#输入、输出语法" class="headerlink" title="输入、输出语法"></a>输入、输出语法</h2><h3 id="输出语法"><a href="#输出语法" class="headerlink" title="输出语法"></a>输出语法</h3><ul><li>第一种，向body输出内容，如果内容是标签，也会被解析成网页元素。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>第二种，页面弹出警告对话框<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>第三种，控制台输出语法，程序员调试使用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="输入语法"><a href="#输入语法" class="headerlink" title="输入语法"></a>输入语法</h3><ul><li>弹出输入对话框，用户输入的内容会被赋值给变量<code>name</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="title function_">prompt</span>(<span class="string">&quot;请输入你的名字：&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="代码执行顺序"><a href="#代码执行顺序" class="headerlink" title="代码执行顺序"></a>代码执行顺序</h2><ul><li>按HTML文档流顺序执行JavaScript代码，alert()和prompt()会跳过页面渲染先执行。</li></ul><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><ul><li>字面量是一种固定值，不可改变，比如数字、字符串、布尔值、数组、对象等。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><ul><li>变量是存储数据的容器，可以存储任何类型的数据。</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>声明变量：let、var</li><li>区别：let和const是ES6新增的，var是ES5的，let和const有块级作用域，var没有。</li><li>赋值：<code>let name = &quot;Tom&quot;;</code></li><li>更新：<code>name = &quot;Jerry&quot;;</code></li></ul><h3 id="变量的本质"><a href="#变量的本质" class="headerlink" title="变量的本质"></a>变量的本质</h3><ul><li>变量是存储在内存中的数据，变量名是对数据的引用。</li></ul><h3 id="命名规则与规范"><a href="#命名规则与规范" class="headerlink" title="命名规则与规范"></a>命名规则与规范</h3><ul><li>变量名只能包含字母、数字、下划线、美元符号，不能以数字开头。</li><li>变量名区分大小写。</li><li>变量名不能使用保留字。</li><li>变量名要有意义，驼峰命名法。</li><li>变量名不能使用中文。</li><li>变量名不能使用特殊符号。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var有一些不合理之处，比如变量提升、全局变量污染等，所以在ES6中引入了let和const。</span><br><span class="line">可以先使用再声明，重复声明，并不合理。</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>数组是一种特殊的对象，用于存储多个数据。</li><li>可以存储不同类型的数据。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>]  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>常量是一种固定值，不可改变。</li><li>声明常量：<code>const PI = 3.14;</code></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JavaScript是一种弱类型语言，变量不需要指定数据类型，可以存储任何类型的数据。</p><ul><li>number 数字</li><li>string 字符串 单引号（推荐）、双引号、反引号（模板字符串）</li><li>boolean 布尔值</li><li>null 空值</li><li>undefined 未定义 声明变量但未赋值</li><li>object 对象 <strong>引用数据类型</strong></li></ul><p><em><strong>NaN</strong></em>：Not a Number，表示不是一个数字，黏性，任何数和NaN计算都是NaN。NaN与NaN不相等。</p><p><em><strong>模版字符串</strong></em>：反引号包裹，可以换行，可以插入变量，使用<code>$&#123;&#125;</code>。</p><p><em><strong>null和undefined的区别</strong></em>:</p><ul><li>null表示空值，是一个对象，表示没有对象。</li><li>undefined表示未定义，是一个数据类型，表示未定义的值。</li><li>null &#x3D;&#x3D; undefined &#x2F;&#x2F; true</li><li>null &#x3D;&#x3D;&#x3D; undefined &#x2F;&#x2F; false</li></ul><p><em><strong>检测数据类型</strong></em>:</p><ul><li>typeof() &#x2F;&#x2F; 返回数据类型的字符串形式 </li><li>Object.prototype.toString.call() &#x2F;&#x2F; 返回对象的类型</li></ul><p><em><strong>类型转换</strong></em>:</p><ul><li>强制类型转换：Number()、String()、Boolean()、parseInt()、parseFloat()。</li><li>自动类型转换：隐式类型转换，比如字符串和数字相加，数字会转换成字符串。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>对变量进行赋值的运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">5</span>; <span class="comment">// a = a + 5</span></span><br><span class="line">a -= <span class="number">5</span>; <span class="comment">// a = a - 5</span></span><br><span class="line">a *= <span class="number">5</span>; <span class="comment">// a = a * 5</span></span><br><span class="line">a /= <span class="number">5</span>; <span class="comment">// a = a / 5</span></span><br><span class="line">a %= <span class="number">5</span>; <span class="comment">// a = a % 5</span></span><br></pre></td></tr></table></figure><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p>对一个变量进行操作的运算符。正负号、自增自减。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">a++; <span class="comment">// a = a + 1</span></span><br><span class="line">a--; <span class="comment">// a = a - 1</span></span><br></pre></td></tr></table></figure><p>前置自增自减：先加先减。<br>后置自增自减：先赋值再加减。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较两个值的大小，返回布尔值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">a &gt; b; <span class="comment">// false</span></span><br><span class="line">a &lt; b; <span class="comment">// true</span></span><br><span class="line">a &gt;= b; <span class="comment">// false</span></span><br><span class="line">a &lt;= b; <span class="comment">// true</span></span><br><span class="line">a == b; <span class="comment">// false 两个等号是比较值是否相等</span></span><br><span class="line">a != b; <span class="comment">// true</span></span><br><span class="line">a === b; <span class="comment">// false 三个等号是比较值和类型是否相等</span></span><br><span class="line">a !== b; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>; <span class="comment">// false</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>字符串比较：比较的是Unicode编码，从第一个字符开始比较，如果相等则继续比较下一个字符，直到不相等为止。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符用于连接两个或多个表达式，返回布尔值。</p><ul><li>与：&amp;&amp; 两个表达式都为真，结果为真。</li><li>或：|| 两个表达式有一个为真，结果为真。</li><li>非：! 表达式为真，结果为假。</li><li>短路逻辑：如果第一个表达式的结果可以确定整个表达式的结果，就不会执行第二个表达式。</li><li>逻辑运算符的优先级：! &gt; &amp;&amp; &gt; ||</li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><ul><li>一元运算符 &gt; 算术运算符 &gt; 比较运算符 &gt; 逻辑运算符 &gt; 赋值运算符</li><li>优先级相同的运算符，从左到右执行。</li><li>可以使用括号改变运算顺序。</li></ul><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ul><li>语句是一组指令，用于执行特定的任务。</li></ul><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><ul><li>表达式是一个值或变量或运算符的组合，可以计算出一个值。</li><li>语句是一组表达式的组合，用于执行特定的任务。</li></ul><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><p>顺序结构、分支结构、循环结构。</p><ul><li>if语句<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 条件为真执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件为假执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>if…else if…else<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 条件1为真执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 条件2为真执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件1和条件2都为假执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>switch语句<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 表达式等于值1执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 表达式等于值2执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="comment">// 表达式不等于值1和值2执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>三元运算符：<code>条件 ? 成功执行 : 失败执行</code></li></ul><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h4><ul><li>断点：在代码中设置一个断点，程序执行到断点时会暂停。</li><li>单步执行：逐行执行代码。</li><li>查看变量：查看变量的值。</li><li>查看调用栈：查看函数的调用关系。</li><li>重启：重新执行代码。</li></ul><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>三要素：变量起始值、终止条件、变量更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 条件为真执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>break: 跳出循环。</li><li>continue: 跳过本次循环。</li></ul><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 条件为真执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>无限循环是一种循环结构，没有终止条件，只能通过break跳出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环嵌套：在循环中再嵌套一个循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><ul><li>数组是一种特殊的对象，用于存储多个数据。</li><li>可以存储不同类型的数据。</li><li>数组的本质是对象，数组的索引是对象的属性名。</li><li>数组的长度是动态的，可以随时增加或删除元素。</li><li>数组的索引是从0开始的。</li><li>数组的最后一个元素的索引是数组长度减1。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> array = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">arr[<span class="number">0</span>]  <span class="comment">// 1</span></span><br><span class="line">arr[<span class="number">1</span>]  <span class="comment">// 2</span></span><br><span class="line">arr[<span class="number">2</span>]  <span class="comment">// 3</span></span><br><span class="line">arr[<span class="number">3</span>]  <span class="comment">// 4</span></span><br><span class="line">arr[<span class="number">4</span>]  <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line">arr.<span class="property">length</span>  <span class="comment">// 5</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">6</span>);  <span class="comment">// 6 这是从数组末尾添加元素 返回数组的新长度</span></span><br><span class="line">arr.<span class="title function_">pop</span>();  <span class="comment">// 5 这是从数组末尾删除元素</span></span><br><span class="line">arr.<span class="title function_">shift</span>();  <span class="comment">// 1 这是从数组开头删除元素</span></span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">0</span>);  <span class="comment">// 0 这是从数组开头添加元素 返回数组的新长度</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 2, 3 这是删除元素，第一个参数是索引，第二个参数是删除的个数</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 1, 2, 3, 2, 3, 4, 5 这是添加元素，第一个参数是索引，第二个参数是删除的个数，后面是添加的元素</span></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">arr.<span class="title function_">sort</span>();  <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line">arr.<span class="title function_">reverse</span>();  <span class="comment">// 5, 4, 3, 2, 1</span></span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数是一段可以重复使用的代码块。</li><li>函数可以接受参数，也可以返回值。</li><li>函数的本质是对象。</li><li>函数的参数是局部变量，只能在函数内部使用。</li><li>函数的返回值是函数执行的结果。<strong>默认返回undefined</strong></li><li>函数的参数可以有默认值。</li><li>函数的参数可以有不定参数。</li><li>函数的参数可以有解构赋值。</li><li>函数的参数可以有剩余参数。</li><li>如果形参和实参个数不一致，多余的实参会被忽略，缺少的实参会被赋值为undefined。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认值，如果没有传入参数，就使用默认值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a = <span class="number">0</span>, b = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>作用域：全局作用域、局部作用域、块级作用域。</li><li><em><strong>作用域链：函数的作用域是嵌套的，内部函数可以访问外部函数的变量，外部函数不能访问内部函数的变量。</strong></em></li><li><em><strong>闭包：函数嵌套函数，内部函数可以访问外部函数的变量，外部函数不能访问内部函数的变量。</strong></em><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="title function_">outer</span>();</span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li>闭包的作用：保护变量、延长变量的生命周期。</li><li>闭包的缺点：内存泄漏，变量无法被释放。</li><li>递归：函数调用自身。</li><li>尾递归：递归调用是函数的最后一步操作。</li><li>递归的缺点：占用内存，调用栈溢出。</li><li><strong>如果函数内部变量没有声明直接赋值，会自动声明为全局变量。（不推荐）</strong></li><li>在能够访问到的情况下先使用局部变量，再使用全局变量。</li></ul><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ul><li>匿名函数没有函数名，可以赋值给变量，也可以作为函数的参数。</li><li>区别：函数声明会提升，匿名函数不会提升。</li><li>避免全局污染。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h4><ul><li>立即执行函数是匿名函数的一种，定义完立即执行。</li><li>避免全局污染。</li><li><strong>必须要加分号</strong></li><li>不需要调用，自动执行。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;)();  </span><br></pre></td></tr></table></figure></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li>箭头函数是匿名函数的简写，可以省略function关键字。</li><li>箭头函数没有this，this指向的是定义时所在的对象，而不是执行时所在的对象。</li><li>箭头函数没有arguments，可以使用剩余参数代替。</li><li>箭头函数没有new.target，不能使用new调用。</li><li>箭头函数没有原型，不能作为构造函数。</li><li>箭头函数不能使用yield命令，不能用作Generator函数。</li><li>箭头函数不能使用call、apply、bind方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="逻辑中断"><a href="#逻辑中断" class="headerlink" title="逻辑中断"></a>逻辑中断</h2><ul><li>&amp;&amp; 逻辑与：都是真，返回最后一个真值；有一个假，返回第一个假值。</li><li>|| 逻辑或：有一个真，返回第一个真值；都是假，返回最后一个假值。</li></ul><h2 id="转换为Boolean型"><a href="#转换为Boolean型" class="headerlink" title="转换为Boolean型"></a>转换为Boolean型</h2><ul><li>0、NaN、null、undefined、空字符串、false转换为false，其他转换为true。</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>对象是一种复合数据类型，可以存储多个数据。</li><li>对象的本质是键值对的集合。</li><li>对象的键是字符串，值可以是任意类型的数据。</li><li>对象的键是唯一的，值可以重复。</li><li>对象的键可以是变量，值可以是变量。</li><li>无序的，不能通过索引访问。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li>对象字面量：<code>let obj = &#123;name: &quot;Tom&quot;, age: 18&#125;;</code></li><li>带有方法的对象：<code>let obj = &#123;name: &quot;Tom&quot;, age: 18, say: function() &#123;console.log(&quot;Hello&quot;)&#125;&#125;;</code></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>查：<code>obj.name</code> &#x2F; <code>obj[&quot;name&quot;]</code></li><li>改：<code>obj.name = &quot;Jerry&quot;</code></li><li>增：<code>obj.hobby=&quot;swim&quot;</code></li><li>删：<code>delete obj.hobby</code>(了解)</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li>for…in 这个是遍历对象的键<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Object.keys() 这个是遍历对象的键<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>Object.values() 这个是遍历对象的值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>Object.entries() 这个是遍历对象的键值对<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>foreach()是数组的方法，是用来遍历数组的，具体用法是：其中item是数组的元素，index是数组的索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item, index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="数学内置对象"><a href="#数学内置对象" class="headerlink" title="数学内置对象"></a>数学内置对象</h3><h4 id="内置对象是什么？"><a href="#内置对象是什么？" class="headerlink" title="内置对象是什么？"></a>内置对象是什么？</h4><ul><li>内置对象是JavaScript自带的对象，不需要引入，可以直接使用。</li><li>内置对象有很多种，比如Math、Date、RegExp等。</li><li>内置对象是全局对象的属性，可以直接使用。</li></ul><h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><ul><li>Math对象是数学内置对象，提供了很多数学方法。</li><li>Math对象的方法是静态方法，直接通过Math调用。</li><li>比如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">PI</span>  <span class="comment">// 3.141592653589793</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(-<span class="number">10</span>)  <span class="comment">// 10 绝对值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">3.1</span>)  <span class="comment">// 4 向上取整</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">3.9</span>)  <span class="comment">// 3 向下取整</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">3.5</span>)  <span class="comment">// 4 四舍五入</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment">// 5 最大值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment">// 1 最小值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// 8 2的3次方</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">9</span>)  <span class="comment">// 3 开平方</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>()  <span class="comment">// 0-1之间的随机数</span></span><br><span class="line"><span class="comment">// m和n之间的随机数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">random</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (n - m + <span class="number">1</span>) + m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他数据结构"><a href="#其他数据结构" class="headerlink" title="其他数据结构"></a>其他数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>Set是一种数据结构，类似于数组，但是成员的值是唯一的。</li><li>Set的本质是对象，不是数组。</li><li>Set的成员是无序的，不能通过索引访问。</li><li>详细用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 通过数组创建</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">6</span>); <span class="comment">// 添加元素</span></span><br><span class="line">set.<span class="title function_">delete</span>(<span class="number">6</span>); <span class="comment">// 删除元素</span></span><br><span class="line">set.<span class="title function_">has</span>(<span class="number">6</span>); <span class="comment">// 判断是否存在</span></span><br><span class="line">set.<span class="title function_">clear</span>(); <span class="comment">// 清空元素</span></span><br><span class="line">set.<span class="property">size</span>; <span class="comment">// 元素个数</span></span><br></pre></td></tr></table></figure></li><li>遍历：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>Map是一种数据结构，类似于对象，但是键可以是任意类型的数据。</li><li>Map的本质是对象，不是数组。</li><li>Map的成员是有序的，可以通过键访问。</li><li>详细用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>], [<span class="number">2</span>, <span class="string">&quot;Jerry&quot;</span>]]); <span class="comment">// 通过数组创建</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="number">1</span>); <span class="comment">// Tom 通过键获取值</span></span><br><span class="line">map.<span class="title function_">entries</span>(); <span class="comment">// 返回键值对</span></span><br><span class="line">map.<span class="title function_">keys</span>(); <span class="comment">// 返回键</span></span><br><span class="line">map.<span class="title function_">values</span>(); <span class="comment">// 返回值</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&quot;Spike&quot;</span>); <span class="comment">// 添加元素</span></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">3</span>); <span class="comment">// 删除元素</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="number">3</span>); <span class="comment">// 判断是否存在</span></span><br><span class="line">map.<span class="title function_">clear</span>(); <span class="comment">// 清空元素</span></span><br><span class="line">map.<span class="property">size</span>; <span class="comment">// 元素个数</span></span><br></pre></td></tr></table></figure></li><li>遍历：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>引用数据类型：对象、数组、函数、Set、Map等。<br>简单数据类型放在栈内存，引用数据类型在栈内存中存储地址，堆内存中存储数据。</p><p><strong>如果一个对象定义了一个叫[Symbol.iterator]的方法，那么这个对象就是一个迭代器。比如数组、字符串、Set、Map等。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript异步编程</title>
      <link href="/2025/03/03/jsasync/"/>
      <url>/2025/03/03/jsasync/</url>
      
        <content type="html"><![CDATA[<h2 id="📌-1-JavaScript-为什么需要异步？"><a href="#📌-1-JavaScript-为什么需要异步？" class="headerlink" title="📌 1. JavaScript 为什么需要异步？"></a>📌 1. JavaScript 为什么需要异步？</h2><p>JavaScript 是 单线程（Single-threaded）语言，它的执行方式是<strong>逐行执行</strong>，但有时候代码的执行可能会遇到等待：</p><ul><li>你去点咖啡（等待制作）。</li><li>你从服务器请求数据（等待网络）。</li><li>你读取一个文件（等待磁盘）。</li></ul><p>如果JavaScript只能同步执行，遇到等待时，整个程序都会卡住，无法继续执行。为了解决这个问题，JavaScript引入了<strong>异步编程</strong>。</p><h2 id="📌-2-回调函数（Callback）——-传统异步"><a href="#📌-2-回调函数（Callback）——-传统异步" class="headerlink" title="📌 2. 回调函数（Callback）—— 传统异步"></a>📌 2. 回调函数（Callback）—— 传统异步</h2><p>最原始的异步方案是回调函数（callback），即当任务完成时，调用一个函数来处理结果。</p><h3 id="💡-例子：回调函数点咖啡"><a href="#💡-例子：回调函数点咖啡" class="headerlink" title="💡 例子：回调函数点咖啡"></a>💡 例子：回调函数点咖啡</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">orderCoffee</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始制作咖啡...&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;咖啡制作完成 ☕&quot;</span>);</span><br><span class="line">        <span class="title function_">callback</span>(<span class="string">&quot;☕ 咖啡&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">orderCoffee</span>(<span class="function"><span class="params">coffee</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 你拿到了:&quot;</span>, coffee);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>📌 运行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始制作咖啡...</span><br><span class="line">（<span class="number">2</span> 秒后）</span><br><span class="line">咖啡制作完成 ☕</span><br><span class="line">✅ 你拿到了: ☕ 咖啡</span><br></pre></td></tr></table></figure><h3 id="🔹-回调的缺点"><a href="#🔹-回调的缺点" class="headerlink" title="🔹 回调的缺点"></a>🔹 回调的缺点</h3><ol><li>   回调地狱（Callback Hell）：<ul><li>如果有多个步骤（如：点咖啡 → 加糖 → 加奶），代码会变得嵌套很多层，难以维护。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">orderCoffee</span>(<span class="function"><span class="params">coffee</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">addSugar</span>(coffee, <span class="function"><span class="params">sugaredCoffee</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">addMilk</span>(sugaredCoffee, <span class="function"><span class="params">finalCoffee</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 你的最终咖啡:&quot;</span>, finalCoffee);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>   可读性差，难以调试。</li></ol><h2 id="📌-3-事件循环（Event-Loop）——-JavaScript-异步的核心"><a href="#📌-3-事件循环（Event-Loop）——-JavaScript-异步的核心" class="headerlink" title="📌 3. 事件循环（Event Loop）—— JavaScript 异步的核心"></a>📌 3. 事件循环（Event Loop）—— JavaScript 异步的核心</h2><p>JavaScript 的 异步任务（如 setTimeout()、Promise、fetch）不是立即执行的，而是放入任务队列，等主线程（同步任务）完成后再执行。这就是事件循环（Event Loop）的工作方式。</p><h3 id="💡-事件循环的运作"><a href="#💡-事件循环的运作" class="headerlink" title="💡 事件循环的运作"></a>💡 事件循环的运作</h3><ol><li>   JavaScript代码会先执行同步任务（如变量声明、函数调用）。</li><li>   遇到异步任务（如 setTimeout()），它会交给浏览器（WebAPI）执行，完成后将回调函数放入任务队列。</li><li>   当主线程空闲时，事件循环（Event Loop）会把任务队列里的任务放入主线程执行。</li></ol><h3 id="💡-例子：事件循环"><a href="#💡-例子：事件循环" class="headerlink" title="💡 例子：事件循环"></a>💡 例子：事件循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1. 我先来杯咖啡&quot;</span>);  <span class="comment">// 同步任务</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3. 咖啡做好了 ☕&quot;</span>);  <span class="comment">// 异步任务</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2. 先看看手机等咖啡&quot;</span>);  <span class="comment">// 同步任务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📌 执行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 我先来杯咖啡</span><br><span class="line"><span class="number">2.</span> 先看看手机等咖啡</span><br><span class="line">（<span class="number">2</span> 秒后）</span><br><span class="line"><span class="number">3.</span> 咖啡做好了 ☕</span><br></pre></td></tr></table></figure><h2 id="📌-4-Promise——-解决回调地狱"><a href="#📌-4-Promise——-解决回调地狱" class="headerlink" title="📌 4. Promise—— 解决回调地狱"></a>📌 4. Promise—— 解决回调地狱</h2><p>Promise 是 异步任务的容器，它有三种状态：</p><ul><li>pending（等待中）</li><li>fulfilled（已完成）</li><li>rejected（已拒绝）</li></ul><h3 id="💡-例子：用-Promise-处理点咖啡"><a href="#💡-例子：用-Promise-处理点咖啡" class="headerlink" title="💡 例子：用 Promise 处理点咖啡"></a>💡 例子：用 Promise 处理点咖啡</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">orderCoffee</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始制作咖啡...&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;☕ 咖啡&quot;</span>);  <span class="comment">// 成功</span></span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">orderCoffee</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">coffee</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 你拿到了:&quot;</span>, coffee);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;❌ 失败:&quot;</span>, error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>📌 执行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始制作咖啡...</span><br><span class="line">（<span class="number">2</span> 秒后）</span><br><span class="line">✅ 你拿到了: ☕ 咖啡</span><br></pre></td></tr></table></figure><h3 id="Promise-的优势："><a href="#Promise-的优势：" class="headerlink" title="Promise 的优势："></a>Promise 的优势：</h3><ul><li>链式调用，比回调函数更清晰。</li><li>错误处理更优雅，可以用 .catch()。</li></ul><h2 id="📌-5-async-await——-最清晰的异步写法"><a href="#📌-5-async-await——-最清晰的异步写法" class="headerlink" title="📌 5. async&#x2F;await—— 最清晰的异步写法"></a>📌 5. async&#x2F;await—— 最清晰的异步写法</h2><p><strong>async&#x2F;await</strong>是Promise的语法糖，让代码更像同步代码。</p><h3 id="💡-例子：async-await-版的点咖啡"><a href="#💡-例子：async-await-版的点咖啡" class="headerlink" title="💡 例子：async&#x2F;await 版的点咖啡"></a>💡 例子：async&#x2F;await 版的点咖啡</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">orderCoffee</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始制作咖啡...&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;☕ 咖啡&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getCoffee</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我点了一杯咖啡...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> coffee = <span class="keyword">await</span> <span class="title function_">orderCoffee</span>();  <span class="comment">// 等待咖啡完成</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 我拿到了:&quot;</span>, coffee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getCoffee</span>();</span><br></pre></td></tr></table></figure><p>📌 执行顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我点了一杯咖啡...</span><br><span class="line">开始制作咖啡...</span><br><span class="line">（2 秒后）</span><br><span class="line">✅ 我拿到了: ☕ 咖啡</span><br></pre></td></tr></table></figure><p>为什么async&#x2F;await更好？</p><ul><li>代码更直观，没有 .then() 链式调用。</li><li>结构更清晰，像同步代码一样易读。</li></ul><h2 id="📌-6-Promise-all-和-Promise-race"><a href="#📌-6-Promise-all-和-Promise-race" class="headerlink" title="📌 6. Promise.all() 和 Promise.race()"></a>📌 6. Promise.all() 和 Promise.race()</h2><h3 id="🔹-Promise-all-——-并行执行"><a href="#🔹-Promise-all-——-并行执行" class="headerlink" title="🔹 Promise.all() —— 并行执行"></a>🔹 Promise.all() —— 并行执行</h3><p>如果你同时点 咖啡、蛋糕、面包，可以用 Promise.all() 并行执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> coffee = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;☕ 咖啡&quot;</span>), <span class="number">2000</span>));</span><br><span class="line"><span class="keyword">const</span> cake = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;🍰 蛋糕&quot;</span>), <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">const</span> bread = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;🥪 面包&quot;</span>), <span class="number">1500</span>));</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([coffee, cake, bread])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 早餐准备好啦:&quot;</span>, results));</span><br></pre></td></tr></table></figure><p>📌 输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">✅ 早餐准备好啦: [<span class="string">&quot;☕ 咖啡&quot;</span>, <span class="string">&quot;🍰 蛋糕&quot;</span>, <span class="string">&quot;🥪 面包&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="🔹-Promise-race-——-谁先完成返回谁"><a href="#🔹-Promise-race-——-谁先完成返回谁" class="headerlink" title="🔹 Promise.race() —— 谁先完成返回谁"></a>🔹 Promise.race() —— 谁先完成返回谁</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([coffee, cake, bread])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;✅ 最快的食物是:&quot;</span>, result));</span><br></pre></td></tr></table></figure><p>📌 输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">✅ 最快的食物是: 🥪 面包</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是一棵小树🌳</title>
      <link href="/2024/12/11/tree/"/>
      <url>/2024/12/11/tree/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的遍历（非递归）"><a href="#二叉树的遍历（非递归）" class="headerlink" title="二叉树的遍历（非递归）"></a>二叉树的遍历（非递归）</h3><ul><li><p>前序遍历<br>基本思路是把根节点入栈，然后出栈并访问，接着把右子节点入栈，最后把左子节点入栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) stack.push(node.right); <span class="comment">// 右子节点先入栈</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) stack.push(node.left);   <span class="comment">// 左子节点后入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历<br>基本思路就是从根开始把左子节点都入栈，当没有左子节点时，出栈并访问右子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;            <span class="comment">// 左子节点依次入栈</span></span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = stack.pop();               <span class="comment">// 访问栈顶节点</span></span><br><span class="line">        System.out.print(curr.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        curr = curr.right;                <span class="comment">// 转向右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历<br>后序遍历的顺序是左右根，而前序遍历的顺序是根左右，所以可以先按照根右左的顺序遍历，然后再逆序输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrderIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; output = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        output.push(node);                <span class="comment">// 根节点先入辅助栈</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) stack.push(node.left);   <span class="comment">// 左子节点入栈</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) stack.push(node.right); <span class="comment">// 右子节点入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!output.isEmpty()) &#123;</span><br><span class="line">        System.out.print(output.pop().val + <span class="string">&quot; &quot;</span>);       <span class="comment">// 按后序输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>层序遍历<br>层级遍历需要借助队列，先把根节点入队，然后出队并访问，接着把左右子节点入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.offer(node.left);  <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.offer(node.right); <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>做了一道<strong>leecode102</strong>题，也是层序遍历，但是要返回的是[[3],[9,20],[15,7]]这种把每一层的点再包在一个list中的形式。<br>这个时候就需要在每一层遍历的时候，记录下当前层的节点个数（也就是此时队列的长度），然后再遍历这个个数的节点，把他们的值加入到一个list中，最后再把这个list加入到结果中。</p><h3 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h3><p>二叉搜索树是一种特殊的二叉树，对于每个节点，其左子树上的所有节点的值都小于根节点的值，右子树上的所有节点的值都大于根节点的值。</p><p><strong>leecode98题</strong>验证二叉搜索树，我太想当然把二叉搜索树当成左孩子小于当前节点，右孩子大于当前节点了。。<br>应该是左子树的所有节点值都必须小于当前节点值，而右子树的所有节点值都必须大于当前节点值。在调用递归的时候应该判断的是左节点和右节点<strong>在一个区域low和high之间</strong>。对于左节点，应该更新他的最大值high为当前节点的值，而对于右节点，应该更新他的最小值low为当前节点的值。</p><p>还有一种办法是用中序遍历的方式。根据二叉搜索树的性质可知，二叉搜索树<strong>中序遍历</strong>得到的值构成的序列一定是升序的。所以我们可以在中序遍历的时候检查当前节点的值是否大于前一个中序遍历的节点的值即可。</p><p><strong>leecode96题</strong>不同的二叉搜索树。这道题是求1到n这n个数能组成多少种不同的二叉搜索树。这道题的思路是，对于每个节点i，以i为根节点的二叉搜索树的数量是左子树的数量乘以右子树的数量。<br>所以可以用<strong>动态规划</strong>的方法，dp[i]表示1到i这i个数能组成的不同二叉搜索树的数量。对于每个i，我们可以把1到i中的每个数都作为根节点，然后分别计算左子树和右子树的数量，然后相乘即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] G = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; G.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>动态规划的核心思想是将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。动态规划的实现通常是自底向上的，即先解决子问题，再逐步解决原问题。</p></blockquote><p><strong>leecode95题</strong>是按任意顺序返回二叉搜索树，不想做。。有时间记得看看。。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程</title>
      <link href="/2024/12/11/netprogram/"/>
      <url>/2024/12/11/netprogram/</url>
      
        <content type="html"><![CDATA[<p>无论是 Web 服务器处理网页请求、即时通讯工具的消息传递，还是在线游戏的数据同步，都离不开 Socket 的支持。Socket 的本质，是将复杂的网络通信抽象成一个简单的接口，让开发者可以通过像操作文件一样的方式实现数据的收发。这也是”Unix中万物皆文件”。本文将以 TCP Socket 编程为例，逐步拆解从服务器端到客户端的交互过程，解析系统调用的作用，建立清晰的理解框架。</p><h2 id="什么是-Socket？"><a href="#什么是-Socket？" class="headerlink" title="什么是 Socket？"></a>什么是 Socket？</h2><p>Socket 提供了一种通信的端点，就像电器与电源的插座。通过 Socket，两个设备之间可以建立通信链接。<br>程序员只需要按照 Socket 提供的接口进行操作，不需要关心底层的复杂网络协议。</p><p>Socket 的现代实现被称为 Berkeley Sockets，因为它起源于 Berkeley Unix（BSD Unix）中，是基于 Unix 操作系统设计的。Berkeley Sockets 的出现奠定了今天网络编程的基础。</p><ul><li>在Web浏览器与Web服务器通信：浏览器通过 Socket 向服务器发送 HTTP 请求，服务器通过 Socket 返回 HTTP 响应。</li><li>在即时通讯工具中传递消息：客户端通过 Socket 向服务器发送消息，服务器通过 Socket 将消息推送给其他客户端。</li><li>在在线游戏中同步数据：客户端通过 Socket 向服务器发送操作指令，服务器通过 Socket 将操作结果推送给其他客户端。</li></ul><h2 id="工作原理，怎么打电话？"><a href="#工作原理，怎么打电话？" class="headerlink" title="工作原理，怎么打电话？"></a>工作原理，怎么打电话？</h2><ul><li>首先，我们需要一个电话，也就是创建一个 Socket 对象。</li><li>如果想给朋友打电话，首先要知道朋友的电话号码。Socket 通信也是一样，需要知道对方的 IP 地址和端口号。<blockquote><p>IP类似于大楼的地址，而Socket端口号类似于房间号。即我们通过IP地址实现主机到主机的通信，通过端口号实现主机内的进程到进程的通信。</p></blockquote></li><li>打通电话后，可以开始通话。你说一句话（发送数据），对方听到并回复（接收数据）。Socket 通信也是一样，建立连接后，可以开始传输数据。</li><li>通话结束后，挂断电话。Socket通信结束后，关闭 Socket。</li></ul><h2 id="TCP与UDP，就像是打电话和写信"><a href="#TCP与UDP，就像是打电话和写信" class="headerlink" title="TCP与UDP，就像是打电话和写信"></a>TCP与UDP，就像是打电话和写信</h2><p>Socket 通信可以基于两种协议：TCP 和 UDP。TCP需要建立连接，而UDP不需要建立连接。</p><ul><li><strong>TCP（Transmission Control Protocol）</strong>：面向连接的协议，提供可靠的数据传输。TCP 保证数据的顺序和完整性，适用于要求数据准确无误的场景（网页、聊天、文件传输）。</li><li><strong>UDP（User Datagram Protocol）</strong>：面向无连接的协议，提供高效的数据传输。UDP 不保证数据的顺序和完整性，适用于实时性要求高的场景（在线游戏、直播）。</li></ul><h2 id="TCP-Socket通信模型"><a href="#TCP-Socket通信模型" class="headerlink" title="TCP Socket通信模型"></a>TCP Socket通信模型</h2><h3 id="TCP-Socket-通信模型是一种客户端-服务器模型。"><a href="#TCP-Socket-通信模型是一种客户端-服务器模型。" class="headerlink" title="TCP Socket 通信模型是一种客户端-服务器模型。"></a>TCP Socket 通信模型是一种客户端-服务器模型。</h3><ul><li><strong>服务器（Server）</strong>：被叫方（接线员）随时准备接电话。在程序中表示为一个服务器进程，而不是硬件服务器。</li><li><strong>客户端（Client）</strong>：主动拨打电话。在程序中表示为一个客户端进程。</li></ul><h3 id="双工文件描述符"><a href="#双工文件描述符" class="headerlink" title="双工文件描述符"></a>双工文件描述符</h3><p>使用TCP Socket进行通信后，客户端和服务器各自都会获得一个文件描述符，这使得网络通信就像在操作文件。<br>写操作即是发送字节给对方，而读操作就是接受对方发送的字节。</p><blockquote><p>文件描述符是操作系统中对文件的引用，是一个非负整数。在Linux系统中，文件描述符0、1、2分别对应标准输入、标准输出和标准错误。<br>每次打开一个文件或资源，操作系统都会返回一个文件描述符，用于后续对文件的操作。</p></blockquote><h3 id="TCP服务器系统调用过程"><a href="#TCP服务器系统调用过程" class="headerlink" title="TCP服务器系统调用过程"></a>TCP服务器系统调用过程</h3><p><img src="/images/linux/net_map.png" alt="模型"></p><ul><li>socket() <font color="pink" weigh="bold">–准备好电话啦☎️</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建服务器的 Socket</span></span><br><span class="line"><span class="comment">// socket() 函数创建一个 Socket，返回一个文件描述符</span></span><br><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// - AF_INET: 表示使用 IPv4,AF_INET6 表示 IPv6</span></span><br><span class="line"><span class="comment">// - SOCK_STREAM: 表示使用 TCP（流式传输）.SOCK_DGRAM 表示 UDP（数据报传输）</span></span><br><span class="line"><span class="comment">// - 0: 默认协议（通常是 TCP）</span></span><br><span class="line">server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (server_fd == <span class="number">-1</span>) &#123;               <span class="comment">// 如果返回 -1，表示创建失败</span></span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);                <span class="comment">// 打印错误信息</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);              <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置服务器地址</span></span><br><span class="line">server_addr.sin_family = AF_INET;    <span class="comment">// 地址族，AF_INET 表示 IPv4</span></span><br><span class="line">server_addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 监听所有网络接口（本机 IP）</span></span><br><span class="line">server_addr.sin_port = htons(PORT); <span class="comment">// 将端口号转换为网络字节序</span></span><br></pre></td></tr></table></figure>上述代码除了创建服务器的socket外，还对服务器地址进行了配置。配置过程的主要任务就是告诉操作系统，使用哪种地址类型，绑定到哪个IP地址和端口号。<br>而这些信息都存储在struct sockaddr_in结构体中，通过该结构体的成员变量进行配置。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;   <span class="comment">// 地址族 (AF_INET 表示 IPv4)</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;       <span class="comment">// 16 位端口号（网络字节序）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>  <span class="comment">// IPv4 地址</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];         <span class="comment">// 填充字段，保持与 struct sockaddr 大小一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在配置IP地址时用到了INADDR_ANY，它表示监听所有网络接口，即服务器将接受来自任何网络接口的连接请求。<blockquote><p>网络接口是连接设备和网络的桥梁，每个接口可以有自己的IP地址，例如有线网卡、无线网卡等。一台服务器可能有多个网络接口，一个连接到内网，一个连接到外网。所以一台服务器可能有多个IP地址。<br>INADDR_ANY表示监听所有网络接口，而INADDR_LOOPBACK表示监听本地回环接口，即只接受来自本机的连接请求。</p></blockquote></li></ul><p>在配置端口号时，使用了htons()函数将端口号转换为网络字节序。网络字节序是大端字节序，即高位字节存储在低地址，低位字节存储在高地址。</p><ul><li><p>bind() <font color="pink" weigh="bold">给电话装上号码📞</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 绑定地址到服务器的 Socket</span></span><br><span class="line"><span class="comment">// bind() 函数将服务器地址绑定到服务器 Socket</span></span><br><span class="line"><span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind&quot;</span>);                  <span class="comment">// 如果失败，打印错误信息</span></span><br><span class="line">    close(server_fd);                <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);              <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>listen() <font color="pink" weigh="bold">准备接听来电🤭</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 开始监听端口</span></span><br><span class="line"><span class="comment">// listen() 函数使服务器进入监听状态，准备接受连接</span></span><br><span class="line"><span class="comment">// 第二个参数指定连接队列的最大长度（这里为 5）</span></span><br><span class="line"><span class="keyword">if</span> (listen(server_fd, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;listen&quot;</span>);                <span class="comment">// 如果失败，打印错误信息</span></span><br><span class="line">    close(server_fd);                <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);              <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server is listening on port %d...\n&quot;</span>, PORT);</span><br></pre></td></tr></table></figure></li><li><p>accept() <font color="pink" weigh="bold">电话接通了🤩</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 接受客户端连接</span></span><br><span class="line"><span class="comment">// accept() 函数等待客户端连接，成功后返回一个新的文件描述符（用于与客户端通信）</span></span><br><span class="line">client_fd = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line"><span class="keyword">if</span> (client_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;accept&quot;</span>);                <span class="comment">// 如果失败，打印错误信息</span></span><br><span class="line">    close(server_fd);                <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);              <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client connected!\n&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>(struct sockaddr *)&amp;client_addr的含义<br>在网络编程中，许多函数（如 bind() 和 connect()）需要传递地址参数，类型为 struct sockaddr *，而不是 struct sockaddr_in *。<br>struct sockaddr 是一个通用的地址结构，可以表示多种类型的地址（IPv4、IPv6 等）。 struct sockaddr_in 是 IPv4 专用的地址结构。<br>函数要求地址参数的类型为 struct sockaddr *，以便支持多种协议。<br>为了解决这个问题，可以使用类型转换将 struct sockaddr_in * 转换为 struct sockaddr *，这样就可以传递给函数了。</p></blockquote></li></ul><p>accept()函数会阻塞等待客户端连接，一旦有客户端连接，就会返回一个新的文件描述符，用于与客户端通信。<br>这两个文件描述符各司其职，server_fd用于监听客户端连接，而client_fd用于与客户端通信。</p><ul><li><p>read() write() <font color="pink" weigh="bold">通话中…🤔</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6. 接收客户端发送的消息</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);      <span class="comment">// 清空缓冲区</span></span><br><span class="line">read(client_fd, buffer, BUFFER_SIZE); <span class="comment">// 从客户端接收数据，存入缓冲区</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client says: %s\n&quot;</span>, buffer); <span class="comment">// 打印接收到的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 回复客户端</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *response = <span class="string">&quot;Hello from server!&quot;</span>;</span><br><span class="line">write(client_fd, response, <span class="built_in">strlen</span>(response));  <span class="comment">// 将消息发送给客户端</span></span><br></pre></td></tr></table></figure></li><li><p>close() <font color="pink" weigh="bold">挂断电话👋</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8. 关闭文件描述符</span></span><br><span class="line">close(client_fd);                    <span class="comment">// 关闭客户端文件描述符</span></span><br><span class="line">close(server_fd);                    <span class="comment">// 关闭服务器文件描述符</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="TCP客户端系统调用过程"><a href="#TCP客户端系统调用过程" class="headerlink" title="TCP客户端系统调用过程"></a>TCP客户端系统调用过程</h3><p>对于客户端呢，和TCP服务器一样，都要先准备电话，所以socket系统调用与TCP服务器是完全一致的。<br>客户端要想连接服务器，不需要限定自己的IP地址和端口号，只需要知道服务器的IP地址和端口号即可。</p><blockquote><p>IPv4的地址是32位的，通常用点分十进制表示，例如本机回送地址是”127.0.0.1”‘,如果用32位整数表示，就是0x7F000001。十进制就是127<em>256^3+0</em>256^2+0*256+1&#x3D;2130706433。<br>为了方便，我们可以使用inet_addr库函数将点分十进制的IP地址转换为网络字节序的整数。</p></blockquote><p>connect()的调用格式与bind很类似，但是connect后的文件描述符不是通过返回值获得的，而是通过参数sockfd传递的。connect成功后，通过read&#x2F;write操作文件描述符socket就可以与服务器通信了。通信结束后，<br>同样通过close()关闭文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="comment">// connect() 函数尝试连接服务器</span></span><br><span class="line"><span class="keyword">if</span> (connect(sock_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;connect&quot;</span>);            <span class="comment">// 如果失败，打印错误信息</span></span><br><span class="line">    close(sock_fd);               <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);           <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Connected to server!\n&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件项目管理课程</title>
      <link href="/2024/10/17/ManagementCourse/"/>
      <url>/2024/10/17/ManagementCourse/</url>
      
        <content type="html"><![CDATA[<h1 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h1><h2 id="（一）项目管理的定义"><a href="#（一）项目管理的定义" class="headerlink" title="（一）项目管理的定义"></a>（一）项目管理的定义</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>a temporary endeavor undertaken to create a unique product, service, or result.<br>（一个临时性的工作，为了创造一个独特的产品、服务或结果） </p><h3 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h3><ul><li>过程上，临时性的有时限性、不确定性、逐步精化</li><li>输入：特定目的    输出：推动变革创造价值</li><li>投入上，有发起人、需要资源、有经理人</li></ul><h3 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h3><p>成功的项目意味着满足三个目标：Scope goal、Time goal、Cost goal 并让发起者满意</p><h3 id="项目约束"><a href="#项目约束" class="headerlink" title="项目约束"></a>项目约束</h3><ul><li>六个约束：成本、风险、资源、质量、时间、范围（Cost, Risk, Resource, Quality, Time, Scope） </li><li>怎么平衡约束？<br><img src="/images/manage/img.png" alt="img.png"></li></ul><h3 id="项目群管理"><a href="#项目群管理" class="headerlink" title="项目群管理"></a>项目群管理</h3><ul><li>项目群：一组相互关联的项目，被协调和管理以获得更好的效益，这些效益单独管理项目无法获得</li><li>将项目合并为组，有助于管理、招聘员工、采购以及其他工作快捷化，而且要经济些。</li></ul><h3 id="项目组合管理"><a href="#项目组合管理" class="headerlink" title="项目组合管理"></a>项目组合管理</h3><ul><li>项目组合：一组项目、子项目、项目群、子项目群、以及运营工作，被协调和管理以实现一些特定的战略目标</li></ul><blockquote><p><em><strong>项目Projects、项目群Programs、项目组合Portfolios归纳</strong></em></p><p>定义上，</p><ul><li>项目：一个临时性的工作，为了创造一个独特的产品、服务或结果</li><li>项目群：一组相互关联的项目，被协调和管理以获得更好的效益</li><li>项目组合：组织将项目以及项目群合并进行管理，使其作为一个投资组合，从而促成整个企业的成功。</li></ul><p>管理上，</p><ul><li>项目管理：项目经理管理项目团队以满足项目要求目标。</li><li>项目群管理：项目群经理通过协调项目群各个组成部分的活动，确保项目效益按预期达成。</li><li>项目组合管理：组合管理者可以管理或协调组合管理、项目群或项目工作人员，从战略视角帮助组织挑选并分析项目，帮助组织做出明智的投资决策。</li></ul><p>监控上，</p><ul><li>项目监控：项目经理监督和控制生产产品、服务或成果所需的工作。</li><li>项目群监控：项目群经理监督项目群各个组成部分的进度，以确保项目群的总体目标、进度、预算和效益得到满足。</li><li>项目组合监控：组合经理监控投资组合的战略变化和聚集资源分配、绩效结果和风险。</li></ul><p>成功上，</p><ul><li>项目：成功与否取决于项目的质量、及时性、预算合规性和客户满意度</li><li>项目群：项目向组织提供其预期利益的能力，以及项目提供这些利益的效率和有效性。</li><li>项目组合：投资组合的成功</li></ul></blockquote><h3 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h3><ul><li>SPM工具集：综合工具、任务管理、缺陷跟踪、代码管理、团队协作、进度管理、文档管理、原型设计</li></ul><h2 id="（二）确定范围"><a href="#（二）确定范围" class="headerlink" title="（二）确定范围"></a>（二）确定范围</h2><h3 id="范围管理概念"><a href="#范围管理概念" class="headerlink" title="范围管理概念"></a>范围管理概念</h3><ul><li>界定和控制项目中应包括什么和不包括什么所涉及的过程，该过程确保了项目团队和干系人对项目的可交付成果以及生成这些可交付成果所进行的工作达成共识。</li></ul><h3 id="组域映射"><a href="#组域映射" class="headerlink" title="组域映射"></a>组域映射</h3><ul><li>五大过程组：启动Initiating、规划Planning、执行Executing、监控与控制Monitoring and Controlling、收尾Closing</li><li>五大过程组和范围管理知识域的映射：</li></ul><p>规划Planning上：</p><ol><li><p>规划范围管理：计划如何在整个项目的生命周期内管理范围</p><p> <strong>输入</strong>：项目章程、项目管理计划（质量管理计划、项目生命周期描述、开发方法）、事业环境因素、组织过程资产</p><p> <strong>工具与技术</strong>：专家判断、数据分析（备选方案分析）、会议</p><p> <strong>输出</strong>：范围管理计划、需求管理计划</p></li><li><p>收集需求；定义并记录产品的特点和功能，以及开发过程<br><img src="/images/manage/img_1.png" alt="/images/manage/img_1.png"></p></li><li><p>定义范围：审查范管计划等，指定和维护范管说明书<br><img src="/images/manage/img_2.png" alt="/images/manage/img_2.png"><br><img src="/images/manage/img_3.png" alt="/images/manage/img_3.png"></p></li><li><p>创建WBS： 将可交付成果分解为更细小和更易管理的部分<br><img src="/images/manage/img_4.png" alt="/images/manage/img_4.png"></p></li></ol><p>监控Monitoring and Controlling上：</p><ol><li>确认范围：可交付成果的正式验收<br><img src="/images/manage/img_5.png" alt="/images/manage/img_5.png"></li><li>控制范围： 对项目范围的变化进行控制<br><img src="/images/manage/img_6.png" alt="/images/manage/img_6.png"></li></ol><h3 id="WBS工作分解结构-Work-Breakdown-Structure"><a href="#WBS工作分解结构-Work-Breakdown-Structure" class="headerlink" title="WBS工作分解结构 Work Breakdown Structure"></a>WBS工作分解结构 Work Breakdown Structure</h3><ul><li>WBS是把项目细分为更小的、更易于管理的组成部分的一个层级结构。每向下一个层级，就是对项目工作更详细的定义。</li><li>优点：<img src="/images/manage/img_7.png" alt="/images/manage/img_7.png"><br><img src="/images/manage/img_8.png" alt="/images/manage/img_8.png"></li><li>WBS的标志、编码、组件、工作包和要素</li><li>特殊组件：项目管理（第2层级），计划管理、风险管理…（第3层级）</li><li>WBS的分解粒度（何时停止分解?）<ul><li>基于目前的分解程度，可以把这个组件分配给一个人吗？</li><li>团队能够合理估算这个组件的成本和工期吗？</li><li>团队能够确认完成本组件所需的活动和里程碑吗？</li><li>我能够有效监控与本组件有关的工作吗？</li></ul></li><li>常用编排方法：<ul><li>按主要交付成果 ： 调研总结、项目管理、软件评估、评估报表</li><li>按项目阶段 ： 图景、路线、原型、产品、上线、项目管理</li><li>按子项目 ： 桌面工具、Web网站、SaaS服务平台、项目管理</li><li>按地理位置 ： 南京、西安、杭州、沈阳</li><li>按部门 ： 软件开发1部、软件开发2部、基础软件事业部、项目管理中心</li><li>其他方法 ：综合法、使用指南、类比法、自上而下法、自下而上法、思维导图法</li></ul></li><li>样式：树形图、大纲式、表格式<br><img src="/images/manage/img_9.png" alt="/images/manage/img_9.png"></li><li>词典：WBS词典是WBS的一个附录，包含了每个WBS组件的详细描述</li><li>工具：WBS Chart Pro、VP、思维导图、办公软件（WPS、Visio、Project、Excel）</li><li>建议：一个工作单元仅出现一次、工作内容是下一级工作内容的总和、一个负责人、与实际一致、成员参与一致认同、记录词典精确描述、灵活变通</li><li>WBS是对项目工作的分解或划分，以便更好的界定、沟通和管理项目的工作范围，向干系人展示了即将开展的项目工作全景图</li><li>不是我们必须做什么也不是该怎样或何时交付，而是必须交付什么。不是活动清单、不是进度安排、而是范围工具</li><li>什么是范围？ 范围是指项目的工作内容，包括项目的产品和服务，以及项目的过程</li></ul><h2 id="（三）故事地图"><a href="#（三）故事地图" class="headerlink" title="（三）故事地图"></a>（三）故事地图</h2><h3 id="识别目标"><a href="#识别目标" class="headerlink" title="识别目标"></a>识别目标</h3><ul><li>故事地图目标<ul><li>Scrum Process Canvas入口</li><li>3个层次<ul><li>用例：高级业务目标，了解整个系统的范围，基于所识别的用例发现Epics</li><li>Epics：高级功能或广泛定义的要求，可以分解成更小的部分，称为用户故事</li><li>用户故事：简短陈述，记录了要求和所需的最终用功能。</li></ul></li></ul></li><li>绘制用例图、定义用例<br><em><strong>用例图和故事地图目标的关系？</strong></em></li><li>管理Epics–Scrum Process Canvas入口、在故事地图中添加更新Epics<ul><li>用户故事地图显示用例，Epics和用户故事之间的映射</li></ul></li></ul><h3 id="管理Backlog-Scrum-Process-Canvas入口"><a href="#管理Backlog-Scrum-Process-Canvas入口" class="headerlink" title="管理Backlog -Scrum Process Canvas入口"></a>管理Backlog -Scrum Process Canvas入口</h3><blockquote><p>backlog,在其中按照优先级列出所要实现的场景和具体功能，是一个项目的需求清单<br>每个用户故事地图代表是一个完整的用户故事，地图的核心是一条从左到右的时间线<br>时间线的上部放置最大粒度内容（可以理解为Epic）<br>时间线的下部的第一行放置二级粒度内容（可以理解为backlog item）<br>并在每一个粒度下按照从左到右的优先级进行放置<br>每个二级粒度内容的下面，自上而下放置三级粒度内容（可以理解为task）</p></blockquote><ul><li>定义：Backlog，待办事项，是Scrum团队定义用户故事来管理积压的工作，通过创建和详细说明项目的用户故事，来构建和维护产品待办事项<br>用户故事准备好了，才可以包含在sprint backlog中以供进一步开发<blockquote><p>sprint: 冲刺周期，通俗的地讲就是实现一个小目标的周期，一个sprint可以包含若干user story<br>task:由user story拆分成的具体开发任务</p></blockquote></li><li>定义适用于所有用户故事的验收标准</li><li>添加用户故事</li><li>创造其他用户故事</li><li>将用户故事安排到特定版本中</li><li>描述用户故事</li><li>定义用户故事的验收标准</li><li>定义用户故事的故事点、优先级、风险和截止日期</li><li>批准用户故事</li></ul><h3 id="发布计划-Scrum-Process-Canvas入口"><a href="#发布计划-Scrum-Process-Canvas入口" class="headerlink" title="发布计划 -Scrum Process Canvas入口"></a>发布计划 -Scrum Process Canvas入口</h3><ul><li>定义可交付成果</li><li>定义发布计划</li><li>将用户故事安排到版本中</li><li>形成用户故事地图</li></ul><blockquote><p>用户地图和WBS的区别<br>用户地图主要用于理解和描绘用户的行为、需求和情境，帮助团队更好地设计产品和服务<br>WBS用于将项目的整体目标分解为更小的、可管理的部分，以便于项目的规划、执行和控制<br>用户地图是产品设计的工具，WBS是项目管理的工具</p></blockquote><h2 id="（四）立体建模"><a href="#（四）立体建模" class="headerlink" title="（四）立体建模"></a>（四）立体建模</h2><h3 id="故事旅程地图"><a href="#故事旅程地图" class="headerlink" title="故事旅程地图"></a>故事旅程地图</h3><ul><li>接触点、客户想法和主意间的可追溯性<ul><li>它通过不同的接触点呈现客户的想法和感受，帮助企业加深对客户行为、想法和感受的理解，以做出有价值的决策</li><li>接触点是能够改变客户对产品、品牌、业务或服务的感受的交互点</li><li>客户旅程可以阐明产品策略，这些策略通常由许多相互关联的层面组成：例如行动、想法和感受等</li><li>要为这些项目建立可追溯性。可以将客户想法引用到接触点，或将客户想法引用到解决方法</li><li>数据的连接显示在旅程地图上，使我们能够更有效地识别用户问题</li></ul></li><li>以客户为中心<br><img src="/images/manage/img_10.png" alt="/images/manage/img_10.png"></li><li>创建新旅程</li><li>从旅程地图生成文档</li></ul><h3 id="UML推演"><a href="#UML推演" class="headerlink" title="UML推演"></a>UML推演</h3><ul><li>从传统模型到软件模型</li><li>4+1模型（uml为不同视图提供了标准化的表达方式） 可以视为一种组织和使用uml来全面描述软件系统架构的框架<ul><li>逻辑视图（logical view）：系统分析、设计人员  类与对象</li><li>进程视图（process view）：系统集成人员   线程、进程、并发</li><li>实现视图（implementation view）：程序员   物理代码文件和组件</li><li>部署视图（deployment view）：系统和网络工程师  软件到硬件的映射</li><li>用例视图（use case view）：最终用户   需求分析模型</li></ul></li><li>用例图与用例文档的映射：用例文档详细描述用例的具体情境、前提条件、步骤和结果<br><img src="/images/manage/img_11.png" alt="/images/manage/img_11.png"></li><li>用例文档与活动图的映射：图形化方式展示活动之间的顺序和条件，与用例文档中的详细步骤相对应<br><img src="/images/manage/img_12.png" alt="/images/manage/img_12.png"></li><li>用例文档与类图的映射：开发者识别用例所需的类和属性，确保系统设计的完整性<br><img src="/images/manage/img_13.png" alt="/images/manage/img_13.png"></li><li>基于时序图改进类图：时序图通过具体的消息传递关系，能够揭示类途中未明确的关系或行为<br><img src="/images/manage/img_14.png" alt="/images/manage/img_14.png"></li><li>基于类图改进时序图：类图提供了系统的静态结构信息，时序图则展示动态交互。通过结合类图的信息，时序图额能够更准确地反映对象之间的交互关系和对象的状态<br><img src="/images/manage/img_15.png" alt="/images/manage/img_15.png"></li><li>为何而生？ <ul><li>活动图–为理解而生 帮助开发者理解系统的工作流程</li><li>时序图–为实现而生 实现复杂对象之间的交互关系</li></ul></li><li>统一建模 时序图–可以表达更复杂的对象交互关系</li></ul><h3 id="原型推演"><a href="#原型推演" class="headerlink" title="原型推演"></a>原型推演</h3><ul><li>静态界面设计：创建界面的基本布局和元素，通常不包含交互和动态内容</li><li>Single Wireframe， Mutiple States：<br>单一线框图展示了某个界面的基本结构，多个状态则是指同一个界面的不同状态</li><li>Storyboard 故事板：<br>故事板是一种线性展示界面和交互流程的工具。通过一系列图像或框架展示用户在使用系统时的步骤和情景</li><li>Storyboard Player 故事板播放器：<br>一个工具或软件，能够动态展示故事板中的各个场景和过渡效果</li><li>Wireframe-based flow chart 基于线框的流程图：<br>结合了线框设计和流程图的特点，展示了用户在系统中的交互流程</li><li>Animate Path In action 动画路径：<br>通过动画演示对象的移动、变化和过渡</li></ul><h3 id="故事地图、uml、原型可否打通三界？"><a href="#故事地图、uml、原型可否打通三界？" class="headerlink" title="故事地图、uml、原型可否打通三界？"></a>故事地图、uml、原型可否打通三界？</h3><ul><li>故事地图是一种可视化工具，用于展示用户故事的优先级和关系。它帮助团队识别和组织产品功能，从用户的角度理解需求，并确保每个功能与用户目标的紧密联系。</li><li>UML提供了一系列标准化图形，帮助团队以结构化的方式描述系统的设计和行为。通过使用UML，开发团队可以清晰地表达系统的静态结构（如类图）和动态行为（如时序图、活动图），促进沟通和理解</li><li>原型设计通过视觉和交互的方式呈现产品的外观和功能，帮助利益相关者快速验证想法。原型可以是静态的线框图，也可以是动态的可交互模型。</li></ul><h4 id="复盘Scrum"><a href="#复盘Scrum" class="headerlink" title="复盘Scrum"></a>复盘Scrum</h4><ul><li>画布与五大过程组</li><li>规划：识别业务目标、管理Epics、管理Backlog、发布计划</li><li>细化用户故事之定义验收标准：<br>明确每个用户故事的验收标准，以确保开发的功能满足用户需求</li><li>细化用户故事之定义故事点：<br>为每个用户故事分配故事点，反映其复杂度和工作量。有助于团队在迭代中进行更准确的估算和规划</li><li>细化用户故事之编写故事剧情：<br>编写用户故事的详细描述，包括场景、角色、目标和行动。有助于团队更好地理解用户需求，确保开发的功能符合用户期望</li><li>细化用户故事之绘制时序图：<br>利用时序图展示用户故事中的交互过程，帮助团队明确不同对象之间的关系和消息传递</li><li>细化用户故事之绘制活动图：<br>利用活动图展示用户故事中的工作流程，帮助团队理解系统的操作流程和交互逻辑</li></ul><h2 id="五）功能点法"><a href="#五）功能点法" class="headerlink" title="(五）功能点法"></a>(五）功能点法</h2><h3 id="宏观过程"><a href="#宏观过程" class="headerlink" title="宏观过程"></a>宏观过程</h3><p><img src="/images/manage/img_16.png" alt="/images/manage/img_16.png"></p><h3 id="中观过程"><a href="#中观过程" class="headerlink" title="中观过程"></a>中观过程</h3><p><img src="/images/manage/img_17.png" alt="/images/manage/img_17.png"></p><h3 id="度量标准"><a href="#度量标准" class="headerlink" title="度量标准"></a>度量标准</h3><h3 id="五类方法：IFPUG、MarkII、NESMA、COSMIC、FISMA"><a href="#五类方法：IFPUG、MarkII、NESMA、COSMIC、FISMA" class="headerlink" title="五类方法：IFPUG、MarkII、NESMA、COSMIC、FISMA"></a>五类方法：IFPUG、MarkII、NESMA、COSMIC、FISMA</h3><p><img src="/images/manage/img_18.png" alt="/images/manage/img_18.png"></p><h3 id="规模评估–功能点评估"><a href="#规模评估–功能点评估" class="headerlink" title="规模评估–功能点评估"></a>规模评估–功能点评估</h3><ul><li>IFPUG微观过程</li></ul><h4 id="功能类型"><a href="#功能类型" class="headerlink" title="功能类型"></a>功能类型</h4><ul><li><em><strong>功能类型ILF</strong></em>：内部逻辑文件，是一组可由用户识别确认的、在应用系统边界内维护的、逻辑上相关的数据或控制信息。<br>ILF的主要意图是通过被测应用程序的一个或多个基本处理来保存维护数据。</li><li><em><strong>功能类型EIF</strong></em>：外部接口文件是一组可由用户识别确认的、由被测应用系统引用，但在其它应用系统边界内维护的、逻辑上相关的数据或控制信息。<br>EIF的主要意图是存放被测应用程序中的一个或多个基本处理所引用的数据。也就是说，一个应用程序的EIF必定是另一个应用系统的ILF</li><li><em><strong>功能类型EI</strong></em>：外部输入，是处理来自应用程序边界外的数据或者控制信息的一个基本处理，如用户通过增删改来维护内部逻辑文件。<br>经过处理的控制信息则可能维护一个ILF或不维护它，EI的主要意图是维护一个或多个ILF，以及通过其他处理逻辑来改变应用程序的行为。</li><li><em><strong>功能类型EO</strong></em>：外部输出，是一个向应用程序边界外提供数据或控制信息的基本处理。EO的主要意图是向用户提供经过处理逻辑加工的、除了检索数据或控制信息之外的信息或附加信息。<br>处理逻辑必须包含至少一个数学公式或计算、创建导出数据、维护一个或多个ILF，并且&#x2F;或者改变系统的行为</li><li><em><strong>功能类型EQ</strong></em>：外部查询，是应用程序向边界之外提供数据或控制信息的基本处理。主要意图是向用户展示未经处理、直接查询的一些数据或控制信息。<br>处理逻辑不包含数学公式或计算，也不产生派生的数据。处理过程中外部查询既不维护ILF，也不改变系统的行为。</li><li>EI、EO、EQ 是事务功能，ILF、EIF 是数据功能</li><li>功能类型案例<br><img src="/images/manage/img_19.png" alt="/images/manage/img_19.png"><br><img src="/images/manage/img_20.png" alt="/images/manage/img_20.png"></li><li>功能复杂程度<br><img src="/images/manage/img_21.png" alt="/images/manage/img_21.png"></li><li>未调整功能点<br><img src="/images/manage/img_22.png" alt="/images/manage/img_22.png"><br><img src="/images/manage/img_23.png" alt="/images/manage/img_23.png"></li></ul><h4 id="GSC综合系统特征"><a href="#GSC综合系统特征" class="headerlink" title="GSC综合系统特征"></a>GSC综合系统特征</h4><p><img src="/images/manage/img_24.png" alt="/images/manage/img_24.png"></p><h4 id="VAF调整系数值"><a href="#VAF调整系数值" class="headerlink" title="VAF调整系数值"></a>VAF调整系数值</h4><p><img src="/images/manage/img_25.png" alt="/images/manage/img_25.png"></p><h4 id="已调整功能点计数"><a href="#已调整功能点计数" class="headerlink" title="已调整功能点计数"></a>已调整功能点计数</h4><p><img src="/images/manage/img_26.png" alt="/images/manage/img_26.png"></p><h4 id="规模变更调整因子"><a href="#规模变更调整因子" class="headerlink" title="规模变更调整因子"></a>规模变更调整因子</h4><p><img src="/images/manage/img_27.png" alt="/images/manage/img_27.png"></p><h4 id="已调整功能点计数-1"><a href="#已调整功能点计数-1" class="headerlink" title="已调整功能点计数"></a>已调整功能点计数</h4><p><img src="/images/manage/img_28.png" alt="/images/manage/img_28.png"></p><h4 id="已调整功能点计数比较"><a href="#已调整功能点计数比较" class="headerlink" title="已调整功能点计数比较"></a>已调整功能点计数比较</h4><p><img src="/images/manage/img_29.png" alt="/images/manage/img_29.png"></p><h3 id="工作量评估–方程法"><a href="#工作量评估–方程法" class="headerlink" title="工作量评估–方程法"></a>工作量评估–方程法</h3><p><img src="/images/manage/img_30.png" alt="/images/manage/img_30.png"></p><h3 id="单价评估–行业区域人员成本评估"><a href="#单价评估–行业区域人员成本评估" class="headerlink" title="单价评估–行业区域人员成本评估"></a>单价评估–行业区域人员成本评估</h3><p><img src="/images/manage/img_31.png" alt="/images/manage/img_31.png"></p><h3 id="风险评估-质量评估–风险评估"><a href="#风险评估-质量评估–风险评估" class="headerlink" title="风险评估&#x2F;质量评估–风险评估"></a>风险评估&#x2F;质量评估–风险评估</h3><p><img src="/images/manage/img_32.png" alt="/images/manage/img_32.png"></p><h3 id="综合评估–综合评估法"><a href="#综合评估–综合评估法" class="headerlink" title="综合评估–综合评估法"></a>综合评估–综合评估法</h3><p><img src="/images/manage/img_33.png" alt="/images/manage/img_33.png"></p><h3 id="WBS"><a href="#WBS" class="headerlink" title="WBS"></a>WBS</h3><p><img src="/images/manage/img_34.png" alt="/images/manage/img_34.png"></p><h2 id="（六）过程规划"><a href="#（六）过程规划" class="headerlink" title="（六）过程规划"></a>（六）过程规划</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="若干阶段"><a href="#若干阶段" class="headerlink" title="若干阶段"></a>若干阶段</h4><ul><li>把项目分为若干阶段因为：项目作为系统的一部分运行并且包含不确定性</li><li>项目生命周期是项目阶段的集合</li><li>定义了：<ul><li>每个阶段做什么工作</li><li>什么样的可交付物和什么时候</li><li>谁参与到每个阶段</li><li>经理如何控制和批准工作</li></ul></li></ul><h4 id="三个阶段：早期阶段、中期阶段、后期阶段"><a href="#三个阶段：早期阶段、中期阶段、后期阶段" class="headerlink" title="三个阶段：早期阶段、中期阶段、后期阶段"></a>三个阶段：早期阶段、中期阶段、后期阶段</h4><p><img src="/images/manage/img_35.png" alt="/images/manage/img_35.png"></p><h4 id="四个阶段：Concept、Development、Implementation、Close-out（概念、开发、实施、收尾）"><a href="#四个阶段：Concept、Development、Implementation、Close-out（概念、开发、实施、收尾）" class="headerlink" title="四个阶段：Concept、Development、Implementation、Close-out（概念、开发、实施、收尾）"></a>四个阶段：Concept、Development、Implementation、Close-out（概念、开发、实施、收尾）</h4><p><img src="/images/manage/img_36.png" alt="/images/manage/img_36.png"></p><h4 id="五过程组：Initiating、Planning、Executing、Monitoring-and-Controlling、Closing（启动、规划、执行、监控与控制、收尾）"><a href="#五过程组：Initiating、Planning、Executing、Monitoring-and-Controlling、Closing（启动、规划、执行、监控与控制、收尾）" class="headerlink" title="五过程组：Initiating、Planning、Executing、Monitoring and Controlling、Closing（启动、规划、执行、监控与控制、收尾）"></a>五过程组：Initiating、Planning、Executing、Monitoring and Controlling、Closing（启动、规划、执行、监控与控制、收尾）</h4><ul><li>组间关联<br><img src="/images/manage/img_77.png" alt="/images/manage/img_77.png"></li><li>组外映射<br><img src="/images/manage/img_37.png" alt="/images/manage/img_37.png"></li><li>时间配比<br><img src="/images/manage/img_38.png" alt="/images/manage/img_38.png"></li><li>在规划上花费更多的时间可以减少执行时间</li></ul><h4 id="启动过程组"><a href="#启动过程组" class="headerlink" title="启动过程组"></a>启动过程组</h4><p><img src="/images/manage/img_39.png" alt="/images/manage/img_39.png"><br>包括识别和启动一个新的项目，确保为了正确的原因启动正确的项目</p><p>预启动，在正式启动项目之前，为项目奠定良好的基础</p><ul><li>确定制约因素</li><li>识别发起人</li><li>识别项目经理</li><li>开发商业论证（Business case）<br>   <img src="/images/manage/img_40.png" alt="/images/manage/img_40.png"></li><li>讨论过程结果</li><li>细分子项</li></ul><p>启动项目，让项目顺利进入正轨</p><ul><li>识别干系人（Stakeholder）<br>  <img src="/images/manage/img_41.png" alt="/images/manage/img_41.png"></li><li>起草项目章程（Project Charter）<br>  项目经理起草 -&gt; 团队成员内审 -&gt; 发起人&#x2F;高级经理审核 -&gt; 内签<br>  <img src="/images/manage/img_42.png" alt="/images/manage/img_42.png"></li><li>召开启动会议<br>  <img src="/images/manage/img_43.png" alt="/images/manage/img_43.png"></li></ul><h4 id="规划过程组"><a href="#规划过程组" class="headerlink" title="规划过程组"></a>规划过程组</h4><p>规划项目，指导项目的执行</p><ul><li>团队协议<br>  <img src="/images/manage/img_44.png" alt="/images/manage/img_44.png"><br>  <img src="/images/manage/img_45.png" alt="/images/manage/img_45.png"></li><li>工作范围说明书<br>  <img src="/images/manage/img_46.png" alt="/images/manage/img_46.png"></li><li>工作分解结构<br>  <img src="/images/manage/img_47.png" alt="/images/manage/img_47.png"></li><li>项目时间表<br>  <img src="/images/manage/img_48.png" alt="/images/manage/img_48.png"></li><li>风险排序清单<br>  <img src="/images/manage/img_49.png" alt="/images/manage/img_49.png"></li><li>…</li></ul><h4 id="执行过程组"><a href="#执行过程组" class="headerlink" title="执行过程组"></a>执行过程组</h4><p>项目执行，采取必要的行动以确保完成项目计划中的活动</p><ul><li>指导&#x2F;管理项目<br>  <img src="/images/manage/img_50.png" alt="/images/manage/img_50.png"></li><li>执行质量保证</li><li>获取项目团队</li><li>建设项目团队</li><li>管理项目团队</li><li>管理沟通</li><li>实施采购</li><li>管理干系人参与</li></ul><h4 id="监控过程组"><a href="#监控过程组" class="headerlink" title="监控过程组"></a>监控过程组</h4><p>项目监控，针对项目目标来衡量进展情况、监测计划的偏离状况、采取正确的行动符合计划的进展</p><ul><li>监控项目工作<br>  <img src="/images/manage/img_51.png" alt="/images/manage/img_51.png"></li><li>整体变更控制</li><li>范围核实</li><li>进度控制</li><li>成本控制</li><li>质量控制</li><li>沟通控制</li><li>风险控制</li><li>采购控制</li><li>干系人控制</li></ul><h4 id="收尾过程组"><a href="#收尾过程组" class="headerlink" title="收尾过程组"></a>收尾过程组</h4><p>收尾过程，包括获得干系人和客户对于最终产品和服务的<em><strong>验收</strong></em>，同时使得项目或者项目阶段实现<em><strong>有序的结束</strong></em></p><p>核实成果+交付成果+最终陈述+经验教训</p><ul><li>项目&#x2F;阶段收尾<br>  <img src="/images/manage/img_52.png" alt="/images/manage/img_52.png"><br>  <img src="/images/manage/img_53.png" alt="/images/manage/img_53.png"></li><li>采购终止<br>小结：<br><img src="/images/manage/img_54.png" alt="/images/manage/img_54.png"></li></ul><h3 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h3><h4 id="若干模型"><a href="#若干模型" class="headerlink" title="若干模型"></a>若干模型</h4><p><img src="/images/manage/img_55.png" alt="/images/manage/img_55.png"></p><h4 id="三层五类"><a href="#三层五类" class="headerlink" title="三层五类"></a>三层五类</h4><p><img src="/images/manage/img_56.png" alt="/images/manage/img_56.png"></p><h5 id="传统模型"><a href="#传统模型" class="headerlink" title="传统模型"></a>传统模型</h5><p>特征：</p><ul><li>低复杂性</li><li>范围变更请求很少</li><li>很好理解的技术架构</li><li>低风险</li><li>有经验、有能力的开发团队</li><li>计划驱动的TPM项目</li></ul><h5 id="线性-Linear"><a href="#线性-Linear" class="headerlink" title="线性 Linear"></a>线性 Linear</h5><p><img src="/images/manage/img_57.png" alt="/images/manage/img_57.png"><br><img src="/images/manage/img_58.png" alt="/images/manage/img_58.png"><br><img src="/images/manage/img_59.png" alt="/images/manage/img_59.png"></p><ul><li>优点：<ul><li>开始时就进行了进度安排</li><li>开始时资源已知</li><li>不需要最熟练的项目团队</li><li>不需要同地协作</li></ul></li><li>缺点：<ul><li>不适应变更</li><li>成本过高</li><li>耗时过长</li><li>要求有完整和细致的计划</li><li>严格的过程组线性顺序</li><li>不关注客户价值</li></ul></li></ul><h5 id="增量-Incremental"><a href="#增量-Incremental" class="headerlink" title="增量 Incremental"></a>增量 Incremental</h5><p><img src="/images/manage/img_60.png" alt="/images/manage/img_60.png"><br><img src="/images/manage/img_61.png" alt="/images/manage/img_61.png"></p><ul><li>优点：<ul><li>更早地产生商业价值</li><li>更好地安排稀缺资源</li><li>适应小变更</li><li>有产品改良机会</li><li>比线性更关注客户价值</li></ul></li><li>缺点：<ul><li>团队人员不稳定</li><li>增量之间的交接文档</li><li>增量优先级必须考虑依赖性</li><li>更需要客户参与</li><li>比线性模型更长的时间</li><li>功能分隔可能成为问题</li></ul></li></ul><h4 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h4><p>特征：</p><ul><li>没有已知的解决方案</li><li>预计会有新的商业机会</li><li>变化驱动的APM项目</li><li>对组织化解风险非常关键</li><li>客户的有效参与是绝对必要</li><li>使用小型同地协作团队</li></ul><h5 id="重型RUP"><a href="#重型RUP" class="headerlink" title="重型RUP"></a>重型RUP</h5><p><img src="/images/manage/img_62.png" alt="/images/manage/img_62.png"></p><h5 id="轻型SCRUM"><a href="#轻型SCRUM" class="headerlink" title="轻型SCRUM"></a>轻型SCRUM</h5><p><img src="/images/manage/img_63.png" alt="/images/manage/img_63.png"></p><ul><li>优点：<ul><li>可变更范围</li><li>适应变化随变而调即时规划</li><li>关注形成商业价值</li><li>客户可评审部分解决方案</li></ul></li><li>缺点：<ul><li>团队人员不稳定</li><li>同地协作的团队</li><li>资源需求不清晰</li><li>更高的客户参与度</li><li>不确定的最终解决方案</li></ul></li></ul><h4 id="极限模型"><a href="#极限模型" class="headerlink" title="极限模型"></a>极限模型</h4><p>特征：</p><ul><li>xPM是一种研发项目</li><li>xPM项目的风险很高</li><li>优点：<ul><li>备选方案保持时间长</li><li>能提供大量部分解决方案供早期参考</li></ul></li><li>缺点<ul><li>可能在所有错误的地方寻找解决方案</li><li>不能保证项目交付结果具有商业价值</li></ul></li></ul><h4 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h4><p>相同点：</p><ul><li>都有5个过程组</li><li>都开始于范围&#x2F;启动过程组</li><li>都结束于收尾过程组<br>不同点：</li><li>越来越高的不确定性</li><li>越来越重要的风险管理</li><li>越来越需要客户有效参与</li><li>趋向生命周期的开端</li><li>完整的项目计划被即时项目计划取代<br>  <img src="/images/manage/img_64.png" alt="/images/manage/img_64.png"></li></ul><h3 id="最适之选"><a href="#最适之选" class="headerlink" title="最适之选"></a>最适之选</h3><p><img src="/images/manage/img_65.png" alt="/images/manage/img_65.png"></p><h2 id="（七）敏捷方法"><a href="#（七）敏捷方法" class="headerlink" title="（七）敏捷方法"></a>（七）敏捷方法</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p><img src="/images/manage/img_66.png" alt="/images/manage/img_66.png"></p><h3 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h3><p><img src="/images/manage/img_67.png" alt="/images/manage/img_67.png"></p><ul><li>个体和互动高于流程和工具</li><li>工作的软件高于详尽的文档</li><li>客户合作高于合同谈判</li><li>响应变化高于遵循计划</li></ul><h3 id="敏捷原则"><a href="#敏捷原则" class="headerlink" title="敏捷原则"></a>敏捷原则</h3><p><img src="/images/manage/img_68.png" alt="/images/manage/img_68.png"><br><img src="/images/manage/img_69.png" alt="/images/manage/img_69.png"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>三用<ul><li>需求不确定</li><li>设计不确定</li><li>计划不确定</li></ul></li><li>三不用<ul><li>产品高要求</li><li>团队有问题</li><li>需求负反馈</li></ul></li></ul><h3 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h3><p><img src="/images/manage/img_70.png" alt="/images/manage/img_70.png"></p><h3 id="RUP"><a href="#RUP" class="headerlink" title="RUP"></a>RUP</h3><p><img src="/images/manage/img_71.png" alt="/images/manage/img_71.png"></p><h3 id="RUP迭代"><a href="#RUP迭代" class="headerlink" title="RUP迭代"></a>RUP迭代</h3><p><img src="/images/manage/img_72.png" alt="/images/manage/img_72.png"></p><h3 id="RUP阶段工作量和进度"><a href="#RUP阶段工作量和进度" class="headerlink" title="RUP阶段工作量和进度"></a>RUP阶段工作量和进度</h3><p><img src="/images/manage/img_73.png" alt="/images/manage/img_73.png"></p><h3 id="OpenUP"><a href="#OpenUP" class="headerlink" title="OpenUP"></a>OpenUP</h3><p><img src="/images/manage/img_74.png" alt="/images/manage/img_74.png"></p><h3 id="Kanban"><a href="#Kanban" class="headerlink" title="Kanban"></a>Kanban</h3><p><img src="/images/manage/img_75.png" alt="/images/manage/img_75.png"><br><img src="/images/manage/img_76.png" alt="/images/manage/img_76.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软件项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Avalonia 全栈开发课程</title>
      <link href="/2024/10/09/avalonia/"/>
      <url>/2024/10/09/avalonia/</url>
      
        <content type="html"><![CDATA[<h1 id="读写数据库"><a href="#读写数据库" class="headerlink" title="读写数据库"></a>读写数据库</h1><p>如何在Avalonia中建立数据库连接，如何在数据库中插入数据</p><ul><li>Mvvm设计模式：Model、ViewModel、View 客户端开发的一种设计模式（MVC是服务端开发的设计模式）</li></ul><h2 id="从Model开始，添加新类作为模型类"><a href="#从Model开始，添加新类作为模型类" class="headerlink" title="从Model开始，添加新类作为模型类"></a>从Model开始，添加新类作为模型类</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Poetry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="built_in">string</span>.Empty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="service层，添加新类作为服务类-接口IPoetryStorage，实现类PoetryStorage"><a href="#service层，添加新类作为服务类-接口IPoetryStorage，实现类PoetryStorage" class="headerlink" title="service层，添加新类作为服务类 接口IPoetryStorage，实现类PoetryStorage"></a>service层，添加新类作为服务类 接口IPoetryStorage，实现类PoetryStorage</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPoetryStorage</span> &#123;</span><br><span class="line">    <span class="function">Task <span class="title">InsertAsync</span>(<span class="params">Poetry poetry</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个异步操作，函数名以Async结尾，返回值是Task，参数是Poetry类型的对象<br><strong>异步操作：不会阻塞当前线程，而是在另一个线程上执行，执行完毕后会通知当前线程</strong></p><p>什么时候用异步操作？ 当操作比较耗时的时候，比如读写文件、读写数据库、网络请求</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PoetryStorage</span> : <span class="title">IPoetryStorage</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InsertAsync</span>(<span class="params">Poetry poetry</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>.NET代码优先，code first，怎么把数据库表建起来？ 根据模型类建立数据库表</li><li>运行在服务器，数据库在服务器上，但是我们的代码运行在用户的本机上，怎么让我们的代码和数据库建立连接？</li></ul><h2 id="嵌入式数据库，SQLite-行业标准-程序的一部分，不需要安装，不需要配置，不需要启动"><a href="#嵌入式数据库，SQLite-行业标准-程序的一部分，不需要安装，不需要配置，不需要启动" class="headerlink" title="嵌入式数据库，SQLite 行业标准 程序的一部分，不需要安装，不需要配置，不需要启动"></a>嵌入式数据库，SQLite 行业标准 程序的一部分，不需要安装，不需要配置，不需要启动</h2><ul><li>通过NuGet安装<em><strong>sqlite-net-pcl</strong></em></li><li>确定数据库怎么找，先确定数据库的文件名，在PoetryStorage类中添加一个常量<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> DbName = <span class="string">&quot;poetrydb.sqlite3&quot;</span>;</span><br></pre></td></tr></table></figure></li><li>重点问题：放在哪？放在哪个目录下？ 放用户总目录下，有一个位置专门存放应用程序</li></ul><h2 id="新建Helpers文件夹，添加一个新类PathHelper"><a href="#新建Helpers文件夹，添加一个新类PathHelper" class="headerlink" title="新建Helpers文件夹，添加一个新类PathHelper"></a>新建Helpers文件夹，添加一个新类PathHelper</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PathHelper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> _localFolder = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒初始化，只有在需要的时候才初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> LocalFolder &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(_localFolder)) &#123;</span><br><span class="line">                <span class="keyword">return</span> _localFolder;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 专门存放应用程序的位置</span></span><br><span class="line">            _localFolder =</span><br><span class="line">                Path.Combine(</span><br><span class="line">                    Environment.GetFolderPath(Environment.SpecialFolder</span><br><span class="line">                        .LocalApplicationData), <span class="keyword">nameof</span>(Mvvm)); <span class="comment">// 获取物理路径</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// nameof(Mvvm)获取Mvvm的字符串名称</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(_localFolder)) &#123;</span><br><span class="line">                Directory.CreateDirectory(_localFolder);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _localFolder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定一个文件名，返回文件的完整路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetLocalFilePath</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Path.Combine(LocalFolder, fileName);  <span class="comment">// 拼接路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回到PoetryStorage类，可以获取数据库文件的完整路径"><a href="#回到PoetryStorage类，可以获取数据库文件的完整路径" class="headerlink" title="回到PoetryStorage类，可以获取数据库文件的完整路径"></a>回到PoetryStorage类，可以获取数据库文件的完整路径</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> PoetryDbPath =</span><br><span class="line">    PathHelper.GetLocalFilePath(DbName);</span><br></pre></td></tr></table></figure><ul><li>public const string 和 public static readonly string 的区别？ <ul><li>public const string 是常量，编译时就确定了值，不能修改</li><li>public static readonly string 是只读的，运行时确定值，可以修改</li></ul></li></ul><h2 id="建立数据库连接"><a href="#建立数据库连接" class="headerlink" title="建立数据库连接"></a>建立数据库连接</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SQLiteAsyncConnection _connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SQLiteAsyncConnection Connection =&gt;</span><br><span class="line">    _connection ??= <span class="keyword">new</span> SQLiteAsyncConnection(PoetryDbPath);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>??&#x3D; 是什么意思？ 空合并运算符，左边的值为空时，才会计算右边的值</li></ul><h2 id="建立数据库表"><a href="#建立数据库表" class="headerlink" title="建立数据库表"></a>建立数据库表</h2><ul><li>现在IPoetryStorage接口中添加一个新方法<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">InitializeAsync</span>()</span>;</span><br></pre></td></tr></table></figure></li><li>在PoetryStorage类中实现这个方法,根据模型类建立数据库表，不用写SQL语句<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InitializeAsync</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> Connection.CreateTableAsync&lt;Poetry&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="初探MVVM"><a href="#初探MVVM" class="headerlink" title="初探MVVM"></a>初探MVVM</h1><p>通过像数据库中插入数据，来学习MVVM设计模式，Avolonia是如何把UI连起来的</p><h2 id="实现插入诗词的功能，在PoetryStorage类中实现InsertAsync方法-（Service层）"><a href="#实现插入诗词的功能，在PoetryStorage类中实现InsertAsync方法-（Service层）" class="headerlink" title="实现插入诗词的功能，在PoetryStorage类中实现InsertAsync方法 （Service层）"></a>实现插入诗词的功能，在PoetryStorage类中实现InsertAsync方法 （Service层）</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InsertAsync</span>(<span class="params">Poetry poetry</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> Connection.InsertAsync(poetry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>软件是分层的，每一层都有自己的职责，UI层（View）只负责显示，业务逻辑层（ViewModel）负责业务逻辑，Service层负责数据存取，Model层负责数据结构</li></ul><h2 id="向上一层，添加一个新类PoetryViewModel"><a href="#向上一层，添加一个新类PoetryViewModel" class="headerlink" title="向上一层，添加一个新类PoetryViewModel"></a>向上一层，添加一个新类PoetryViewModel</h2><p>ViewModel中的属性，是UI中的数据源，UI中的控件绑定到ViewModel中的属性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindowViewModel</span> : <span class="title">ViewModelBase</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IPoetryStorage _poetryStorage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为什么一定用接口？ </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用构造方法的方式注入依赖</span></span><br><span class="line">    <span class="comment">// new一个MainWindowViewModel对象时，必须传入一个IPoetryStorage类型的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindowViewModel</span>(<span class="params">IPoetryStorage poetryStorage</span>)</span> &#123;</span><br><span class="line">        _poetryStorage = poetryStorage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Message &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _message;</span><br><span class="line">        <span class="keyword">set</span> =&gt; SetProperty(<span class="keyword">ref</span> _message, <span class="keyword">value</span>);</span><br><span class="line">        <span class="comment">// ref 引用传递，传递的是变量的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span> &#123;</span><br><span class="line">       Message = <span class="string">&quot;Hello, Avalonia!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 谁来调用SayHello方法？ 由UI层调用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本CURD"><a href="#基本CURD" class="headerlink" title="基本CURD"></a>基本CURD</h1><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><h1 id="Mock2"><a href="#Mock2" class="headerlink" title="Mock2"></a>Mock2</h1><h1 id="Behaviors"><a href="#Behaviors" class="headerlink" title="Behaviors"></a>Behaviors</h1><h1 id="无限滚动及其原理"><a href="#无限滚动及其原理" class="headerlink" title="无限滚动及其原理"></a>无限滚动及其原理</h1><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><h1 id="访问Json-Web服务"><a href="#访问Json-Web服务" class="headerlink" title="访问Json Web服务"></a>访问Json Web服务</h1><h1 id="MVVM-IService架构"><a href="#MVVM-IService架构" class="headerlink" title="MVVM + IService架构"></a>MVVM + IService架构</h1><h1 id="导航的原理"><a href="#导航的原理" class="headerlink" title="导航的原理"></a>导航的原理</h1><p>Avalonia.Samples-main\src\Avalonia.Samples\Routing\BasicViewLocatorSample</p><h2 id="从导航的按钮出发-MainWindow-axaml"><a href="#从导航的按钮出发-MainWindow-axaml" class="headerlink" title="从导航的按钮出发  MainWindow.axaml"></a>从导航的按钮出发  MainWindow.axaml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Command=&quot;&#123;Binding NavigateNextCommand&#125;&quot; Content=&quot;Next&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="NavigateNextCommand是什么？"><a href="#NavigateNextCommand是什么？" class="headerlink" title="NavigateNextCommand是什么？"></a>NavigateNextCommand是什么？</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NavigateNextCommand = ReactiveCommand.Create(NavigateNext, canNavNext);</span><br></pre></td></tr></table></figure><h2 id="NavigateNext是什么？"><a href="#NavigateNext是什么？" class="headerlink" title="NavigateNext是什么？"></a>NavigateNext是什么？</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NavigateNext</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// get the current index and add 1</span></span><br><span class="line">  <span class="keyword">var</span> index = Pages.IndexOf(CurrentPage) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  /!\ Be aware that we have no check if the index is valid. You may want to add it on your own. /!\</span></span><br><span class="line">  CurrentPage = Pages[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pages和CurrentPage是什么？"><a href="#Pages和CurrentPage是什么？" class="headerlink" title="Pages和CurrentPage是什么？"></a>Pages和CurrentPage是什么？</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PageViewModelBase CurrentPage</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; <span class="keyword">return</span> _CurrentPage; &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">set</span> &#123; <span class="keyword">this</span>.RaiseAndSetIfChanged(<span class="keyword">ref</span> _CurrentPage, <span class="keyword">value</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CurrentPage是PageViewModelBase类型的对象，继承于ViewModelBase，也就是说CurrentPage是一个ViewModel<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A read.only array of possible pages</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> PageViewModelBase[] Pages = </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">new</span> FirstPageViewModel(),</span><br><span class="line">            <span class="keyword">new</span> SecondPageViewModel(),</span><br><span class="line">            <span class="keyword">new</span> ThirdPageViewModel()</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></li><li>Pages是一个数组，数组中的元素是PageViewModelBase类型的对象，也就是说Pages是一个ViewModel数组</li><li><em><strong>怎么做到把ViewModel一改变，View就跟着改变？</strong></em></li></ul><h2 id="在MainWindow-axaml中，有一个TransitioningContentControl控件，但只是用来呈现内容的，不是用来导航的"><a href="#在MainWindow-axaml中，有一个TransitioningContentControl控件，但只是用来呈现内容的，不是用来导航的" class="headerlink" title="在MainWindow.axaml中，有一个TransitioningContentControl控件，但只是用来呈现内容的，不是用来导航的"></a>在MainWindow.axaml中，有一个TransitioningContentControl控件，但只是用来呈现内容的，不是用来导航的</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TransitioningContentControl Content=&quot;&#123;Binding CurrentPage&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="有一个抽象的机制ViewLocater"><a href="#有一个抽象的机制ViewLocater" class="headerlink" title="有一个抽象的机制ViewLocater"></a>有一个抽象的机制ViewLocater</h2><p>这里有一个函数Match，每次对按钮赋值Content的时候，都会调用这个函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Match</span>(<span class="params"><span class="built_in">object</span>? data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> data <span class="keyword">is</span> ViewModelBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>打了三次断点：Back、Next、FirstPageViewModel</li><li>这个函数用来判断当前的ViewModel是否匹配，如果匹配就返回true，否则返回false</li><li>返回true之后跳到了上面的方法Build</li><li>也就是说只有content的赋值为ViewModelBase子类的时候，才会调用Build方法<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = data.GetType().FullName!.Replace(<span class="string">&quot;ViewModel&quot;</span>, <span class="string">&quot;View&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>通过ViewModel的类型，找到对应的View的类型</li><li>通过反射，找到View的类型，然后实例化View<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = Type.GetType(name);</span><br><span class="line"><span class="keyword">if</span> (type != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Control)Activator.CreateInstance(type)!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>返回一个View的实例给了MainWindow.axaml中的TransitioningContentControl控件的Content</li></ul>]]></content>
      
      
      <categories>
          
          <category> Avolonia </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Avolonia </tag>
            
            <tag> 全栈开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot注册</title>
      <link href="/2024/09/28/springboot-register/"/>
      <url>/2024/09/28/springboot-register/</url>
      
        <content type="html"><![CDATA[<h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><ul><li>请求参数有两个：username和password，分别表示用户名和密码。请求参数是通过URL传递的，如&#96;&#x2F;login?username&#x3D;admin&amp;password&#x3D;123456</li><li>响应数据： code（相应码，0表示成功，1表示失败）、message（响应消息）、data（响应数据）。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;登录成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>定义一个有如上三个成员变量的result类，用于封装响应数据，spring自动将其转换为json格式返回给前端。</li></ul><h2 id="Result-java"><a href="#Result-java" class="headerlink" title="Result.java"></a>Result.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; Result&lt;E&gt; <span class="title function_">success</span><span class="params">(E data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">0</span>, <span class="string">&quot;success&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; Result&lt;E&gt; <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">0</span>, <span class="string">&quot;操作成功&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; Result&lt;E&gt; <span class="title function_">fail</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">1</span>, message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="User-java"><a href="#User-java" class="headerlink" title="User.java"></a>User.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line">    <span class="keyword">public</span> Timestamp createTime;</span><br><span class="line">    <span class="keyword">public</span> Timestamp updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UserMapper-java"><a href="#UserMapper-java" class="headerlink" title="UserMapper.java"></a>UserMapper.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username = #&#123;username&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user (username, password) values (#&#123;username&#125;, #&#123;password&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String username, String encode)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UserService-java"><a href="#UserService-java" class="headerlink" title="UserService.java"></a>UserService.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserMapper userMapper, PasswordEncoder passwordEncoder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">        <span class="built_in">this</span>.passwordEncoder = passwordEncoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//要进行加密处理，不能明文存储</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> passwordEncoder.encode(password);</span><br><span class="line">        userMapper.add(username, encode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UserController-java"><a href="#UserController-java" class="headerlink" title="UserController.java"></a>UserController.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//查询用户是否被占用</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> userService.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span>(u != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="number">1</span>, <span class="string">&quot;用户名已被占用&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            userService.register(username, password);</span><br><span class="line">            <span class="keyword">return</span> Result.success();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由于密码不能明文存储，所以要进行加密处理，这里使用Spring-Security提供的PasswordEncoder接口来进行加密处理。"><a href="#由于密码不能明文存储，所以要进行加密处理，这里使用Spring-Security提供的PasswordEncoder接口来进行加密处理。" class="headerlink" title="由于密码不能明文存储，所以要进行加密处理，这里使用Spring Security提供的PasswordEncoder接口来进行加密处理。"></a>由于密码不能明文存储，所以要进行加密处理，这里使用Spring Security提供的PasswordEncoder接口来进行加密处理。</h2><p>在config包下创建一个SecurityConfig类，用于配置Spring Security。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> register </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis</title>
      <link href="/2024/09/28/mybatis/"/>
      <url>/2024/09/28/mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot整合mybatis"><a href="#springboot整合mybatis" class="headerlink" title="springboot整合mybatis"></a>springboot整合mybatis</h1><h2 id="model类-Liujinhe-java"><a href="#model类-Liujinhe-java" class="headerlink" title="model类 Liujinhe.java"></a>model类 Liujinhe.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetos.neu.demooo.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiuJinHe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String usage;</span><br><span class="line">    <span class="keyword">private</span> Timestamp createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建表-Liujinhe"><a href="#建表-Liujinhe" class="headerlink" title="建表 Liujinhe"></a>建表 Liujinhe</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS mydb DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br><span class="line">USE mydb;</span><br><span class="line">CREATE TABLE LiuJinHe (</span><br><span class="line">                          id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">                          name VARCHAR(255) NOT NULL,</span><br><span class="line">                          age INT NOT NULL,</span><br><span class="line">                          `usage` VARCHAR(255) NOT NULL,</span><br><span class="line">                          create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO LiuJinHe (name, age, `usage`, category_id) VALUES</span><br><span class="line">                                                         (&#x27;光速小飞侠&#x27;, 25, &#x27;能够瞬间解读任意文学作品的潜台词，适合文学研讨会使用&#x27;, 1),</span><br><span class="line">                                                         (&#x27;乐器魔术师&#x27;, 30, &#x27;擅长通过各种乐器演奏曲子，可以演奏从古典到流行的任何风格&#x27;, 2),</span><br><span class="line">                                                         (&#x27;天空涂鸦家&#x27;, 22, &#x27;能够在高空中创作巨型壁画，适合公共艺术项目&#x27;, 3),</span><br><span class="line">                                                         (&#x27;音符猎人&#x27;, 27, &#x27;专门用于捕捉自然界中的声音，适合音乐创作和音效设计&#x27;, 4),</span><br><span class="line">                                                         (&#x27;全能修理工&#x27;, 35, &#x27;能够修复从古董手表到飞行器的任何设备，适合工匠和收藏家使用&#x27;, 1),</span><br><span class="line">                                                         (&#x27;代码舞者&#x27;, 28, &#x27;可以编写自动生成艺术作品的代码，适合数字艺术创作&#x27;, 2),</span><br><span class="line">                                                         (&#x27;故事编织者&#x27;, 24, &#x27;可以编写复杂的多线叙事小说，适合文学创作者&#x27;, 3),</span><br><span class="line">                                                         (&#x27;光影雕塑家&#x27;, 29, &#x27;通过操控光线与阴影来创造动态雕塑，适合现代艺术展览&#x27;, 4),</span><br><span class="line">                                                         (&#x27;时间旅行者&#x27;, 26, &#x27;能够为历史研究者再现真实历史场景，适合考古学和历史学领域&#x27;, 5),</span><br><span class="line">                                                         (&#x27;梦境探险家&#x27;, 31, &#x27;能够进入并探索他人的梦境，适合心理学研究和艺术创作&#x27;, 5),</span><br><span class="line">                                                         (&#x27;百科全书人&#x27;, 40, &#x27;能够瞬间回答任何学术问题，适合大学和科研机构&#x27;, 1),</span><br><span class="line">                                                         (&#x27;色彩音符&#x27;, 23, &#x27;可以根据音符自动生成相应的色彩搭配，适合设计师使用&#x27;, 4),</span><br><span class="line">                                                         (&#x27;言语雕刻家&#x27;, 34, &#x27;通过文字精确雕刻情感，适合诗人和作家使用&#x27;, 3),</span><br><span class="line">                                                         (&#x27;旋律造梦者&#x27;, 28, &#x27;可以在睡眠中创作出梦幻般的旋律，适合音乐制作人&#x27;, 2),</span><br><span class="line">                                                         (&#x27;机械灵魂&#x27;, 35, &#x27;能将机械赋予灵魂，适合机械装置艺术和工业设计&#x27;, 1),</span><br></pre></td></tr></table></figure><h2 id="LiujinheMapper"><a href="#LiujinheMapper" class="headerlink" title="LiujinheMapper"></a>LiujinheMapper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetos.neu.demooo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.model.LiuJinHe;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LiuJinHeMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from mydb.LiuJinHe where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LiuJinHe <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="liujinheService"><a href="#liujinheService" class="headerlink" title="liujinheService"></a>liujinheService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetos.neu.demooo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.model.LiuJinHe;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LiuJinHeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LiuJinHe <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="liujinheServiceImpl"><a href="#liujinheServiceImpl" class="headerlink" title="liujinheServiceImpl"></a>liujinheServiceImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetos.neu.demooo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.mapper.LiuJinHeMapper;</span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.model.LiuJinHe;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiuJinHeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LiuJinHeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LiuJinHeMapper liuJinHeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiuJinHeServiceImpl</span><span class="params">(LiuJinHeMapper liuJinHeMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liuJinHeMapper = liuJinHeMapper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> LiuJinHe <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> liuJinHeMapper.findById(id);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="liujinheController"><a href="#liujinheController" class="headerlink" title="liujinheController"></a>liujinheController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetos.neu.demooo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.model.LiuJinHe;</span><br><span class="line"><span class="keyword">import</span> org.jetos.neu.demooo.service.LiuJinHeService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiuJinHeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LiuJinHeService liuJinHeService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LiuJinHeController</span><span class="params">(LiuJinHeService liuJinHeService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liuJinHeService = liuJinHeService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findById&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LiuJinHe <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> liuJinHeService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遇到问题：SELECT-command-denied-to-user-‘myuser‘-’172-22-0-1’-for-table-‘LiuJinHe’"><a href="#遇到问题：SELECT-command-denied-to-user-‘myuser‘-’172-22-0-1’-for-table-‘LiuJinHe’" class="headerlink" title="遇到问题：SELECT command denied to user ‘myuser‘@’172.22.0.1’ for table ‘LiuJinHe’"></a>遇到问题：SELECT command denied to user ‘myuser‘@’172.22.0.1’ for table ‘LiuJinHe’</h2><ul><li>用户没有权限，删除compose.yml中mysql的envi的用户名和密码，只保留根用户密码</li></ul><h2 id="Bean扫描及注册"><a href="#Bean扫描及注册" class="headerlink" title="Bean扫描及注册"></a>Bean扫描及注册</h2><p>启动类所在的包是根包，Spring Boot会自动扫描根包下及其子包下的所有类，查找带有<code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>等注解的类，并将它们注册为Bean。<br>如果要注册的Bean对象来自于第三方库，是不能添加注解的，这时可以使用<code>@Bean</code>、<code>@Import</code>等注解来注册Bean。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot的一些项目依赖</title>
      <link href="/2024/09/26/docker-compose/"/>
      <url>/2024/09/26/docker-compose/</url>
      
        <content type="html"><![CDATA[<h1 id="创建项目依赖（单体服务器）："><a href="#创建项目依赖（单体服务器）：" class="headerlink" title="创建项目依赖（单体服务器）："></a>创建项目依赖（单体服务器）：</h1><h2 id="Docker-Compose-Support"><a href="#Docker-Compose-Support" class="headerlink" title="Docker Compose Support"></a>Docker Compose Support</h2><p>项目会自动创建一个名为<code>compose.yaml</code>的Docker Compose文件。在这个文件中，已经定义了以下服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;mysql:latest&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;MYSQL_DATABASE=mydatabase&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;MYSQL_PASSWORD=secret&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;MYSQL_ROOT_PASSWORD=verysecret&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;MYSQL_USER=myuser&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;3306:3306&#x27;</span>  <span class="comment"># x:y x是宿主机端口，y是容器端口</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;rabbitmq:latest&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;RABBITMQ_DEFAULT_PASS=secret&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;RABBITMQ_DEFAULT_USER=myuser&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;5672:5672&#x27;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;redis:latest&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;6379:6379&#x27;</span></span><br></pre></td></tr></table></figure><p>services是一个列表，包含了所有的服务。每个服务都有一个名称，如mysql、rabbitmq、redis等。每个服务都有一个image属性，指定了服务的镜像。每个服务都有一个environment属性，指定了服务的环境变量。每个服务都有一个ports属性，指定了服务的端口。</p><ul><li>mysql: <a href="https://hub.docker.com/_/mysql"><code>mysql:latest</code></a> 这是一个MySQL数据库的镜像</li><li>rabbitmq: <a href="https://hub.docker.com/_/rabbitmq"><code>rabbitmq:latest</code></a> 这是一个RabbitMQ消息队列的镜像，用于异步消息处理</li><li>redis: <a href="https://hub.docker.com/_/redis"><code>redis:latest</code></a> 这是一个Redis缓存的镜像，用于缓存数据</li></ul><p>以这个映像为载体（核心）创建一个环境，然后在这个环境中运行应用程序。这样就可以在开发环境中运行应用程序，而不用担心环境的问题。</p><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p>Lombok是一个Java库，可以通过注解的方式来简化Java代码。在SpringBoot项目中，可以通过Lombok来简化实体类的编写。<br>详情链接：<a href="https://projectlombok.org/features">Lombok</a></p><h2 id="Spring-Boot-DevTools"><a href="#Spring-Boot-DevTools" class="headerlink" title="Spring Boot DevTools"></a>Spring Boot DevTools</h2><p>Spring Boot DevTools是一个开发工具，它可以提高开发人员的开发效率。它提供了一些开发工具，如自动重启、热部署等。<br>我暂时用不上</p><h2 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h2><p>Spring Web是Spring框架的一个模块，它提供了一些Web开发的功能，如控制器、视图解析器等。<br>有了它，就可以在SpringBoot项目中开发Web应用程序。</p><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p>Java Database Connectivity (JDBC) API是Java数据库连接的API，它提供了一些接口和类，用于连接数据库、执行SQL语句等。</p><h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h2><p>JPQL（Java Persistence Query Language）,是一种面向对象的查询语言，它类似于SQL，但是更加面向对象。</p><p>Java Persistence API &#x2F; Jakarta Persistence API<br>Spring Data JPA是Spring框架的一个模块，它提供了一些JPA的功能，如实体管理、事务管理等。</p><h2 id="Rest-Repositories"><a href="#Rest-Repositories" class="headerlink" title="Rest Repositories"></a>Rest Repositories</h2><p>Rest Repositories是Spring框架的一个模块，它提供了一些RESTful风格的资源库，用于访问数据。</p><p>什么是REST风格？ REST是一种软件架构风格，它是一种设计原则，用于构建分布式系统。RESTful是一种设计风格，用于构建RESTful风格的Web服务。RESTful风格的Web服务是一种基于HTTP协议的Web服务，它使用HTTP协议的方法来操作资源，如GET（查）、POST（增）、PUT（改）、DELETE（删）等。</p><h2 id="Rest-Repositories-HAL-Browser"><a href="#Rest-Repositories-HAL-Browser" class="headerlink" title="Rest Repositories HAL Browser"></a>Rest Repositories HAL Browser</h2><p>Rest Repositories HAL Browser是一个RESTful风格的资源库，用于访问数据。</p><h2 id="Spring-Data-Redis-Access-Driver"><a href="#Spring-Data-Redis-Access-Driver" class="headerlink" title="Spring Data Redis (Access+Driver)"></a>Spring Data Redis (Access+Driver)</h2><p>Spring Data Redis是Spring框架的一个模块，它提供了一些Redis的功能，如连接Redis、操作Redis等。</p><h2 id="MySQL-Driver"><a href="#MySQL-Driver" class="headerlink" title="MySQL Driver"></a>MySQL Driver</h2><h2 id="MyBatis-Framework"><a href="#MyBatis-Framework" class="headerlink" title="MyBatis Framework"></a>MyBatis Framework</h2><p>MyBatis Framework是一个持久层框架，它可以简化数据库操作，提高开发效率。</p><h2 id="Quartz-Scheduler"><a href="#Quartz-Scheduler" class="headerlink" title="Quartz Scheduler"></a>Quartz Scheduler</h2><p>Quartz Scheduler是一个调度框架，它可以用于定时任务、异步任务等。</p><p>什么是cron表达式？<br>cron表达式是一种时间表达式，用于指定任务的执行时间。它由6个字段组成，分别表示秒、分、时、日、月、周。每个字段都有一个取值范围，如秒的取值范围是0-59，分的取值范围是0-59，时的取值范围是0-23，日的取值范围是1-31，月的取值范围是1-12，周的取值范围是0-6。cron表达式可以指定任务的执行时间，</p><p>例如：每天凌晨1点执行一次任务，可以使用<code>0 0 1 * * ?</code>；</p><p>每天凌晨1点到2点之间每分钟执行一次任务，可以使用<code>0 0-59 1 * * ?</code>；</p><p>每天凌晨1点到2点之间每5分钟执行一次任务，可以使用<code>0 0/5 1 * * ?</code>；</p><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>Spring Security是Spring框架的一个模块，它提供了一些安全功能，如认证、授权等。</p><h2 id="Java-Mail-Sender"><a href="#Java-Mail-Sender" class="headerlink" title="Java Mail Sender"></a>Java Mail Sender</h2><p>Java Mail Sender是一个邮件发送工具，它可以用于发送邮件。</p><p>Thymeleaf是一个模板引擎，它可以用于生成HTML页面。结合Java Mail Sender，可以用于发送HTML邮件。</p><h2 id="Spring-for-RabbitMQ"><a href="#Spring-for-RabbitMQ" class="headerlink" title="Spring for RabbitMQ"></a>Spring for RabbitMQ</h2><p>Spring for RabbitMQ是Spring框架的一个模块，它提供了一些RabbitMQ的功能，如连接RabbitMQ、操作RabbitMQ等。<br>RabbitMQ是一个消息队列，它可以用于异步消息处理。<br>实际案例：用户注册时，发送一封邮件给用户，告知用户注册成功，可以使用RabbitMQ来实现异步消息处理，队列里面存放用户注册的消息，消费者监听队列，当有消息时，发送邮件给用户。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker Compose </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to Skye&#39;s Cottage!</title>
      <link href="/2024/09/23/hello-world/"/>
      <url>/2024/09/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>🌲 Deep in a secluded valley, far from the hustle and bustle of the world, there stands a tiny wooden cottage, surrounded by lush green forests and twinkling stars. This is Skye’s Cottage, the cozy home of a programmer who—let’s be honest—isn’t exactly great at magic. 🧙‍♀️💻</p><p>Skye is a little wizard who loves tinkering with computers, but whether it’s casting spells or writing code, she always seems to mess things up. Her magic doesn’t make broomsticks fly—it gets them stuck in tree branches, wobbling helplessly. And her code? Well, let’s just say her screen is often flooded with red error messages, as if mocking her “noob” status. 🚨❌</p><p>But Skye never gives up. 💪 Every morning, she powers up her ancient laptop, determined to fix yesterday’s catastrophic bug. Outside, birds chirp and the wind whispers through the trees, as if cheering her on. 🎶🍃 Even when she sits on the cottage steps, staring into the distance and sighing, “Where did I go wrong this time?”, the fire in her heart never fades. 🔥❤️</p><p>She knows that whether it’s magic or programming, failure is just another step toward success. Every time she squashes a tiny bug, she celebrates like she’s just defeated a mighty magical beast. 🎉🐉 And even though she’s got a long way to go before becoming a legendary coder, she understands that the real magic lies in the journey itself. ✨🚀</p><p>Welcome to Skye’s Cottage—a world where magic and code coexist. 💻🔮 Whether you’re looking for an escape from reality or a spark of programming inspiration, step inside this cozy little home. Who knows? You might just realize that there’s no problem in the world that a simple restart can’t fix. And if there is… well, just restart a few more times. 😉🔄</p><img src="\images\tale.png" width=70%>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
